/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const _STDINT_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __GNU_LIBRARY__: u32 = 6;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _REQUIRES_FREESTANDING_H: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _PSTL_VERSION: u32 = 12000;
pub const _PSTL_VERSION_MAJOR: u32 = 12;
pub const _PSTL_VERSION_MINOR: u32 = 0;
pub const _PSTL_VERSION_PATCH: u32 = 0;
pub const _PSTL_USAGE_WARNINGS: u32 = 0;
pub const _PSTL_UDR_PRESENT: u32 = 0;
pub const _PSTL_PRAGMA_LOCATION: &[u8; 26] = b" [Parallel STL message]: \0";
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __FP_LONG_MAX: u64 = 9223372036854775807;
pub const FP_LLOGB0: i64 = -9223372036854775808;
pub const FP_LLOGBNAN: i64 = -9223372036854775808;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_Ef: f64 = 2.718281828459045;
pub const M_LOG2Ef: f64 = 1.4426950408889634;
pub const M_LOG10Ef: f64 = 0.4342944819032518;
pub const M_LN2f: f64 = 0.6931471805599453;
pub const M_LN10f: f64 = 2.302585092994046;
pub const M_PIf: f64 = 3.141592653589793;
pub const M_PI_2f: f64 = 1.5707963267948966;
pub const M_PI_4f: f64 = 0.7853981633974483;
pub const M_1_PIf: f64 = 0.3183098861837907;
pub const M_2_PIf: f64 = 0.6366197723675814;
pub const M_2_SQRTPIf: f64 = 1.1283791670955126;
pub const M_SQRT2f: f64 = 1.4142135623730951;
pub const M_SQRT1_2f: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const __cpp_lib_hypot: u32 = 201603;
pub const __STDCPP_MATH_SPEC_FUNCS__: u32 = 201003;
pub const __cpp_lib_math_special_functions: u32 = 201603;
pub const _STL_ALGOBASE_H: u32 = 1;
pub const _FUNCTEXCEPT_H: u32 = 1;
pub const _EXCEPTION_DEFINES_H: u32 = 1;
pub const _EXT_NUMERIC_TRAITS: u32 = 1;
pub const _STL_PAIR_H: u32 = 1;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const _MOVE_H: u32 = 1;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
pub const _CONCEPT_CHECK_H: u32 = 1;
pub const _STL_ITERATOR_H: u32 = 1;
pub const _PTR_TRAITS_H: u32 = 1;
pub const __cpp_lib_array_constexpr: u32 = 201803;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ROCBLAS_VERSION_MAJOR: u32 = 4;
pub const ROCBLAS_VERSION_MINOR: u32 = 3;
pub const ROCBLAS_VERSION_PATCH: u32 = 0;
pub const ROCSOLVER_VERSION_MAJOR: u32 = 3;
pub const ROCSOLVER_VERSION_MINOR: u32 = 27;
pub const ROCSOLVER_VERSION_PATCH: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " \\brief Used to specify the logging layer mode using a bitwise combination\nof rocblas_layer_mode values."]
pub type rocblas_layer_mode_flags = u32;
#[doc = "< Enable logging for kernel calls."]
pub const rocblas_layer_mode_ex__rocblas_layer_mode_ex_log_kernel: rocblas_layer_mode_ex_ = 16;
#[doc = " \\brief Used to expand the logging layer modes offered for rocSOLVER logging."]
pub type rocblas_layer_mode_ex_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to expand the logging layer modes offered for rocSOLVER logging."]
pub use self::rocblas_layer_mode_ex_ as rocblas_layer_mode_ex;
#[doc = "< Householder matrices applied from the right."]
pub const rocblas_direct__rocblas_forward_direction: rocblas_direct_ = 171;
#[doc = "< Householder matrices applied from the left."]
pub const rocblas_direct__rocblas_backward_direction: rocblas_direct_ = 172;
#[doc = " \\brief Used to specify the order in which multiple Householder matrices are\napplied together"]
pub type rocblas_direct_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify the order in which multiple Householder matrices are\napplied together"]
pub use self::rocblas_direct_ as rocblas_direct;
#[doc = "< Householder vectors are stored in the columns of a matrix."]
pub const rocblas_storev__rocblas_column_wise: rocblas_storev_ = 181;
#[doc = "< Householder vectors are stored in the rows of a matrix."]
pub const rocblas_storev__rocblas_row_wise: rocblas_storev_ = 182;
#[doc = " \\brief Used to specify how householder vectors are stored in a matrix of\nvectors"]
pub type rocblas_storev_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify how householder vectors are stored in a matrix of\nvectors"]
pub use self::rocblas_storev_ as rocblas_storev;
#[doc = "< The entire associated orthogonal/unitary matrix is computed."]
pub const rocblas_svect__rocblas_svect_all: rocblas_svect_ = 191;
#[doc = "< Only the singular vectors are computed and\nstored in output array."]
pub const rocblas_svect__rocblas_svect_singular: rocblas_svect_ = 192;
#[doc = "< Only the singular vectors are computed and\noverwrite the input matrix."]
pub const rocblas_svect__rocblas_svect_overwrite: rocblas_svect_ = 193;
#[doc = "< No singular vectors are computed."]
pub const rocblas_svect__rocblas_svect_none: rocblas_svect_ = 194;
#[doc = " \\brief Used to specify how the singular vectors are to be computed and\nstored"]
pub type rocblas_svect_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify how the singular vectors are to be computed and\nstored"]
pub use self::rocblas_svect_ as rocblas_svect;
#[doc = "< Out-of-place computations are allowed; this\nrequires extra device memory for workspace."]
pub const rocblas_workmode__rocblas_outofplace: rocblas_workmode_ = 201;
#[doc = "< If not enough memory is available, this forces in-place computations."]
pub const rocblas_workmode__rocblas_inplace: rocblas_workmode_ = 202;
#[doc = " \\brief Used to enable the use of fast algorithms (with out-of-place\ncomputations) in some of the routines"]
pub type rocblas_workmode_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to enable the use of fast algorithms (with out-of-place\ncomputations) in some of the routines"]
pub use self::rocblas_workmode_ as rocblas_workmode;
#[doc = "< Compute eigenvectors for the original symmetric/Hermitian\nmatrix."]
pub const rocblas_evect__rocblas_evect_original: rocblas_evect_ = 211;
#[doc = "< Compute eigenvectors for the symmetric tridiagonal\nmatrix."]
pub const rocblas_evect__rocblas_evect_tridiagonal: rocblas_evect_ = 212;
#[doc = "< No eigenvectors are computed."]
pub const rocblas_evect__rocblas_evect_none: rocblas_evect_ = 213;
#[doc = " \\brief Used to specify how the eigenvectors are to be computed"]
pub type rocblas_evect_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify how the eigenvectors are to be computed"]
pub use self::rocblas_evect_ as rocblas_evect;
#[doc = "< The problem is \\f$Ax = \\lambda Bx\\f$."]
pub const rocblas_eform__rocblas_eform_ax: rocblas_eform_ = 221;
#[doc = "< The problem is \\f$ABx = \\lambda x\\f$."]
pub const rocblas_eform__rocblas_eform_abx: rocblas_eform_ = 222;
#[doc = "< The problem is \\f$BAx = \\lambda x\\f$."]
pub const rocblas_eform__rocblas_eform_bax: rocblas_eform_ = 223;
#[doc = " \\brief Used to specify the form of the generalized eigenproblem"]
pub type rocblas_eform_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify the form of the generalized eigenproblem"]
pub use self::rocblas_eform_ as rocblas_eform;
#[doc = "< All eigenvalues will be found."]
pub const rocblas_erange__rocblas_erange_all: rocblas_erange_ = 231;
#[doc = "< All eigenvalues in the half-open interval\n\\f$(vl, vu]\\f$ will be found."]
pub const rocblas_erange__rocblas_erange_value: rocblas_erange_ = 232;
#[doc = "< The \\f$il\\f$-th through \\f$iu\\f$-th eigenvalues will be found."]
pub const rocblas_erange__rocblas_erange_index: rocblas_erange_ = 233;
#[doc = " \\brief Used to specify the type of range in which eigenvalues will be found\nin partial eigenvalue decompositions"]
pub type rocblas_erange_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify the type of range in which eigenvalues will be found\nin partial eigenvalue decompositions"]
pub use self::rocblas_erange_ as rocblas_erange;
#[doc = "< The computed eigenvalues will be grouped by split-off\nblocks and arranged in increasing order within each block."]
pub const rocblas_eorder__rocblas_eorder_blocks: rocblas_eorder_ = 241;
#[doc = "< All computed eigenvalues of the entire matrix will be\nordered from smallest to largest."]
pub const rocblas_eorder__rocblas_eorder_entire: rocblas_eorder_ = 242;
#[doc = " \\brief Used to specify whether the eigenvalues are grouped and ordered by blocks"]
pub type rocblas_eorder_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify whether the eigenvalues are grouped and ordered by blocks"]
pub use self::rocblas_eorder_ as rocblas_eorder;
#[doc = "< The computed eigenvalues will not be sorted."]
pub const rocblas_esort__rocblas_esort_none: rocblas_esort_ = 251;
#[doc = "< The computed eigenvalues will be sorted in ascending order."]
pub const rocblas_esort__rocblas_esort_ascending: rocblas_esort_ = 252;
#[doc = " \\brief Used in the Jacobi methods to specify whether the eigenvalues are sorted\nin increasing order"]
pub type rocblas_esort_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used in the Jacobi methods to specify whether the eigenvalues are sorted\nin increasing order"]
pub use self::rocblas_esort_ as rocblas_esort;
#[doc = "< All singular values will be found."]
pub const rocblas_srange__rocblas_srange_all: rocblas_srange_ = 261;
#[doc = "< All singular values in the half-open interval\n\\f$(vl, vu]\\f$ will be found."]
pub const rocblas_srange__rocblas_srange_value: rocblas_srange_ = 262;
#[doc = "< The \\f$il\\f$-th through \\f$iu\\f$-th singular values will be found."]
pub const rocblas_srange__rocblas_srange_index: rocblas_srange_ = 263;
#[doc = " \\brief Used to specify the type of range in which singular values will be found\nin partial singular value decompositions"]
pub type rocblas_srange_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify the type of range in which singular values will be found\nin partial singular value decompositions"]
pub use self::rocblas_srange_ as rocblas_srange;
#[doc = " \\brief Forward-declaration of opaque struct containing data used for the re-factorization interfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocsolver_rfinfo_ {
    _unused: [u8; 0],
}
#[doc = " \\brief A handle to a structure containing matrix descriptors and metadata required to interact\nwith rocSPARSE when using the rocSOLVER re-factorization functionality. It needs to be initialized\nwith \\ref rocsolver_create_rfinfo and destroyed with \\ref rocsolver_destroy_rfinfo."]
pub type rocsolver_rfinfo = *mut rocsolver_rfinfo_;
pub const rocsolver_rfinfo_mode__rocsolver_rfinfo_mode_lu: rocsolver_rfinfo_mode_ = 271;
pub const rocsolver_rfinfo_mode__rocsolver_rfinfo_mode_cholesky: rocsolver_rfinfo_mode_ = 272;
#[doc = " \\brief Used to specify the mode of the rfinfo struct required by the re-factorization functionality."]
pub type rocsolver_rfinfo_mode_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify the mode of the rfinfo struct required by the re-factorization functionality."]
pub use self::rocsolver_rfinfo_mode_ as rocsolver_rfinfo_mode;
#[doc = " \\brief Struct to represent a 16 bit Brain floating-point number."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_bfloat16 {
    pub data: u16,
}
#[doc = " \\brief Struct to represent a 8 bit floating-point number."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_f8 {
    pub data: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_bf8 {
    pub data: u8,
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___true_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___false_type {
    pub _address: u8,
}
pub type std___truth_type___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 = 0;
pub type std___traitor__bindgen_ty_1 = i32;
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 = 0;
pub type std___are_same__bindgen_ty_1 = i32;
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 = 0;
pub type std___is_void__bindgen_ty_1 = i32;
pub type std___is_void___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 = 0;
pub type std___is_integer__bindgen_ty_1 = i32;
pub type std___is_integer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 = 0;
pub type std___is_floating__bindgen_ty_1 = i32;
pub type std___is_floating___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 = 0;
pub type std___is_pointer__bindgen_ty_1 = i32;
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 = 0;
pub type std___is_char__bindgen_ty_1 = i32;
pub type std___is_char___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 = 0;
pub type std___is_byte__bindgen_ty_1 = i32;
pub type std___is_byte___type = std___false_type;
pub type std_byte = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nonvolatile_trivially_copyable {
    pub _address: u8,
}
pub const std___is_nonvolatile_trivially_copyable___value:
    std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = 0;
pub type std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcpyable {
    pub _address: u8,
}
pub const std___memcpyable___value: std___memcpyable__bindgen_ty_1 = 0;
pub type std___memcpyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcmpable {
    pub _address: u8,
}
pub const std___memcmpable___value: std___memcmpable__bindgen_ty_1 = 0;
pub type std___memcmpable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1 = 0;
pub type std___is_move_iterator__bindgen_ty_1 = i32;
pub type std___is_move_iterator___type = std___false_type;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt28__throw_bad_array_new_lengthv"]
    pub fn std___throw_bad_array_new_length() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper {
    pub _address: u8,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
pub type std_bool_constant = u8;
pub type std___enable_if_t = u8;
pub type std___conditional_type<_Tp> = _Tp;
pub type std___conditional_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
pub type std___type_identity_t = std___type_identity;
pub type std___detail___first_t<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___disjunction_impl {
    pub _address: u8,
}
pub type std___detail___disjunction_impl_type<_B1> = _B1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___conjunction_impl {
    pub _address: u8,
}
pub type std___detail___conjunction_impl_type<_B1> = _B1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___floating_point_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___numeric_constants {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_conjunction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_disjunction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negation {
    pub _address: u8,
}
pub type std___remove_cv_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _base: std_is_null_pointer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
pub type std___is_one_of = std___or_;
pub type std___is_signed_integer = std___is_one_of;
pub type std___is_unsigned_integer = std___is_one_of;
pub type std___is_standard_integer = std___or_;
pub type std___void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
pub type std___is_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_lvalue_reference_helper {
    pub _address: u8,
}
pub type std___add_lvalue_reference_helper_type<_Tp> = _Tp;
pub type std___add_lval_ref_t = std___add_lvalue_reference_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_rvalue_reference_helper {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type<_Tp> = _Tp;
pub type std___add_rval_ref_t = std___add_rvalue_reference_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
pub type std___is_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
pub type std___is_nothrow_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
pub type std___is_trivially_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
pub type std___is_trivially_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___is_array_convertible = std_is_convertible;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Tp> = _Tp;
pub type std_remove_const_t = std_remove_const;
pub type std_remove_volatile_t = std_remove_volatile;
pub type std_remove_cv_t = std_remove_cv;
pub type std_add_const_t = std_add_const;
pub type std_add_volatile_t = std_add_volatile;
pub type std_add_cv_t = std_add_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = std___add_lval_ref_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = std___add_rval_ref_t;
pub type std_remove_reference_t = std_remove_reference;
pub type std_add_lvalue_reference_t = std_add_lvalue_reference;
pub type std_add_rvalue_reference_t = std_add_rvalue_reference;
pub type std___match_cv_qualifiers___match = u8;
pub type std___match_cv_qualifiers___type = std___match_cv_qualifiers___match;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base__List {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
pub type std_make_unsigned_t = std_make_unsigned;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std_remove_extent_t = std_remove_extent;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_pointer_helper {
    pub _address: u8,
}
pub type std___add_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_t = std_remove_pointer;
pub type std_add_pointer_t = std_add_pointer;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std___aligned_storage_msa___type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union___strictest = std___strictest_alignment;
pub type std_aligned_union_type = u8;
unsafe extern "C" {
    #[link_name = "\u{1}alignment_value"]
    pub static std_alignment_value: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___decay_selector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay_type = std___decay_selector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
pub type std___decay_t = std_decay;
pub type std___decay_and_strip = std___strip_reference_wrapper;
pub type std__Require = std___enable_if_t;
pub type std___remove_cvref_t = std_remove_cv;
pub type std_conditional_type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
pub type std___do_common_type_impl___cond_t<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_pack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_fold {
    pub _address: u8,
}
pub type std___underlying_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type<_Tag> = _Tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type<_Tp> = _Tp;
pub type std___result_of_impl_type = std___failure_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_t = u8;
pub type std_decay_t = std_decay;
pub type std_enable_if_t = u8;
pub type std_conditional_t = u8;
pub type std_common_type_t = std_common_type;
pub type std_underlying_type_t = std_underlying_type;
pub type std_result_of_t = std_result_of;
pub type std_void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_type<_Default> = _Default;
pub type std___detector___is_detected = std_false_type;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_swappable_with_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_nothrow_swappable_with_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable_with {
    pub _address: u8,
}
pub type std___is_invocable_impl___nothrow_conv = std_false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = std___call_is_nothrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuchbase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_invoke_result {
    pub _address: u8,
}
pub type std_invoke_result_t = std_invoke_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable {
    pub _address: u8,
}
pub type std___is_nt_invocable_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_unique_object_representations {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_aggregate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size<_Tp> = _Tp;
pub type std___tuple_element_t = u8;
pub type std_tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
pub type std_integer_sequence_value_type<_Tp> = _Tp;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = std_make_integer_sequence;
pub type std_index_sequence_for = std_make_index_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_t {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt8in_place"]
    pub static std_in_place: std_in_place_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_type_t {
    pub _address: u8,
}
pub type std___is_in_place_type = std_bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
    pub first: _T1,
    pub second: _T2,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std___iter_category_t = std_iterator_traits;
pub type std__RequireInputIter = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_random_access_iter {
    pub _address: u8,
}
pub type std___is_random_access_iter__Base = std_is_base_of;
pub const std___is_random_access_iter___value: std___is_random_access_iter__bindgen_ty_1 = 0;
pub type std___is_random_access_iter__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_elem {
    pub _address: u8,
}
pub type std___ptr_traits_elem_t = std___ptr_traits_elem;
pub type std___ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_ptr_to_element_type<_Elt> = _Elt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_impl {
    pub _address: u8,
}
pub type std___ptr_traits_impl___diff_t = __BindgenOpaqueArray<u8, 0usize>;
pub type std___ptr_traits_impl___rebind = std___type_identity;
pub type std___ptr_traits_impl_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_impl_element_type<_Elt> = _Elt;
pub type std___ptr_traits_impl_difference_type = std___detected_or_t;
pub type std___ptr_traits_impl_rebind = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std___ptr_rebind = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub current: _Iterator,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
}
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
}
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
    pub iter: std_insert_iterator__Iter,
}
pub type std_insert_iterator__Iter = __BindgenOpaqueArray<u8, 0usize>;
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub _M_current: _Iterator,
}
pub type std_move_iterator___traits_type = std_iterator_traits;
pub type std_move_iterator___base_ref = std_move_iterator___traits_type;
pub type std_move_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_move_iterator_iterator_category = std_move_iterator___traits_type;
pub type std_move_iterator_value_type = std_move_iterator___traits_type;
pub type std_move_iterator_difference_type = std_move_iterator___traits_type;
pub type std_move_iterator_pointer<_Iterator> = _Iterator;
pub type std_move_iterator_reference = std___conditional_t;
pub type std___iter_key_t = std_remove_const_t;
pub type std___iter_val_t = std_iterator_traits;
pub type std___iter_to_alloc_t = std_pair<std___iter_key_t, std___iter_val_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Deque_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt9__fill_a1St13_Bit_iteratorS_RKb"]
    pub fn std___fill_a1(arg1: std__Bit_iterator, arg2: std__Bit_iterator, arg3: *const bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_limits_base {
    pub _address: u8,
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
pub const FP_INT_UPWARD: _bindgen_ty_1 = 0;
pub const FP_INT_DOWNWARD: _bindgen_ty_1 = 1;
pub const FP_INT_TOWARDZERO: _bindgen_ty_1 = 2;
pub const FP_INT_TONEARESTFROMZERO: _bindgen_ty_1 = 3;
pub const FP_INT_TONEAREST: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
unsafe extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn nextdown(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextdown(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextup(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextup(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogb(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogb(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundeven(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __roundeven(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalize(__cx: *mut f64, __x: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaxmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn totalorder(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermag(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayload(__x: *const f64) -> f64;
}
unsafe extern "C" {
    pub fn __getpayload(__x: *const f64) -> f64;
}
unsafe extern "C" {
    pub fn setpayload(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsig(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
unsafe extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn nextdownf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextdownf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextupf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextupf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundevenf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundevenf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef(__cx: *mut f32, __x: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn totalorderf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf(__x: *const f32) -> f32;
}
unsafe extern "C" {
    pub fn __getpayloadf(__x: *const f32) -> f32;
}
unsafe extern "C" {
    pub fn setpayloadf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
unsafe extern "C" {
    pub fn __sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn exp10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextdownl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextdownl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextupl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextupl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundevenl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundevenl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizel(__cx: *mut u128, __x: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn totalorderl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadl(__x: *const u128) -> u128;
}
unsafe extern "C" {
    pub fn __getpayloadl(__x: *const u128) -> u128;
}
unsafe extern "C" {
    pub fn setpayloadl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn acosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __acosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn asinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __asinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn cosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __cosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn coshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __coshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
unsafe extern "C" {
    pub fn __sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
unsafe extern "C" {
    pub fn acoshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __acoshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn asinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __asinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn expf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __expf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn logf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __logf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn exp10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __exp10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn expm1f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __expm1f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log1pf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log1pf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn logbf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __logbf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn exp2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __exp2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sqrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sqrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn cbrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __cbrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn ceilf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __ceilf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fabsf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fabsf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn floorf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __floorf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
unsafe extern "C" {
    pub fn __nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
unsafe extern "C" {
    pub fn j0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __j0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn j1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __j1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn y0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __y0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn y1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __y1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn erff32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __erff32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn erfcf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __erfcf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn lgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __lgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn rintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __rintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextdownf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextdownf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextupf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextupf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
unsafe extern "C" {
    pub fn __scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
unsafe extern "C" {
    pub fn nearbyintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nearbyintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn roundf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __roundf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn truncf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __truncf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int)
        -> _Float32;
}
unsafe extern "C" {
    pub fn lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn roundevenf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __roundevenf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef32(__cx: *mut _Float32, __x: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn totalorderf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf32(__x: *const _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __getpayloadf32(__x: *const _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn setpayloadf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __acosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn asinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __asinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn cosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __cosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn coshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __coshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
unsafe extern "C" {
    pub fn __sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
unsafe extern "C" {
    pub fn acoshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __acoshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn asinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __asinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn expf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __expf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn logf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __logf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn exp10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __exp10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn expm1f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __expm1f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log1pf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log1pf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn logbf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __logbf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn exp2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __exp2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sqrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sqrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn cbrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __cbrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn ceilf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __ceilf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fabsf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fabsf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn floorf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __floorf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
unsafe extern "C" {
    pub fn __nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
unsafe extern "C" {
    pub fn j0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __j0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn j1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __j1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn y0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __y0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn y1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __y1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn erff64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __erff64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn erfcf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __erfcf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn lgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __lgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn rintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __rintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextdownf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextdownf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextupf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextupf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
unsafe extern "C" {
    pub fn __scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
unsafe extern "C" {
    pub fn nearbyintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nearbyintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn roundf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __roundf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn truncf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __truncf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int)
        -> _Float64;
}
unsafe extern "C" {
    pub fn lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn roundevenf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __roundevenf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef64(__cx: *mut _Float64, __x: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn totalorderf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf64(__x: *const _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __getpayloadf64(__x: *const _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn setpayloadf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __acosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn asinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __asinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn cosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __cosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn coshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __coshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
unsafe extern "C" {
    pub fn __sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
unsafe extern "C" {
    pub fn acoshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __acoshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn asinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __asinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn expf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __expf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn logf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __logf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn exp10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __exp10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn expm1f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __expm1f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log1pf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log1pf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn logbf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __logbf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn exp2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __exp2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sqrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sqrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn cbrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __cbrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn ceilf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ceilf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fabsf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fabsf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn floorf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __floorf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
unsafe extern "C" {
    pub fn j0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __j0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn j1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __j1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn y0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __y0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn y1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __y1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn erff32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __erff32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn erfcf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __erfcf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn lgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __lgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn rintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __rintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextdownf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextdownf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextupf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextupf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
unsafe extern "C" {
    pub fn __scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
unsafe extern "C" {
    pub fn nearbyintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nearbyintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn roundf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __roundf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn truncf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __truncf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn __remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn roundevenf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __roundevenf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef32x(__cx: *mut _Float32x, __x: *const _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn totalorderf32x(__x: *const _Float32x, __y: *const _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf32x(__x: *const _Float32x, __y: *const _Float32x)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn setpayloadf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __acosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn asinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __asinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn cosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __cosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn coshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __coshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
unsafe extern "C" {
    pub fn __sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
unsafe extern "C" {
    pub fn acoshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __acoshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn asinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __asinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn expf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __expf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn logf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __logf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn exp10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __exp10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn expm1f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __expm1f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log1pf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log1pf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn logbf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __logbf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn exp2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __exp2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sqrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sqrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn cbrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __cbrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn ceilf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ceilf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fabsf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fabsf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn floorf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __floorf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
unsafe extern "C" {
    pub fn j0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __j0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn j1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __j1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn y0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __y0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn y1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __y1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn erff64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __erff64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn erfcf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __erfcf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn lgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __lgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn rintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __rintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextdownf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextdownf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextupf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextupf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
unsafe extern "C" {
    pub fn __scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
unsafe extern "C" {
    pub fn nearbyintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nearbyintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn roundf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __roundf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn truncf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __truncf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn __remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn roundevenf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __roundevenf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef64x(__cx: *mut _Float64x, __x: *const _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn totalorderf64x(__x: *const _Float64x, __y: *const _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf64x(__x: *const _Float64x, __y: *const _Float64x)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn setpayloadf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fadd(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fdiv(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn ffma(__x: f64, __y: f64, __z: f64) -> f32;
}
unsafe extern "C" {
    pub fn fmul(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fsqrt(__x: f64) -> f32;
}
unsafe extern "C" {
    pub fn fsub(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn faddl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fdivl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn ffmal(__x: u128, __y: u128, __z: u128) -> f32;
}
unsafe extern "C" {
    pub fn fmull(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fsqrtl(__x: u128) -> f32;
}
unsafe extern "C" {
    pub fn fsubl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn daddl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn ddivl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn dfmal(__x: u128, __y: u128, __z: u128) -> f64;
}
unsafe extern "C" {
    pub fn dmull(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn dsqrtl(__x: u128) -> f64;
}
unsafe extern "C" {
    pub fn dsubl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn f32addf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32sqrtf32x(__x: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32addf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32sqrtf64(__x: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32addf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32sqrtf64x(__x: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32xaddf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xdivf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xfmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xmulf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsqrtf64(__x: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsubf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xaddf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xdivf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xfmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xmulf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsqrtf64x(__x: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsubf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f64addf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64divf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64mulf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64sqrtf64x(__x: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64subf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_2 = 0;
pub const FP_INFINITE: _bindgen_ty_2 = 1;
pub const FP_ZERO: _bindgen_ty_2 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_2 = 3;
pub const FP_NORMAL: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __iscanonicall(__x: u128) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __iseqsig_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtol"]
    pub fn strtol1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoul"]
    pub fn strtoul1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoll"]
    pub fn strtoq1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoull"]
    pub fn strtouq1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtol_l"]
    pub fn strtol_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoul_l"]
    pub fn strtoul_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoll_l"]
    pub fn strtoll_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoull_l"]
    pub fn strtoull_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut u32, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_debug__Safe_iterator {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rocblas_handle {
    _unused: [u8; 0],
}
#[doc = " \\brief rocblas_handle is a structure holding the rocblas library context.\n It must be initialized using rocblas_create_handle(),\n and the returned handle must be passed\n to all subsequent library function calls.\n It should be destroyed at the end using rocblas_destroy_handle()."]
pub type rocblas_handle = *mut _rocblas_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
#[doc = " \\brief Forward declaration of hipStream_t"]
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
#[doc = " \\brief Forward declaration of hipEvent_t"]
pub type hipEvent_t = *mut ihipEvent_t;
#[doc = " \\brief Opaque base class for device memory allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_device_malloc_base {
    _unused: [u8; 0],
}
pub type rocblas_int = i32;
#[doc = " \\brief Stride between matrices or vectors in strided_batched functions"]
pub type rocblas_stride = i64;
#[doc = " \\brief Single precision floating point type"]
pub type rocblas_float = f32;
#[doc = " \\brief Double precision floating point type"]
pub type rocblas_double = f64;
#[doc = " \\brief Structure definition for rocblas_half"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_half {
    pub data: u16,
}
#[doc = " \\brief Struct to represent a complex number with single precision real and imaginary parts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_float_complex {
    pub x: f32,
    pub y: f32,
}
#[doc = " \\brief Struct to represent a complex number with double precision real and imaginary parts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocblas_double_complex {
    pub x: f64,
    pub y: f64,
}
#[doc = "< Operate with the matrix."]
pub const rocblas_operation__rocblas_operation_none: rocblas_operation_ = 111;
#[doc = "< Operate with the transpose of the matrix."]
pub const rocblas_operation__rocblas_operation_transpose: rocblas_operation_ = 112;
pub const rocblas_operation__rocblas_operation_conjugate_transpose: rocblas_operation_ = 113;
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
pub type rocblas_operation_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
pub use self::rocblas_operation_ as rocblas_operation;
#[doc = "< Upper triangle."]
pub const rocblas_fill__rocblas_fill_upper: rocblas_fill_ = 121;
#[doc = "< Lower triangle."]
pub const rocblas_fill__rocblas_fill_lower: rocblas_fill_ = 122;
pub const rocblas_fill__rocblas_fill_full: rocblas_fill_ = 123;
#[doc = " \\brief Used by the Hermitian, symmetric and triangular matrix\n routines to specify whether the upper, or lower triangle is being referenced."]
pub type rocblas_fill_ = ::std::os::raw::c_uint;
#[doc = " \\brief Used by the Hermitian, symmetric and triangular matrix\n routines to specify whether the upper, or lower triangle is being referenced."]
pub use self::rocblas_fill_ as rocblas_fill;
#[doc = "< Non-unit triangular."]
pub const rocblas_diagonal__rocblas_diagonal_non_unit: rocblas_diagonal_ = 131;
#[doc = "< Unit triangular."]
pub const rocblas_diagonal__rocblas_diagonal_unit: rocblas_diagonal_ = 132;
#[doc = " \\brief It is used by the triangular matrix routines to specify whether the\n matrix is unit triangular."]
pub type rocblas_diagonal_ = ::std::os::raw::c_uint;
#[doc = " \\brief It is used by the triangular matrix routines to specify whether the\n matrix is unit triangular."]
pub use self::rocblas_diagonal_ as rocblas_diagonal;
#[doc = "< Multiply general matrix by symmetric,\nHermitian, or triangular matrix on the left."]
pub const rocblas_side__rocblas_side_left: rocblas_side_ = 141;
#[doc = "< Multiply general matrix by symmetric,\nHermitian, or triangular matrix on the right."]
pub const rocblas_side__rocblas_side_right: rocblas_side_ = 142;
pub const rocblas_side__rocblas_side_both: rocblas_side_ = 143;
#[doc = " \\brief Indicates the side matrix A is located relative to matrix B during multiplication."]
pub type rocblas_side_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the side matrix A is located relative to matrix B during multiplication."]
pub use self::rocblas_side_ as rocblas_side;
#[doc = "< 16-bit floating point, real"]
pub const rocblas_datatype__rocblas_datatype_f16_r: rocblas_datatype_ = 150;
#[doc = "< 32-bit floating point, real"]
pub const rocblas_datatype__rocblas_datatype_f32_r: rocblas_datatype_ = 151;
#[doc = "< 64-bit floating point, real"]
pub const rocblas_datatype__rocblas_datatype_f64_r: rocblas_datatype_ = 152;
#[doc = "< 16-bit floating point, complex"]
pub const rocblas_datatype__rocblas_datatype_f16_c: rocblas_datatype_ = 153;
#[doc = "< 32-bit floating point, complex"]
pub const rocblas_datatype__rocblas_datatype_f32_c: rocblas_datatype_ = 154;
#[doc = "< 64-bit floating point, complex"]
pub const rocblas_datatype__rocblas_datatype_f64_c: rocblas_datatype_ = 155;
#[doc = "<  8-bit signed integer, real"]
pub const rocblas_datatype__rocblas_datatype_i8_r: rocblas_datatype_ = 160;
#[doc = "<  8-bit unsigned integer, real"]
pub const rocblas_datatype__rocblas_datatype_u8_r: rocblas_datatype_ = 161;
#[doc = "< 32-bit signed integer, real"]
pub const rocblas_datatype__rocblas_datatype_i32_r: rocblas_datatype_ = 162;
#[doc = "< 32-bit unsigned integer, real"]
pub const rocblas_datatype__rocblas_datatype_u32_r: rocblas_datatype_ = 163;
#[doc = "<  8-bit signed integer, complex"]
pub const rocblas_datatype__rocblas_datatype_i8_c: rocblas_datatype_ = 164;
#[doc = "<  8-bit unsigned integer, complex"]
pub const rocblas_datatype__rocblas_datatype_u8_c: rocblas_datatype_ = 165;
#[doc = "< 32-bit signed integer, complex"]
pub const rocblas_datatype__rocblas_datatype_i32_c: rocblas_datatype_ = 166;
#[doc = "< 32-bit unsigned integer, complex"]
pub const rocblas_datatype__rocblas_datatype_u32_c: rocblas_datatype_ = 167;
#[doc = "< 16-bit bfloat, real"]
pub const rocblas_datatype__rocblas_datatype_bf16_r: rocblas_datatype_ = 168;
#[doc = "< 16-bit bfloat, complex"]
pub const rocblas_datatype__rocblas_datatype_bf16_c: rocblas_datatype_ = 169;
#[doc = "< 8 bit floating point, real"]
pub const rocblas_datatype__rocblas_datatype_f8_r: rocblas_datatype_ = 170;
#[doc = "< 8 bit bfloat, real"]
pub const rocblas_datatype__rocblas_datatype_bf8_r: rocblas_datatype_ = 171;
#[doc = "< Invalid datatype value, do not use"]
pub const rocblas_datatype__rocblas_datatype_invalid: rocblas_datatype_ = 255;
#[doc = " \\brief Indicates the precision width of data stored in a blas type."]
pub type rocblas_datatype_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the precision width of data stored in a blas type."]
pub use self::rocblas_datatype_ as rocblas_datatype;
pub const rocblas_computetype__rocblas_compute_type_f32: rocblas_computetype_ = 300;
pub const rocblas_computetype__rocblas_compute_type_f8_f8_f32: rocblas_computetype_ = 301;
pub const rocblas_computetype__rocblas_compute_type_f8_bf8_f32: rocblas_computetype_ = 302;
pub const rocblas_computetype__rocblas_compute_type_bf8_f8_f32: rocblas_computetype_ = 303;
pub const rocblas_computetype__rocblas_compute_type_bf8_bf8_f32: rocblas_computetype_ = 304;
#[doc = "< Invalid datatype value, do not use"]
pub const rocblas_computetype__rocblas_compute_type_invalid: rocblas_computetype_ = 455;
#[doc = " \\brief Indicates the compute precision mode."]
pub type rocblas_computetype_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates the compute precision mode."]
pub use self::rocblas_computetype_ as rocblas_computetype;
#[doc = "< Success"]
pub const rocblas_status__rocblas_status_success: rocblas_status_ = 0;
#[doc = "< Handle not initialized, invalid or null"]
pub const rocblas_status__rocblas_status_invalid_handle: rocblas_status_ = 1;
#[doc = "< Function is not implemented"]
pub const rocblas_status__rocblas_status_not_implemented: rocblas_status_ = 2;
#[doc = "< Invalid pointer argument"]
pub const rocblas_status__rocblas_status_invalid_pointer: rocblas_status_ = 3;
#[doc = "< Invalid size argument"]
pub const rocblas_status__rocblas_status_invalid_size: rocblas_status_ = 4;
#[doc = "< Failed internal memory allocation, copy or dealloc"]
pub const rocblas_status__rocblas_status_memory_error: rocblas_status_ = 5;
#[doc = "< Other internal library failure"]
pub const rocblas_status__rocblas_status_internal_error: rocblas_status_ = 6;
#[doc = "< Performance degraded due to low device memory"]
pub const rocblas_status__rocblas_status_perf_degraded: rocblas_status_ = 7;
#[doc = "< Unmatched start/stop size query"]
pub const rocblas_status__rocblas_status_size_query_mismatch: rocblas_status_ = 8;
#[doc = "< Queried device memory size increased"]
pub const rocblas_status__rocblas_status_size_increased: rocblas_status_ = 9;
#[doc = "< Queried device memory size unchanged"]
pub const rocblas_status__rocblas_status_size_unchanged: rocblas_status_ = 10;
#[doc = "< Passed argument not valid"]
pub const rocblas_status__rocblas_status_invalid_value: rocblas_status_ = 11;
#[doc = "< Nothing preventing function to proceed"]
pub const rocblas_status__rocblas_status_continue: rocblas_status_ = 12;
pub const rocblas_status__rocblas_status_check_numerics_fail: rocblas_status_ = 13;
pub const rocblas_status__rocblas_status_excluded_from_build: rocblas_status_ = 14;
pub const rocblas_status__rocblas_status_arch_mismatch: rocblas_status_ = 15;
#[doc = "   @brief rocblas status codes definition"]
pub type rocblas_status_ = ::std::os::raw::c_uint;
#[doc = "   @brief rocblas status codes definition"]
pub use self::rocblas_status_ as rocblas_status;
#[doc = " \\brief Scalar values affected by this variable are located on the host."]
pub const rocblas_pointer_mode__rocblas_pointer_mode_host: rocblas_pointer_mode_ = 0;
#[doc = " \\brief Scalar values affected by this variable are located on the device."]
pub const rocblas_pointer_mode__rocblas_pointer_mode_device: rocblas_pointer_mode_ = 1;
#[doc = " \\brief Indicates if scalar pointers are on host or device. This is used for\n    scalars alpha and beta and for scalar function return values."]
pub type rocblas_pointer_mode_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates if scalar pointers are on host or device. This is used for\n    scalars alpha and beta and for scalar function return values."]
pub use self::rocblas_pointer_mode_ as rocblas_pointer_mode;
#[doc = " \\brief Algorithms will refrain from atomics where applicable"]
pub const rocblas_atomics_mode__rocblas_atomics_not_allowed: rocblas_atomics_mode_ = 0;
#[doc = " \\brief Algorithms will take advantage of atomics where applicable"]
pub const rocblas_atomics_mode__rocblas_atomics_allowed: rocblas_atomics_mode_ = 1;
#[doc = " \\brief Indicates if atomics operations are allowed. Not allowing atomic operations\n    may generally improve determinism and repeatability of results at a cost of performance.\n    Defaults to rocblas_atomics_allowed."]
pub type rocblas_atomics_mode_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates if atomics operations are allowed. Not allowing atomic operations\n    may generally improve determinism and repeatability of results at a cost of performance.\n    Defaults to rocblas_atomics_allowed."]
pub use self::rocblas_atomics_mode_ as rocblas_atomics_mode;
#[doc = " \\brief Use Tensile's default performance metric for solution selection"]
pub const rocblas_performance_metric__rocblas_default_performance_metric:
    rocblas_performance_metric_ = 0;
#[doc = " \\brief Select the solution with the highest GFlops across all compute units"]
pub const rocblas_performance_metric__rocblas_device_efficiency_performance_metric:
    rocblas_performance_metric_ = 1;
#[doc = " \\brief Select the solution with the highest GFlops per compute unit it uses. This\n may be useful when running multiple small gemm problems simultaneously"]
pub const rocblas_performance_metric__rocblas_cu_efficiency_performance_metric:
    rocblas_performance_metric_ = 2;
#[doc = " \\brief Indicates which performance metric Tensile uses when selecting the optimal\n    solution for gemm problems."]
pub type rocblas_performance_metric_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates which performance metric Tensile uses when selecting the optimal\n    solution for gemm problems."]
pub use self::rocblas_performance_metric_ as rocblas_performance_metric;
#[doc = " \\brief No logging will take place."]
pub const rocblas_layer_mode__rocblas_layer_mode_none: rocblas_layer_mode_ = 0;
#[doc = " \\brief A line containing the function name and value of arguments passed will be printed with each rocBLAS function call."]
pub const rocblas_layer_mode__rocblas_layer_mode_log_trace: rocblas_layer_mode_ = 1;
#[doc = " \\brief Outputs a line each time a rocBLAS function is called, this line can be used with rocblas-bench to make the same call again."]
pub const rocblas_layer_mode__rocblas_layer_mode_log_bench: rocblas_layer_mode_ = 2;
#[doc = " \\brief Outputs a YAML description of each rocBLAS function called, along with its arguments and number of times it was called."]
pub const rocblas_layer_mode__rocblas_layer_mode_log_profile: rocblas_layer_mode_ = 4;
#[doc = " \\brief Indicates if layer is active with bitmask"]
pub type rocblas_layer_mode_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates if layer is active with bitmask"]
pub use self::rocblas_layer_mode_ as rocblas_layer_mode;
pub const rocblas_gemm_algo__rocblas_gemm_algo_standard: rocblas_gemm_algo_ = 0;
pub const rocblas_gemm_algo__rocblas_gemm_algo_solution_index: rocblas_gemm_algo_ = 1;
#[doc = " \\brief Indicates if layer is active with bitmask"]
pub type rocblas_gemm_algo_ = ::std::os::raw::c_uint;
#[doc = " \\brief Indicates if layer is active with bitmask"]
pub use self::rocblas_gemm_algo_ as rocblas_gemm_algo;
pub const rocblas_geam_ex_operation__rocblas_geam_ex_operation_min_plus:
    rocblas_geam_ex_operation_ = 0;
pub const rocblas_geam_ex_operation__rocblas_geam_ex_operation_plus_min:
    rocblas_geam_ex_operation_ = 1;
#[doc = " \\brief Which mathematical geam-like operation to perform for geam_ex"]
pub type rocblas_geam_ex_operation_ = ::std::os::raw::c_uint;
#[doc = " \\brief Which mathematical geam-like operation to perform for geam_ex"]
pub use self::rocblas_geam_ex_operation_ as rocblas_geam_ex_operation;
#[doc = " \\brief Default empty flags"]
pub const rocblas_gemm_flags__rocblas_gemm_flags_none: rocblas_gemm_flags_ = 0;
#[doc = " \\brief Before ROCm 6.0 rocblas_gemm_flags_pack_int8x4 = 0x1, as has now been removed so is available for future use */\n/*! \\brief Select the gemm problem with the highest efficiency per compute unit used. Useful for running multiple smaller problems\n simultaneously. This takes precedence over the performance metric set in rocblas_handle and currently only works for\n gemm_*_ex problems."]
pub const rocblas_gemm_flags__rocblas_gemm_flags_use_cu_efficiency: rocblas_gemm_flags_ = 2;
#[doc = " \\brief Select an alternate implementation for the MI200 FP16 HPA\n (High Precision Accumulate) GEMM kernel utilizing the BF16 matrix\n instructions with reduced accuracy in cases where computation cannot\n tolerate the FP16 matrix instructions flushing subnormal FP16\n input/output data to zero. See the \"MI200 (gfx90a) Considerations\"\n section for more details."]
pub const rocblas_gemm_flags__rocblas_gemm_flags_fp16_alt_impl: rocblas_gemm_flags_ = 4;
#[doc = " \\brief Select an alternate implementation for the MI200 FP16 HPA\n (High Precision Accumulate) GEMM kernel utilizing the BF16 matrix\n instructions with reduced accuracy in cases where computation cannot\n tolerate the FP16 matrix instructions flushing subnormal FP16\n input/output data to zero. See the \"MI200 (gfx90a) Considerations\"\n section for more details."]
pub const rocblas_gemm_flags__rocblas_gemm_flags_check_solution_index: rocblas_gemm_flags_ = 8;
#[doc = " \\brief Select an alternate implementation for the MI200 FP16 HPA\n (High Precision Accumulate) GEMM kernel utilizing the BF16 matrix\n instructions with reduced accuracy in cases where computation cannot\n tolerate the FP16 matrix instructions flushing subnormal FP16\n input/output data to zero. See the \"MI200 (gfx90a) Considerations\"\n section for more details."]
pub const rocblas_gemm_flags__rocblas_gemm_flags_fp16_alt_impl_rnz: rocblas_gemm_flags_ = 16;
#[doc = " \\brief Select an alternate implementation for the MI200 FP16 HPA\n (High Precision Accumulate) GEMM kernel utilizing the BF16 matrix\n instructions with reduced accuracy in cases where computation cannot\n tolerate the FP16 matrix instructions flushing subnormal FP16\n input/output data to zero. See the \"MI200 (gfx90a) Considerations\"\n section for more details."]
pub const rocblas_gemm_flags__rocblas_gemm_flags_stochastic_rounding: rocblas_gemm_flags_ = 32;
#[doc = " \\brief Control flags passed into gemm algorithms invoked by Tensile Host"]
pub type rocblas_gemm_flags_ = ::std::os::raw::c_uint;
#[doc = " \\brief Control flags passed into gemm algorithms invoked by Tensile Host"]
pub use self::rocblas_gemm_flags_ as rocblas_gemm_flags;
#[doc = " \\brief Union for representing scalar values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rocblas_union_u {
    pub h: rocblas_half,
    pub s: f32,
    pub d: f64,
    pub i: i32,
    pub c: rocblas_float_complex,
    pub z: rocblas_double_complex,
}
#[doc = " \\brief Union for representing scalar values"]
pub type rocblas_union_t = rocblas_union_u;
pub const rocblas_check_numerics_mode__rocblas_check_numerics_mode_no_check:
    rocblas_check_numerics_mode_ = 0;
pub const rocblas_check_numerics_mode__rocblas_check_numerics_mode_info:
    rocblas_check_numerics_mode_ = 1;
pub const rocblas_check_numerics_mode__rocblas_check_numerics_mode_warn:
    rocblas_check_numerics_mode_ = 2;
pub const rocblas_check_numerics_mode__rocblas_check_numerics_mode_fail:
    rocblas_check_numerics_mode_ = 4;
pub const rocblas_check_numerics_mode__rocblas_check_numerics_mode_only_nan_inf:
    rocblas_check_numerics_mode_ = 8;
#[doc = " \\brief Numerical checking for verifying the Input and Output vector/matrix of the rocBLAS functions for a NaN, zero, infinity and denormal value"]
pub type rocblas_check_numerics_mode_ = ::std::os::raw::c_uint;
#[doc = " \\brief Numerical checking for verifying the Input and Output vector/matrix of the rocBLAS functions for a NaN, zero, infinity and denormal value"]
pub use self::rocblas_check_numerics_mode_ as rocblas_check_numerics_mode;
pub const rocblas_math_mode__rocblas_default_math: rocblas_math_mode_ = 0;
pub const rocblas_math_mode__rocblas_xf32_xdl_math_op: rocblas_math_mode_ = 1;
pub type rocblas_math_mode_ = ::std::os::raw::c_uint;
pub use self::rocblas_math_mode_ as rocblas_math_mode;
unsafe extern "C" {
    #[doc = " \\brief Create handle"]
    pub fn rocblas_create_handle(handle: *mut rocblas_handle) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Destroy handle"]
    pub fn rocblas_destroy_handle(handle: rocblas_handle) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Set stream for handle"]
    pub fn rocblas_set_stream(handle: rocblas_handle, stream: hipStream_t) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get stream [0] from handle"]
    pub fn rocblas_get_stream(handle: rocblas_handle, stream: *mut hipStream_t) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Set rocblas_pointer_mode"]
    pub fn rocblas_set_pointer_mode(
        handle: rocblas_handle,
        pointer_mode: rocblas_pointer_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get rocblas_pointer_mode"]
    pub fn rocblas_get_pointer_mode(
        handle: rocblas_handle,
        pointer_mode: *mut rocblas_pointer_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Set rocblas_atomics_mode\n  \\details\n  Some rocBLAS functions may have implementations which use atomic operations to increase performance.\n  By using atomic operations, results are not guaranteed to be identical between multiple runs.\n  Results will be accurate with or without atomic operations, but if it is required to\n  have bit-wise reproducible results, atomic operations should not be used.\n\n  Atomic operations can be turned on or off for a handle by calling rocblas_set_atomics_mode.\n  By default, this is set to `rocblas_atomics_allowed`."]
    pub fn rocblas_set_atomics_mode(
        handle: rocblas_handle,
        atomics_mode: rocblas_atomics_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get rocblas_atomics_mode"]
    pub fn rocblas_get_atomics_mode(
        handle: rocblas_handle,
        atomics_mode: *mut rocblas_atomics_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Set rocblas_math_mode"]
    pub fn rocblas_set_math_mode(
        handle: rocblas_handle,
        math_mode: rocblas_math_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get rocblas_math_mode"]
    pub fn rocblas_get_math_mode(
        handle: rocblas_handle,
        math_mode: *mut rocblas_math_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief  Indicates whether the pointer is on the host or device."]
    pub fn rocblas_pointer_to_mode(ptr: *mut ::std::os::raw::c_void) -> rocblas_pointer_mode;
}
unsafe extern "C" {
    #[doc = " \\brief Copy vector from host to device\n@param[in]\nn           [rocblas_int]\nnumber of elements in the vector\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the host\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the device\n@param[in]\nincy        [rocblas_int]\nspecifies the increment for the elements of the vector"]
    pub fn rocblas_set_vector(
        n: rocblas_int,
        elem_size: rocblas_int,
        x: *const ::std::os::raw::c_void,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_set_vector_64(
        n: i64,
        elem_size: i64,
        x: *const ::std::os::raw::c_void,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Copy vector from device to host\n@param[in]\nn           [rocblas_int]\nnumber of elements in the vector\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the device\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the host\n@param[in]\nincy        [rocblas_int]\nspecifies the increment for the elements of the vector"]
    pub fn rocblas_get_vector(
        n: rocblas_int,
        elem_size: rocblas_int,
        x: *const ::std::os::raw::c_void,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_get_vector_64(
        n: i64,
        elem_size: i64,
        x: *const ::std::os::raw::c_void,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Copy matrix from host to device\n@param[in]\nrows        [rocblas_int]\nnumber of rows in matrices\n@param[in]\ncols        [rocblas_int]\nnumber of columns in matrices\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\na           pointer to matrix on the host\n@param[in]\nlda         [rocblas_int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nb           pointer to matrix on the GPU\n@param[in]\nldb         [rocblas_int]\nspecifies the leading dimension of B, ldb >= rows"]
    pub fn rocblas_set_matrix(
        rows: rocblas_int,
        cols: rocblas_int,
        elem_size: rocblas_int,
        a: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_set_matrix_64(
        rows: i64,
        cols: i64,
        elem_size: i64,
        a: *const ::std::os::raw::c_void,
        lda: i64,
        b: *mut ::std::os::raw::c_void,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Copy matrix from device to host\n@param[in]\nrows        [rocblas_int]\nnumber of rows in matrices\n@param[in]\ncols        [rocblas_int]\nnumber of columns in matrices\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\na           pointer to matrix on the GPU\n@param[in]\nlda         [rocblas_int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nb           pointer to matrix on the host\n@param[in]\nldb         [rocblas_int]\nspecifies the leading dimension of B, ldb >= rows"]
    pub fn rocblas_get_matrix(
        rows: rocblas_int,
        cols: rocblas_int,
        elem_size: rocblas_int,
        a: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_get_matrix_64(
        rows: i64,
        cols: i64,
        elem_size: i64,
        a: *const ::std::os::raw::c_void,
        lda: i64,
        b: *mut ::std::os::raw::c_void,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Asynchronously copy vector from host to device\n\\details\nrocblas_set_vector_async copies a vector from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nn           [rocblas_int]\nnumber of elements in the vector\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the host\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the device\n@param[in]\nincy        [rocblas_int]\nspecifies the increment for the elements of the vector\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn rocblas_set_vector_async(
        n: rocblas_int,
        elem_size: rocblas_int,
        x: *const ::std::os::raw::c_void,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocblas_int,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_set_vector_async_64(
        n: i64,
        elem_size: i64,
        x: *const ::std::os::raw::c_void,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        incy: i64,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Asynchronously copy vector from device to host\n\\details\nrocblas_get_vector_async copies a vector from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nn           [rocblas_int]\nnumber of elements in the vector\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the device\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the host\n@param[in]\nincy        [rocblas_int]\nspecifies the increment for the elements of the vector\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn rocblas_get_vector_async(
        n: rocblas_int,
        elem_size: rocblas_int,
        x: *const ::std::os::raw::c_void,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocblas_int,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_get_vector_async_64(
        n: i64,
        elem_size: i64,
        x: *const ::std::os::raw::c_void,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        incy: i64,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief Asynchronously copy matrix from host to device\n\\details\nrocblas_set_matrix_async copies a matrix from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nrows        [rocblas_int]\nnumber of rows in matrices\n@param[in]\ncols        [rocblas_int]\nnumber of columns in matrices\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\na           pointer to matrix on the host\n@param[in]\nlda         [rocblas_int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nb           pointer to matrix on the GPU\n@param[in]\nldb         [rocblas_int]\nspecifies the leading dimension of B, ldb >= rows\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn rocblas_set_matrix_async(
        rows: rocblas_int,
        cols: rocblas_int,
        elem_size: rocblas_int,
        a: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_set_matrix_async_64(
        rows: i64,
        cols: i64,
        elem_size: i64,
        a: *const ::std::os::raw::c_void,
        lda: i64,
        b: *mut ::std::os::raw::c_void,
        ldb: i64,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief asynchronously copy matrix from device to host\n\\details\nrocblas_get_matrix_async copies a matrix from device memory to pinned host memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nrows        [rocblas_int]\nnumber of rows in matrices\n@param[in]\ncols        [rocblas_int]\nnumber of columns in matrices\n@param[in]\nelem_size   [rocblas_int]\nnumber of bytes per element in the matrix\n@param[in]\na           pointer to matrix on the GPU\n@param[in]\nlda         [rocblas_int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nb           pointer to matrix on the host\n@param[in]\nldb         [rocblas_int]\nspecifies the leading dimension of B, ldb >= rows\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn rocblas_get_matrix_async(
        rows: rocblas_int,
        cols: rocblas_int,
        elem_size: rocblas_int,
        a: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_get_matrix_async_64(
        rows: i64,
        cols: i64,
        elem_size: i64,
        a: *const ::std::os::raw::c_void,
        lda: i64,
        b: *mut ::std::os::raw::c_void,
        ldb: i64,
        stream: hipStream_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " Function to set start/stop event handlers (for internal use only)"]
    pub fn rocblas_set_start_stop_events(
        handle: rocblas_handle,
        startEvent: hipEvent_t,
        stopEvent: hipEvent_t,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_set_solution_fitness_query(
        handle: rocblas_handle,
        fitness: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief specifies the performance metric that solution selection uses\n\\details\nDetermines which performance metric will be used by Tensile when selecting the optimal solution\nfor gemm problems. If a valid solution benchmarked for this performance metric does not exist\nfor a problem, Tensile will default to a solution benchmarked for overall performance instead.\n@param[in]\nhandle      [rocblas_handle]\nthe handle of device\n@param[in]\nmetric      [rocblas_performance_metric]\nthe performance metric to be used"]
    pub fn rocblas_set_performance_metric(
        handle: rocblas_handle,
        metric: rocblas_performance_metric,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief returns the performance metric being used for solution selection\n\\details\nReturns the performance metric used by Tensile to select the optimal solution for gemm problems.\n@param[in]\nhandle      [rocblas_handle]\nthe handle of device\n@param[out]\nmetric      [rocblas_performance_metric*]\npointer to where the metric will be stored"]
    pub fn rocblas_get_performance_metric(
        handle: rocblas_handle,
        metric: *mut rocblas_performance_metric,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nscal  scales each element of vector x with scalar alpha:\n\nx := alpha * x\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in, out]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n"]
    pub fn rocblas_sscal(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dscal(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cscal(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zscal(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csscal(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdscal(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sscal_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dscal_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cscal_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zscal_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csscal_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdscal_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nscal_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count:\n\nx_i := alpha * x_i,\nwhere (x_i) is the i-th instance of the batch.\n\n@param[in]\nhandle      [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn           [rocblas_int]\nthe number of elements in each x_i.\n@param[in]\nalpha       host pointer or device pointer for the scalar alpha.\n@param[in, out]\nx           device array of device pointers storing each vector x_i.\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatch_count [rocblas_int]\nspecifies the number of batches in x.\n"]
    pub fn rocblas_sscal_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dscal_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cscal_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zscal_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csscal_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdscal_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sscal_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dscal_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cscal_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zscal_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csscal_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdscal_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nscal_strided_batched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batch_count:\n\nx_i := alpha * x_i,\nwhere (x_i) is the i-th instance of the batch.\n\n@param[in]\nhandle      [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn           [rocblas_int]\nthe number of elements in each x_i.\n@param[in]\nalpha       host pointer or device pointer for the scalar alpha.\n@param[in, out]\nx           device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nstride_x    [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatch_count [rocblas_int]\nspecifies the number of batches in x.\n"]
    pub fn rocblas_sscal_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dscal_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cscal_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zscal_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csscal_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdscal_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sscal_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dscal_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cscal_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zscal_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csscal_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdscal_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\ncopy  copies each element x[i] into y[i], for  i = 1 , ... , n:\n\ny := x\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x to be copied to y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_scopy(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dcopy(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ccopy(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zcopy(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scopy_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dcopy_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ccopy_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zcopy_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\ncopy_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count:\n\ny_i := x_i,\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i to be copied to y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_scopy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dcopy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ccopy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zcopy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scopy_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dcopy_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ccopy_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zcopy_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\ncopy_strided_batched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batch_count:\n\ny_i := x_i,\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i to be copied to y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [rocblas_int]\nspecifies the increments for the elements of vectors x_i.\n@param[in]\nstridex     [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, the user should\ntake care to ensure that stride_x is of appropriate size. For a typical\ncase, this means stride_x >= n * incx.\n@param[out]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of vectors y_i.\n@param[in]\nstridey     [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_y, However, ensure that stride_y is of appropriate size, for a typical\ncase this means stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_scopy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dcopy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ccopy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zcopy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scopy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dcopy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ccopy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zcopy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\ndot(u)  performs the dot product of vectors x and y:\n\nresult = x * y;\n\ndotc  performs the dot product of the conjugate of complex vector x and complex vector y.\n\nresult = conjugate (x) * y;\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nresult\ndevice pointer or host pointer to store the dot product.\nreturn is 0.0 if n <= 0.\n"]
    pub fn rocblas_sdot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        y: *const f32,
        incy: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        y: *const f64,
        incy: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hdot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_half,
        incx: rocblas_int,
        y: *const rocblas_half,
        incy: rocblas_int,
        result: *mut rocblas_half,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_bfdot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_bfloat16,
        incx: rocblas_int,
        y: *const rocblas_bfloat16,
        incy: rocblas_int,
        result: *mut rocblas_bfloat16,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotu(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotu(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotc(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotc(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sdot_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddot_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hdot_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_half,
        incx: i64,
        y: *const rocblas_half,
        incy: i64,
        result: *mut rocblas_half,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_bfdot_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_bfloat16,
        incx: i64,
        y: *const rocblas_bfloat16,
        incy: i64,
        result: *mut rocblas_bfloat16,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotu_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotu_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotc_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotc_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\ndot_batched(u) performs a batch of dot products of vectors x and y:\n\nresult_i = x_i * y_i;\n\ndotc_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in, out]\nresult\ndevice array or host array of batch_count size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n"]
    pub fn rocblas_sdot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        y: *const *const f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        y: *const *const f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hdot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_half,
        incx: rocblas_int,
        y: *const *const rocblas_half,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_half,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_bfdot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_bfloat16,
        incx: rocblas_int,
        y: *const *const rocblas_bfloat16,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_bfloat16,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotu_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotu_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotc_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotc_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sdot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        batch_count: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        batch_count: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hdot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_half,
        incx: i64,
        y: *const *const rocblas_half,
        incy: i64,
        batch_count: i64,
        result: *mut rocblas_half,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_bfdot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_bfloat16,
        incx: i64,
        y: *const *const rocblas_bfloat16,
        incy: i64,
        batch_count: i64,
        result: *mut rocblas_bfloat16,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotu_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        batch_count: i64,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotu_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        batch_count: i64,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotc_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        batch_count: i64,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotc_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        batch_count: i64,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\ndot_strided_batched(u)  performs a batch of dot products of vectors x and y:\n\nresult_i = x_i * y_i;\n\ndotc_strided_batched  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex     [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey     [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in, out]\nresult\ndevice array or host array of batch_count size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n"]
    pub fn rocblas_sdot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hdot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_half,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_half,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_half,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_bfdot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_bfloat16,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_bfloat16,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_bfloat16,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotu_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotu_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotc_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotc_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sdot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        y: *const f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        y: *const f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hdot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_half,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_half,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut rocblas_half,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_bfdot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_bfloat16,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_bfloat16,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut rocblas_bfloat16,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotu_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotu_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdotc_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdotc_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        result: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nswap  interchanges vectors x and y:\n\ny := x;\nx := y\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x and y.\n@param[in, out]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_sswap(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dswap(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cswap(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zswap(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sswap_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dswap_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cswap_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zswap_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nswap_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count:\n\ny_i := x_i;\nx_i := y_i\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in, out]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sswap_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dswap_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cswap_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zswap_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sswap_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dswap_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cswap_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zswap_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nswap_strided_batched interchanges vectors x_i and y_i, for i = 1 , ... , batch_count:\n\ny_i := x_i;\nx_i := y_i\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in, out]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex   [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical\ncase this means stride_x >= n * incx.\n@param[in, out]\ny         device pointer to the first vector y_1.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey   [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_y is of appropriate size. For a typical\ncase this means stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sswap_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dswap_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cswap_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zswap_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sswap_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f32,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dswap_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f64,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cswap_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zswap_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\naxpy   computes constant alpha multiplied by vector x, plus vector y:\n\ny := alpha * x + y\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x and y.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[out]\ny         device pointer storing vector y.\n@param[in, out]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_haxpy(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_half,
        x: *const rocblas_half,
        incx: rocblas_int,
        y: *mut rocblas_half,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_saxpy(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_daxpy(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_caxpy(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zaxpy(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_haxpy_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_half,
        x: *const rocblas_half,
        incx: i64,
        y: *mut rocblas_half,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_saxpy_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_daxpy_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_caxpy_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zaxpy_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\naxpy_batched compute y := alpha * x + y over a set of batched vectors.\n\n@param[in]\nhandle    rocblas_handle\nhandle to the rocblas library context queue.\n@param[in]\nn         rocblas_int\n@param[in]\nalpha     specifies the scalar alpha.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      rocblas_int\nspecifies the increment for the elements of x.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[in, out]\nincy      rocblas_int\nspecifies the increment for the elements of y.\n\n@param[in]\nbatch_count rocblas_int\nnumber of instances in the batch.\n"]
    pub fn rocblas_haxpy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_half,
        x: *const *const rocblas_half,
        incx: rocblas_int,
        y: *const *mut rocblas_half,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_saxpy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_daxpy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_caxpy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zaxpy_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_haxpy_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_half,
        x: *const *const rocblas_half,
        incx: i64,
        y: *const *mut rocblas_half,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_saxpy_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_daxpy_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_caxpy_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zaxpy_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\naxpy_strided_batched compute y := alpha * x + y over a set of strided batched vectors.\n\n@param[in]\nhandle    rocblas_handle\nhandle to the rocblas library context queue.\n@param[in]\nn         rocblas_int.\n@param[in]\nalpha     specifies the scalar alpha.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      rocblas_int\nspecifies the increment for the elements of x.\n@param[in]\nstridex   rocblas_stride\nspecifies the increment between vectors of x.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[in, out]\nincy      rocblas_int\nspecifies the increment for the elements of y.\n@param[in]\nstridey   rocblas_stride\nspecifies the increment between vectors of y.\n\n@param[in]\nbatch_count rocblas_int\nnumber of instances in the batch.\n"]
    pub fn rocblas_haxpy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_half,
        x: *const rocblas_half,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_half,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_saxpy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_daxpy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_caxpy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zaxpy_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_haxpy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_half,
        x: *const rocblas_half,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_half,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_saxpy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_daxpy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_caxpy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zaxpy_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nasum computes the sum of the magnitudes of elements of a real vector x,\nor the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x. incx must be > 0.\n@param[in, out]\nresult\ndevice pointer or host pointer to store the asum product.\nreturn is 0.0 if n <= 0.\n"]
    pub fn rocblas_sasum(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dasum(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scasum(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dzasum(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sasum_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dasum_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scasum_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dzasum_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nasum_batched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,\nor the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex\nvector, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each vector x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresults\ndevice array or host array of batch_count size for results.\nreturn is 0.0 if n, incx<=0.\n"]
    pub fn rocblas_sasum_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dasum_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scasum_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dzasum_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sasum_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dasum_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scasum_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dzasum_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nasum_strided_batched computes the sum of the magnitudes of elements of a real vectors x_i,\nor the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex\nvector, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each vector x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical\ncase this means stride_x >= n * incx.\n@param[out]\nresults\ndevice pointer or host pointer to array for storing contiguous batch_count results.\nreturn is 0.0 if n, incx<=0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sasum_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dasum_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scasum_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dzasum_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sasum_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dasum_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scasum_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dzasum_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nnrm2 computes the euclidean norm of a real or complex vector:\n\nresult := sqrt( x'*x ) for real vectors\nresult := sqrt( x**H*x ) for complex vectors\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nresult\ndevice pointer or host pointer to store the nrm2 product.\nreturn is 0.0 if n, incx<=0.\n"]
    pub fn rocblas_snrm2(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dnrm2(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scnrm2(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dznrm2(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_snrm2_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dnrm2_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scnrm2_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        result: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dznrm2_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        result: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nnrm2_batched computes the euclidean norm over a batch of real or complex vectors:\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count\nresult := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batch_count\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresults\ndevice pointer or host pointer to array of batch_count size for nrm2 results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n"]
    pub fn rocblas_snrm2_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dnrm2_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scnrm2_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dznrm2_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_snrm2_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dnrm2_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scnrm2_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dznrm2_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nnrm2_strided_batched computes the euclidean norm over a batch of real or complex vectors:\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count\nresult := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batch_count\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresults\ndevice pointer or host pointer to array for storing contiguous batch_count results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n"]
    pub fn rocblas_snrm2_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dnrm2_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scnrm2_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dznrm2_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_snrm2_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dnrm2_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scnrm2_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dznrm2_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        results: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\namax finds the first index of the element of maximum magnitude of a vector x.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nresult\ndevice pointer or host pointer to store the amax index.\nreturn is 0.0 if n, incx<=0.\n"]
    pub fn rocblas_isamax(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamax(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamax(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamax(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_isamax_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamax_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamax_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamax_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\namax_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each vector x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch. Must be > 0.\n@param[out]\nresult\ndevice or host array of pointers of batch_count size for results.\nreturn is 0 if n, incx<=0.\n"]
    pub fn rocblas_isamax_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamax_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamax_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamax_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_isamax_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamax_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamax_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamax_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\namax_strided_batched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each vector x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [rocblas_stride]\nspecifies the pointer increment between one x_i and the next x_(i + 1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresult\ndevice or host pointer for storing contiguous batch_count results.\nreturn is 0 if n <= 0, incx<=0.\n"]
    pub fn rocblas_isamax_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamax_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamax_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamax_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_isamax_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamax_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamax_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamax_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\namin finds the first index of the element of minimum magnitude of a vector x.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nresult\ndevice pointer or host pointer to store the amin index.\nreturn is 0.0 if n, incx<=0.\n"]
    pub fn rocblas_isamin(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamin(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamin(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamin(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_isamin_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamin_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamin_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamin_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\namin_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each vector x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch. Must be > 0.\n@param[out]\nresult\ndevice or host pointers to array of batch_count size for results.\nreturn is 0 if n, incx<=0.\n"]
    pub fn rocblas_isamin_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamin_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamin_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamin_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_isamin_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamin_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamin_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamin_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\namin_strided_batched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each vector x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [rocblas_stride]\nspecifies the pointer increment between one x_i and the next x_(i + 1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresult\ndevice or host pointer to array for storing contiguous batch_count results.\nreturn is 0 if n <= 0, incx<=0.\n"]
    pub fn rocblas_isamin_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamin_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamin_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamin_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_isamin_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_idamin_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_icamin_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_izamin_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        result: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.\nScalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in the x and y vectors.\n@param[in, out]\nx       device pointer storing vector x.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of x.\n@param[in, out]\ny       device pointer storing vector y.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of y.\n@param[in]\nc       device pointer or host pointer storing scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer storing scalar sine component of the rotation matrix.\n"]
    pub fn rocblas_srot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        y: *mut f32,
        incy: rocblas_int,
        c: *const f32,
        s: *const f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        y: *mut f64,
        incy: rocblas_int,
        c: *const f64,
        s: *const f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        c: *const f32,
        s: *const rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csrot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        c: *const f32,
        s: *const f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        c: *const f64,
        s: *const rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdrot(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        c: *const f64,
        s: *const f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srot_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
        c: *const f32,
        s: *const f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drot_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
        c: *const f64,
        s: *const f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crot_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        y: *mut rocblas_float_complex,
        incy: i64,
        c: *const f32,
        s: *const rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csrot_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        y: *mut rocblas_float_complex,
        incy: i64,
        c: *const f32,
        s: *const f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrot_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        y: *mut rocblas_double_complex,
        incy: i64,
        c: *const f64,
        s: *const rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdrot_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        y: *mut rocblas_double_complex,
        incy: i64,
        c: *const f64,
        s: *const f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrot_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.\nScalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in each x_i and y_i vectors.\n@param[in, out]\nx       device array of deivce pointers storing each vector x_i.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of each x_i.\n@param[in, out]\ny       device array of device pointers storing each vector y_i.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of each y_i.\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\nbatch_count [rocblas_int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn rocblas_srot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        y: *const *mut f32,
        incy: rocblas_int,
        c: *const f32,
        s: *const f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        y: *const *mut f64,
        incy: rocblas_int,
        c: *const f64,
        s: *const f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        c: *const f32,
        s: *const rocblas_float_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csrot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        c: *const f32,
        s: *const f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        c: *const f64,
        s: *const rocblas_double_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdrot_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        c: *const f64,
        s: *const f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        c: *const f32,
        s: *const f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        c: *const f64,
        s: *const f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        c: *const f32,
        s: *const rocblas_float_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csrot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        c: *const f32,
        s: *const f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        c: *const f64,
        s: *const rocblas_double_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdrot_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        c: *const f64,
        s: *const f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrot_strided_batched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.\nScalars c and s may be stored in either host or device memory, location is specified by calling rocblas_set_pointer_mode.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in each x_i and y_i vectors.\n@param[in, out]\nx       device pointer to the first vector x_1.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstride_x [rocblas_stride]\nspecifies the increment from the beginning of x_i to the beginning of x_(i+1).\n@param[in, out]\ny       device pointer to the first vector y_1.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstride_y [rocblas_stride]\nspecifies the increment from the beginning of y_i to the beginning of y_(i+1)\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\nbatch_count [rocblas_int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn rocblas_srot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut f32,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const f32,
        s: *const f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut f64,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const f64,
        s: *const f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const f32,
        s: *const rocblas_float_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csrot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const f32,
        s: *const f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const f64,
        s: *const rocblas_double_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdrot_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const f64,
        s: *const f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut f32,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const f32,
        s: *const f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut f64,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const f64,
        s: *const f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const f32,
        s: *const rocblas_float_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csrot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const f32,
        s: *const f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const f64,
        s: *const rocblas_double_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdrot_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const f64,
        s: *const f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotg creates the Givens rotation matrix for the vector (a b).\nScalars a, b, c, and s may be stored in either host or device memory, location is specified by\ncalling rocblas_set_pointer_mode. The computation uses the formulas\n\nsigma = sgn(a)    if |a| >  |b|\n= sgn(b)    if |b| >= |a|\nr = sigma*sqrt( a**2 + b**2 )\nc = 1; s = 0      if r = 0\nc = a/r; s = b/r  if r != 0\n\nThe subroutine also computes\n\nz = s    if |a| > |b|,\n= 1/c  if |b| >= |a| and c != 0\n= 1    if c = 0\n\nThis allows c and s to be reconstructed from z as follows:\n\nIf z = 1, set c = 0, s = 1.\nIf |z| < 1, set c = sqrt(1 - z**2) and s = z.\nIf |z| > 1, set c = 1/z and s = sqrt( 1 - c**2).\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in, out]\na       pointer to a, an element in vector (a,b), overwritten with r.\n@param[in, out]\nb       pointer to b, an element in vector (a,b), overwritten with z.\n@param[out]\nc       pointer to c, cosine element of Givens rotation.\n@param[out]\ns       pointer to s, sine element of Givens rotation.\n"]
    pub fn rocblas_srotg(
        handle: rocblas_handle,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotg(
        handle: rocblas_handle,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crotg(
        handle: rocblas_handle,
        a: *mut rocblas_float_complex,
        b: *mut rocblas_float_complex,
        c: *mut f32,
        s: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrotg(
        handle: rocblas_handle,
        a: *mut rocblas_double_complex,
        b: *mut rocblas_double_complex,
        c: *mut f64,
        s: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotg_64(
        handle: rocblas_handle,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotg_64(
        handle: rocblas_handle,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crotg_64(
        handle: rocblas_handle,
        a: *mut rocblas_float_complex,
        b: *mut rocblas_float_complex,
        c: *mut f32,
        s: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrotg_64(
        handle: rocblas_handle,
        a: *mut rocblas_double_complex,
        b: *mut rocblas_double_complex,
        c: *mut f64,
        s: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotg_batched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batch_count.\na, b, c, and s are host pointers to an array of device pointers on the device, where each device pointer points\nto a scalar value of a_i, b_i, c_i, or s_i.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in, out]\na       a, overwritten with r.\n@param[in, out]\nb       b overwritten with z.\n@param[out]\nc       cosine element of Givens rotation for the batch.\n@param[out]\ns       sine element of Givens rotation for the batch.\n@param[in]\nbatch_count [rocblas_int]\nnumber of batches (length of arrays a, b, c, and s).\n"]
    pub fn rocblas_srotg_batched(
        handle: rocblas_handle,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotg_batched(
        handle: rocblas_handle,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crotg_batched(
        handle: rocblas_handle,
        a: *const *mut rocblas_float_complex,
        b: *const *mut rocblas_float_complex,
        c: *const *mut f32,
        s: *const *mut rocblas_float_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrotg_batched(
        handle: rocblas_handle,
        a: *const *mut rocblas_double_complex,
        b: *const *mut rocblas_double_complex,
        c: *const *mut f64,
        s: *const *mut rocblas_double_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotg_batched_64(
        handle: rocblas_handle,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotg_batched_64(
        handle: rocblas_handle,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crotg_batched_64(
        handle: rocblas_handle,
        a: *const *mut rocblas_float_complex,
        b: *const *mut rocblas_float_complex,
        c: *const *mut f32,
        s: *const *mut rocblas_float_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrotg_batched_64(
        handle: rocblas_handle,
        a: *const *mut rocblas_double_complex,
        b: *const *mut rocblas_double_complex,
        c: *const *mut f64,
        s: *const *mut rocblas_double_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotg_strided_batched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batch_count.\na, b, c, and s are host pointers to arrays a, b, c, s on the device.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in, out]\na       host pointer to first single input vector element a_1 on the device, overwritten with r.\n@param[in]\nstride_a [rocblas_stride]\ndistance between elements of a in batch (distance between a_i and a_(i + 1)).\n@param[in, out]\nb       host pointer to first single input vector element b_1 on the device, overwritten with z.\n@param[in]\nstride_b [rocblas_stride]\ndistance between elements of b in batch (distance between b_i and b_(i + 1)).\n@param[out]\nc       host pointer to first single cosine element of Givens rotations c_1 on the device.\n@param[in]\nstride_c [rocblas_stride]\ndistance between elements of c in batch (distance between c_i and c_(i + 1)).\n@param[out]\ns       host pointer to first single sine element of Givens rotations s_1 on the device.\n@param[in]\nstride_s [rocblas_stride]\ndistance between elements of s in batch (distance between s_i and s_(i + 1)).\n@param[in]\nbatch_count [rocblas_int]\nnumber of batches (length of arrays a, b, c, and s).\n"]
    pub fn rocblas_srotg_strided_batched(
        handle: rocblas_handle,
        a: *mut f32,
        stride_a: rocblas_stride,
        b: *mut f32,
        stride_b: rocblas_stride,
        c: *mut f32,
        stride_c: rocblas_stride,
        s: *mut f32,
        stride_s: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotg_strided_batched(
        handle: rocblas_handle,
        a: *mut f64,
        stride_a: rocblas_stride,
        b: *mut f64,
        stride_b: rocblas_stride,
        c: *mut f64,
        stride_c: rocblas_stride,
        s: *mut f64,
        stride_s: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crotg_strided_batched(
        handle: rocblas_handle,
        a: *mut rocblas_float_complex,
        stride_a: rocblas_stride,
        b: *mut rocblas_float_complex,
        stride_b: rocblas_stride,
        c: *mut f32,
        stride_c: rocblas_stride,
        s: *mut rocblas_float_complex,
        stride_s: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrotg_strided_batched(
        handle: rocblas_handle,
        a: *mut rocblas_double_complex,
        stride_a: rocblas_stride,
        b: *mut rocblas_double_complex,
        stride_b: rocblas_stride,
        c: *mut f64,
        stride_c: rocblas_stride,
        s: *mut rocblas_double_complex,
        stride_s: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotg_strided_batched_64(
        handle: rocblas_handle,
        a: *mut f32,
        stride_a: rocblas_stride,
        b: *mut f32,
        stride_b: rocblas_stride,
        c: *mut f32,
        stride_c: rocblas_stride,
        s: *mut f32,
        stride_s: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotg_strided_batched_64(
        handle: rocblas_handle,
        a: *mut f64,
        stride_a: rocblas_stride,
        b: *mut f64,
        stride_b: rocblas_stride,
        c: *mut f64,
        stride_c: rocblas_stride,
        s: *mut f64,
        stride_s: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_crotg_strided_batched_64(
        handle: rocblas_handle,
        a: *mut rocblas_float_complex,
        stride_a: rocblas_stride,
        b: *mut rocblas_float_complex,
        stride_b: rocblas_stride,
        c: *mut f32,
        stride_c: rocblas_stride,
        s: *mut rocblas_float_complex,
        stride_s: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zrotg_strided_batched_64(
        handle: rocblas_handle,
        a: *mut rocblas_double_complex,
        stride_a: rocblas_stride,
        b: *mut rocblas_double_complex,
        stride_b: rocblas_stride,
        c: *mut f64,
        stride_c: rocblas_stride,
        s: *mut rocblas_double_complex,
        stride_s: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotm applies the modified Givens rotation matrix defined by param to vectors x and y.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in the x and y vectors.\n@param[in, out]\nx       device pointer storing vector x.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of x.\n@param[in, out]\ny       device pointer storing vector y.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of y.\n@param[in]\nparam   device vector or host vector of 5 elements defining the rotation.\n\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\n\nThe flag parameter defines the form of H:\n\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\n\nparam may be stored in either host or device memory,\nlocation is specified by calling rocblas_set_pointer_mode.\n"]
    pub fn rocblas_srotm(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        y: *mut f32,
        incy: rocblas_int,
        param: *const f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotm(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        y: *mut f64,
        incy: rocblas_int,
        param: *const f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotm_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
        param: *const f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotm_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
        param: *const f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotm_batched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batch_count.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in the x and y vectors.\n@param[in, out]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of each x_i.\n@param[in, out]\ny       device array of device pointers storing each vector y_1.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of each y_i.\n@param[in]\nparam   device array of device vectors of 5 elements defining the rotation.\n\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\n\nThe flag parameter defines the form of H:\n\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\n\nparam may ONLY be stored on the device for the batched version of this function.\n\n@param[in]\nbatch_count [rocblas_int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn rocblas_srotm_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        y: *const *mut f32,
        incy: rocblas_int,
        param: *const *const f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotm_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        y: *const *mut f64,
        incy: rocblas_int,
        param: *const *const f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotm_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        param: *const *const f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotm_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *const *mut f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        param: *const *const f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotm_strided_batched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batch_count\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in the x and y vectors.\n@param[in, out]\nx       device pointer pointing to first strided batched vector x_1.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstride_x [rocblas_stride]\nspecifies the increment between the beginning of x_i and x_(i + 1)\n@param[in, out]\ny       device pointer pointing to first strided batched vector y_1.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstride_y [rocblas_stride]\nspecifies the increment between the beginning of y_i and y_(i + 1).\n@param[in]\nparam   device pointer pointing to first array of 5 elements defining the rotation (param_1).\n\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\n\nThe flag parameter defines the form of H:\n\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\n\nparam may ONLY be stored on the device for the strided_batched\nversion of this function.\n\n@param[in]\nstride_param [rocblas_stride]\nspecifies the increment between the beginning of param_i and param_(i + 1).\n@param[in]\nbatch_count [rocblas_int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn rocblas_srotm_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut f32,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        param: *const f32,
        stride_param: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotm_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut f64,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        param: *const f64,
        stride_param: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotm_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut f32,
        incy: i64,
        stride_y: rocblas_stride,
        param: *const f32,
        stride_param: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotm_strided_batched_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut f64,
        incy: i64,
        stride_y: rocblas_stride,
        param: *const f64,
        stride_param: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).\nParameters may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode:\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in, out]\nd1      device pointer or host pointer to input scalar that is overwritten.\n@param[in, out]\nd2      device pointer or host pointer to input scalar that is overwritten.\n@param[in, out]\nx1      device pointer or host pointer to input scalar that is overwritten.\n@param[in]\ny1      device pointer or host pointer to input scalar.\n@param[out]\nparam   device vector or host vector of five elements defining the rotation.\n\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\n\nThe flag parameter defines the form of H:\n\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\n\nparam may be stored in either host or device memory.\nLocation is specified by calling rocblas_set_pointer_mode.\n"]
    pub fn rocblas_srotmg(
        handle: rocblas_handle,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotmg(
        handle: rocblas_handle,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotmg_64(
        handle: rocblas_handle,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotmg_64(
        handle: rocblas_handle,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotmg_batched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batch_count.\nParameters may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode:\n\n- If the pointer mode is set to rocblas_pointer_mode_host, then this function blocks the CPU until the GPU has finished and the results are available in host memory.\n- If the pointer mode is set to rocblas_pointer_mode_device, then this function returns immediately and synchronization is required to read the results.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in, out]\nd1      device batched array or host batched array of input scalars that is overwritten.\n@param[in, out]\nd2      device batched array or host batched array of input scalars that is overwritten.\n@param[in, out]\nx1      device batched array or host batched array of input scalars that is overwritten.\n@param[in]\ny1      device batched array or host batched array of input scalars.\n@param[out]\nparam   device batched array or host batched array of vectors of 5 elements defining the rotation.\n\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\n\nThe flag parameter defines the form of H:\n\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\n\nparam may be stored in either host or device memory.\nLocation is specified by calling rocblas_set_pointer_mode.\n\n@param[in]\nbatch_count [rocblas_int]\nthe number of instances in the batch.\n"]
    pub fn rocblas_srotmg_batched(
        handle: rocblas_handle,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotmg_batched(
        handle: rocblas_handle,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotmg_batched_64(
        handle: rocblas_handle,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotmg_batched_64(
        handle: rocblas_handle,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrotmg_strided_batched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batch_count.\nParameters may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode:\n\n- If the pointer mode is set to rocblas_pointer_mode_host, then this function blocks the CPU until the GPU has finished and the results are available in host memory.\n- If the pointer mode is set to rocblas_pointer_mode_device, then this function returns immediately and synchronization is required to read the results.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in, out]\nd1      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstride_d1 [rocblas_stride]\nspecifies the increment between the beginning of d1_i and d1_(i+1).\n@param[in, out]\nd2      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstride_d2 [rocblas_stride]\nspecifies the increment between the beginning of d2_i and d2_(i+1).\n@param[in, out]\nx1      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstride_x1 [rocblas_stride]\nspecifies the increment between the beginning of x1_i and x1_(i+1).\n@param[in]\ny1      device strided_batched array or host strided_batched array of input scalars.\n@param[in]\nstride_y1 [rocblas_stride]\nspecifies the increment between the beginning of y1_i and y1_(i+1).\n@param[out]\nparam   device strided_batched array or host strided_batched array of vectors of 5 elements defining the rotation.\n\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\n\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\n\nparam may be stored in either host or device memory.\nLocation is specified by calling rocblas_set_pointer_mode.\n\n@param[in]\nstride_param [rocblas_stride]\nspecifies the increment between the beginning of param_i and param_(i + 1).\n@param[in]\nbatch_count [rocblas_int]\nthe number of instances in the batch.\n"]
    pub fn rocblas_srotmg_strided_batched(
        handle: rocblas_handle,
        d1: *mut f32,
        stride_d1: rocblas_stride,
        d2: *mut f32,
        stride_d2: rocblas_stride,
        x1: *mut f32,
        stride_x1: rocblas_stride,
        y1: *const f32,
        stride_y1: rocblas_stride,
        param: *mut f32,
        stride_param: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotmg_strided_batched(
        handle: rocblas_handle,
        d1: *mut f64,
        stride_d1: rocblas_stride,
        d2: *mut f64,
        stride_d2: rocblas_stride,
        x1: *mut f64,
        stride_x1: rocblas_stride,
        y1: *const f64,
        stride_y1: rocblas_stride,
        param: *mut f64,
        stride_param: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_srotmg_strided_batched_64(
        handle: rocblas_handle,
        d1: *mut f32,
        stride_d1: rocblas_stride,
        d2: *mut f32,
        stride_d2: rocblas_stride,
        x1: *mut f32,
        stride_x1: rocblas_stride,
        y1: *const f32,
        stride_y1: rocblas_stride,
        param: *mut f32,
        stride_param: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_drotmg_strided_batched_64(
        handle: rocblas_handle,
        d1: *mut f64,
        stride_d1: rocblas_stride,
        d2: *mut f64,
        stride_d2: rocblas_stride,
        x1: *mut f64,
        stride_x1: rocblas_stride,
        y1: *const f64,
        stride_y1: rocblas_stride,
        param: *mut f64,
        stride_param: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ngbmv performs one of the matrix-vector operations:\n\ny := alpha*A*x    + beta*y,   or\ny := alpha*A**T*x + beta*y,   or\ny := alpha*A**H*x + beta*y,\nwhere alpha and beta are scalars, x and y are vectors and A is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\nm         [rocblas_int]\nnumber of rows of matrix A.\n@param[in]\nn         [rocblas_int]\nnumber of columns of matrix A.\n@param[in]\nkl        [rocblas_int]\nnumber of sub-diagonals of A.\n@param[in]\nku        [rocblas_int]\nnumber of super-diagonals of A.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA     device pointer storing banded matrix A.\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\n\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 3             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\n\nNote that the empty elements which do not correspond to data will not\nbe referenced.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. Must be >= (kl + ku + 1).\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_sgbmv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgbmv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgbmv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgbmv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgbmv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgbmv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgbmv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgbmv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ngbmv_batched performs one of the matrix-vector operations:\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals,\nfor i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\nm         [rocblas_int]\nnumber of rows of each matrix A_i.\n@param[in]\nn         [rocblas_int]\nnumber of columns of each matrix A_i.\n@param[in]\nkl        [rocblas_int]\nnumber of sub-diagonals of each A_i.\n@param[in]\nku        [rocblas_int]\nnumber of super-diagonals of each A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA     device array of device pointers storing each banded matrix A_i.\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\n\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 3             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\n\nNote that the empty elements which do not correspond to data will not\nbe referenced.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. Must be >= (kl + ku + 1)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatch_count [rocblas_int]\nspecifies the number of instances in the batch.\n"]
    pub fn rocblas_sgbmv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgbmv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgbmv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgbmv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgbmv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgbmv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgbmv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgbmv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ngbmv_strided_batched performs one of the matrix-vector operations:\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals,\nfor i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\nm         [rocblas_int]\nnumber of rows of matrix A.\n@param[in]\nn         [rocblas_int]\nnumber of columns of matrix A.\n@param[in]\nkl        [rocblas_int]\nnumber of sub-diagonals of A.\n@param[in]\nku        [rocblas_int]\nnumber of super-diagonals of A.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA     device pointer to first banded matrix (A_1).\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\n\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 3             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\n\nNote that the empty elements which do not correspond to data will not\nbe referenced.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. Must be >= (kl + ku + 1).\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx         device pointer to first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device pointer to first vector (y_1).\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nstride_y  [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (x_i+1).\n@param[in]\nbatch_count [rocblas_int]\nspecifies the number of instances in the batch.\n"]
    pub fn rocblas_sgbmv_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgbmv_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgbmv_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgbmv_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        kl: rocblas_int,
        ku: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgbmv_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const f32,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgbmv_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const f64,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgbmv_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgbmv_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ngemv performs one of the matrix-vector operations:\n\ny := alpha*A*x    + beta*y,   or\ny := alpha*A**T*x + beta*y,   or\ny := alpha*A**H*x + beta*y,\nwhere alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\nm         [rocblas_int]\nnumber of rows of matrix A.\n@param[in]\nn         [rocblas_int]\nnumber of columns of matrix A.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_sgemv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemv(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemv_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ngemv_batched performs a batch of matrix-vector operations:\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle      [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntrans       [rocblas_operation]\nindicates whether matrices A_i are tranposed (conjugated) or not.\n@param[in]\nm           [rocblas_int]\nnumber of rows of each matrix A_i.\n@param[in]\nn           [rocblas_int]\nnumber of columns of each matrix A_i.\n@param[in]\nalpha       device pointer or host pointer to scalar alpha.\n@param[in]\nA           device array of device pointers storing each matrix A_i.\n@param[in]\nlda         [rocblas_int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nx           device array of device pointers storing each vector x_i.\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nbeta        device pointer or host pointer to scalar beta.\n@param[in, out]\ny           device array of device pointers storing each vector y_i.\n@param[in]\nincy        [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hshgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const rocblas_half,
        lda: rocblas_int,
        x: *const *const rocblas_half,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut rocblas_half,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hssgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const rocblas_half,
        lda: rocblas_int,
        x: *const *const rocblas_half,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tstgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const rocblas_bfloat16,
        lda: rocblas_int,
        x: *const *const rocblas_bfloat16,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut rocblas_bfloat16,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tssgemv_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const rocblas_bfloat16,
        lda: rocblas_int,
        x: *const *const rocblas_bfloat16,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hshgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const rocblas_half,
        lda: i64,
        x: *const *const rocblas_half,
        incx: i64,
        beta: *const f32,
        y: *const *mut rocblas_half,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hssgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const rocblas_half,
        lda: i64,
        x: *const *const rocblas_half,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tstgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const rocblas_bfloat16,
        lda: i64,
        x: *const *const rocblas_bfloat16,
        incx: i64,
        beta: *const f32,
        y: *const *mut rocblas_bfloat16,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tssgemv_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const rocblas_bfloat16,
        lda: i64,
        x: *const *const rocblas_bfloat16,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ngemv_strided_batched performs a batch of matrix-vector operations:\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle      [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA      [rocblas_operation]\nindicates whether matrices A_i are tranposed (conjugated) or not.\n@param[in]\nm           [rocblas_int]\nnumber of rows of matrices A_i.\n@param[in]\nn           [rocblas_int]\nnumber of columns of matrices A_i.\n@param[in]\nalpha       device pointer or host pointer to scalar alpha.\n@param[in]\nA           device pointer to the first matrix (A_1) in the batch.\n@param[in]\nlda         [rocblas_int]\nspecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA     [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx           device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx        [rocblas_int]\nspecifies the increment for the elements of vectors x_i.\n@param[in]\nstridex     [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. When trans equals rocblas_operation_none\nthis typically means stride_x >= n * incx, otherwise stride_x >= m * incx.\n@param[in]\nbeta        device pointer or host pointer to scalar beta.\n@param[in, out]\ny           device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy        [rocblas_int]\nspecifies the increment for the elements of vectors y_i.\n@param[in]\nstridey     [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_y. However, ensure that stride_y is of appropriate size. When trans equals rocblas_operation_none\nthis typically means stride_y >= m * incy, otherwise stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hshgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const rocblas_half,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_half,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut rocblas_half,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hssgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const rocblas_half,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_half,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tstgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const rocblas_bfloat16,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_bfloat16,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut rocblas_bfloat16,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tssgemv_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const rocblas_bfloat16,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_bfloat16,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        strideA: rocblas_stride,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        strideA: rocblas_stride,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hshgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const rocblas_half,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_half,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut rocblas_half,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hssgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const rocblas_half,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_half,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tstgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const rocblas_bfloat16,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_bfloat16,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut rocblas_bfloat16,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_tssgemv_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const rocblas_bfloat16,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_bfloat16,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhbmv performs the matrix-vector operations:\n\ny := alpha*A*x + beta*y\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian band matrix, with k super-diagonals.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: The upper triangular part of A is being supplied.\n- rocblas_fill_lower: The lower triangular part of A is being supplied.\n@param[in]\nn         [rocblas_int]\nthe order of the matrix A.\n@param[in]\nk         [rocblas_int]\nthe number of super-diagonals of the matrix A. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device pointer storing matrix A. Of dimension (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe leading (k + 1) by n part of A must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of A will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == rocblas_fill_lower:\nThe leading (k + 1) by n part of A must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of A will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof A will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. must be >= k + 1.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_chbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhbmv_batched performs one of the matrix-vector operations:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: The upper triangular part of each A_i is being supplied.\n- rocblas_fill_lower: The lower triangular part of each A_i is being supplied.\n@param[in]\nn         [rocblas_int]\nthe order of each matrix A_i.\n@param[in]\nk         [rocblas_int]\nthe number of super-diagonals of each matrix A_i. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix_i A of dimension (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe leading (k + 1) by n part of each A_i must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of each A_i will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == rocblas_fill_lower:\nThe leading (k + 1) by n part of each A_i must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of each A_i will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. must be >= max(1, n).\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhbmv_strided_batched performs one of the matrix-vector operations:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: The upper triangular part of each A_i is being supplied.\n- rocblas_fill_lower: The lower triangular part of each A_i is being supplied.\n@param[in]\nn         [rocblas_int]\nthe order of each matrix A_i.\n@param[in]\nk         [rocblas_int]\nthe number of super-diagonals of each matrix A_i. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe leading (k + 1) by n part of each A_i must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of each A_i will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == rocblas_fill_lower:\nThe leading (k + 1) by n part of each A_i must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of each A_i will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. must be >= max(1, n).\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx         device array pointing to the first vector y_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array pointing to the first vector y_1.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nstride_y  [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhemv performs one of the matrix-vector operations:\n\ny := alpha*A*x + beta*y\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.\n- rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [rocblas_int]\nthe order of the matrix A.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device pointer storing matrix A. Of dimension (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular part of A must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of A will not be referenced.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular part of A must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of A will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof A will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. must be >= max(1, n).\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_chemv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chemv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhemv_batched performs one of the matrix-vector operations:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, for each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.\n- rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [rocblas_int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i of dimension (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular part of each A_i must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of each A_i will not be referenced.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular part of each A_i must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of each A_i will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. must be >= max(1, n).\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chemv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chemv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhemv_strided_batched performs one of the matrix-vector operations:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, for each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied.\n- rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [rocblas_int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i of dimension (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular part of each A_i must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of each A_i will not be referenced.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular part of each A_i must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of each A_i will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. must be >= max(1, n).\n@param[in]\nstride_A    [rocblas_stride]\nstride from the start of one (A_i) to the next (A_i+1).\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nstride_y  [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chemv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chemv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nher performs the matrix-vector operations:\n\nA := A + alpha*x*x**H\nwhere alpha is a real scalar, x is a vector, and A is an\nn by n Hermitian matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of A is supplied in A.\n- rocblas_fill_lower: The lower triangular part of A is supplied in A.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in, out]\nA         device pointer storing the specified triangular portion of the Hermitian matrix A. Of size (lda * n).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe lower triangluar portion will not be touched.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe upper triangular portion will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. Must be at least max(1, n)."]
    pub fn rocblas_cher(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nher_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*x_i**H\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in, out]\nA         device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe lower triangular portion of each A_i will not be touched.\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe upper triangular portion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. Must be at least max(1, n).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_cher_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const *const rocblas_float_complex,
        incx: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nher_strided_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*x_i**H\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n Hermitian matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in A.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in A.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in, out]\nA         device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe lower triangular portion of each A_i will not be touched.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe upper triangular portion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstride_A    [rocblas_stride]\nstride from the start of one (A_i) and the next (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_cher_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nher2 performs the matrix-vector operations:\n\nA := A + alpha*x*y**H + conj(alpha)*y*x**H\nwhere alpha is a complex scalar, x and y are vectors, and A is an\nn by n Hermitian matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of A is supplied.\n- rocblas_fill_lower: The lower triangular part of A is supplied.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nA         device pointer storing the specified triangular portion of\nthe Hermitian matrix A. Of size (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe lower triangular portion of A will not be touched.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe upper triangular portion of A will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. Must be at least max(lda, 1)."]
    pub fn rocblas_cher2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nher2_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n Hermitian matrix for each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in, out]\nA         device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i of size (lda, n).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe lower triangular portion of each A_i will not be touched.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe upper triangular portion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. Must be at least max(lda, 1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_cher2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nher2_strided_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n Hermitian matrix for each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nspecifies the stride between the beginning of one vector (x_i) and the next (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstride_y  [rocblas_stride]\nspecifies the stride between the beginning of one vector (y_i) and the next (y_i+1).\n@param[in, out]\nA         device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of\neach Hermitian matrix A_i.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe lower triangular portion of each A_i will not be touched.\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe upper triangular portion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. Must be at least max(lda, 1).\n@param[in]\nstride_A  [rocblas_stride]\nspecifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_cher2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian matrix, supplied in packed form (see description below).\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: the upper triangular part of the Hermitian matrix A is supplied in AP.\n- rocblas_fill_lower: the lower triangular part of the Hermitian matrix A is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe order of the matrix A. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1) ---> [(1,0),(2,1),(4,0),(3,2),(5,-1),(6,0)]\n(3,-2) (5, 1) (6, 0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1) ---> [(1,0),(2,-1),(3,-2),(4,0),(5,1),(6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_chpmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        AP: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        AP: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        AP: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        AP: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpmv_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, supplied in packed form (see description below),\nfor each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.\n- rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP      device pointer of device pointers storing the packed version of the specified triangular\nportion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1) ---> [(1,0),(2,1),(4,0),(3,2),(5,-1),(6,0)]\n(3,-2) (5, 1) (6, 0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1) ---> [(1,0),(2,-1),(3,-2),(4,0),(5,1),(6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chpmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        AP: *const *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        AP: *const *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        AP: *const *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        AP: *const *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpmv_strided_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, supplied in packed form (see description below),\nfor each batch in i = [1, batch_count].\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: the upper triangular part of each Hermitian matrix A_i is supplied in AP.\n- rocblas_fill_lower: the lower triangular part of each Hermitian matrix A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed\nversion of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1) ---> [(1,0),(2,1),(4,0),(3,2),(5,-1),(6,0)]\n(3,-2) (5, 1) (6, 0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1) ---> [(1,0),(2,-1),(3,-2),(4,0),(5,1),(6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (AP_i) and the next one (AP_i+1).\n@param[in]\nx         device array pointing to the beginning of the first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[in, out]\ny         device array pointing to the beginning of the first vector (y_1).\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nstride_y  [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chpmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        AP: *const rocblas_float_complex,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        AP: *const rocblas_double_complex,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        AP: *const rocblas_float_complex,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        AP: *const rocblas_double_complex,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpr performs the matrix-vector operations:\n\nA := A + alpha*x*x**H\nwhere alpha is a real scalar, x is a vector, and A is an\nn by n Hermitian matrix, supplied in packed form.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of A is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in, out]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]\n(4,-9) (5,-3) (6,0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0."]
    pub fn rocblas_chpr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        AP: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        AP: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: i64,
        AP: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: i64,
        AP: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpr_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*x_i**H\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in, out]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]\n(4,-9) (5,-3) (6,0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_chpr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        AP: *const *mut rocblas_float_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        AP: *const *mut rocblas_double_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const *const rocblas_float_complex,
        incx: i64,
        AP: *const *mut rocblas_float_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        AP: *const *mut rocblas_double_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpr_strided_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*x_i**H\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in, out]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]\n(4,-9) (5,-3) (6,0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nstride_A    [rocblas_stride]\nstride from the start of one (A_i) and the next (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_chpr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        AP: *mut rocblas_float_complex,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        AP: *mut rocblas_double_complex,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        AP: *mut rocblas_float_complex,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        AP: *mut rocblas_double_complex,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpr2 performs the matrix-vector operations:\n\nA := A + alpha*x*y**H + conj(alpha)*y*x**H\nwhere alpha is a complex scalar, x and y are vectors, and A is an\nn by n Hermitian matrix, supplied in packed form.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of A is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]\n(4,-9) (5,-3) (6,0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0."]
    pub fn rocblas_chpr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        AP: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        AP: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        AP: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        AP: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpr2_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in, out]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]\n(4,-9) (5,-3) (6,0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) --> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_chpr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        AP: *const *mut rocblas_float_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        AP: *const *mut rocblas_double_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        AP: *const *mut rocblas_float_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        AP: *const *mut rocblas_double_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nhpr2_strided_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector (y_1).\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstride_y  [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in, out]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,1),(3,0),(4,9),(5,3),(6,0)]\n(4,-9) (5,-3) (6,0)\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3) ---> [(1,0),(2,-1),(4,-9),(3,0),(5,-3),(6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed\nand are assumed to be 0.\n@param[in]\nstride_A    [rocblas_stride]\nstride from the start of one (A_i) and the next (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_chpr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        AP: *mut rocblas_float_complex,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        AP: *mut rocblas_double_complex,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chpr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stride_y: rocblas_stride,
        AP: *mut rocblas_float_complex,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhpr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stride_y: rocblas_stride,
        AP: *mut rocblas_double_complex,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntrmv performs one of the matrix-vector operations:\n\nx = A*x or\nx = A**T*x or\nx = A**H*x\nwhere x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.\nThe vector x is overwritten.\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of A. n >= 0.\n\n@param[in]\nA         device pointer storing matrix A, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A, otherwise the lower triangular part of the leading n-by-n array contains the matrix A.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. lda must be at least max( 1, n ).\n\n@param[in, out]\nx         device pointer storing vector x. On exit, x is overwritten with the transformed vector x.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n"]
    pub fn rocblas_strmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntrmv_batched performs one of the matrix-vector operations:\n\nx_i = A_i*x_i or\nx_i = A_i**T*x_i or\nx_i = A_i**H*x_i, 0 < i < batch_count\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nThe vectors x_i are overwritten.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix.\n- rocblas_fill_lower:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of matrices A_i. n >= 0.\n\n@param[in]\nA         device pointer to an array of device pointers to the A_i matrices, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A_i. lda must be at least max( 1, n ).\n\n@param[in, out]\nx         device pointer to an array of device pointers to the x_i vectors. On exit, each x_i is overwritten with the transformed vector x_i.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of vectors x_i.\n\n@param[in]\nbatch_count [rocblas_int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn rocblas_strmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntrmv_strided_batched performs one of the matrix-vector operations:\n\nx_i = A_i*x_i or\nx_i = A_i**T*x_i, or\nx_i = A_i**H*x_i, 0 < i < batch_count\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nwith strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).\n\nThe vectors x_i are overwritten.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix.\n- rocblas_fill_lower:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of matrices A_i. n >= 0.\n\n@param[in]\nA         device pointer to the matrix A_1 of the batch, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A_i. lda must be at least max( 1, n ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one A_i matrix to the next A_{i + 1}.\n\n@param[in, out]\nx         device pointer to the vector x_1 of the batch. On exit, each x_i is overwritten with the transformed vector x_i.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of one vector x.\n\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one x_i vector to the next x_{i + 1}.\n\n@param[in]\nbatch_count [rocblas_int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn rocblas_strmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntpmv performs one of the matrix-vector operations:\n\nx = A*x or\nx = A**T*x or\nx = A**H*x\nwhere x is an n element vector and A is an n by n unit, or non-unit,\nupper or lower triangular matrix, supplied in the pack form.\nThe vector x is overwritten.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows of A. n >= 0.\n\n@param[in]\nA       device pointer storing matrix A,\nof dimension at leat ( n * ( n + 1 ) / 2 ).\n- Before entry with uplo = rocblas_fill_upper, the array A\nmust contain the upper triangular matrix packed sequentially,\ncolumn by column, so that\nA[0] contains a_{0,0}, A[1] and A[2] contain\na_{0,1} and a_{1, 1}, respectively, and so on.\n\n- Before entry with uplo = rocblas_fill_lower, the array A\nmust contain the lower triangular matrix packed sequentially,\ncolumn by column, so that\nA[0] contains a_{0,0}, A[1] and A[2] contain\na_{1,0} and a_{2,0}, respectively, and so on.\n\nNote that when DIAG = rocblas_diagonal_unit, the diagonal elements of A are\nnot referenced, but are assumed to be unity.\n\n@param[in, out]\nx      device pointer storing vector x. On exit, x is overwritten with the transformed vector x.\n\n@param[in]\nincx    [rocblas_int]\nspecifies the increment for the elements of x. incx must not be zero.\n"]
    pub fn rocblas_stpmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stpmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f32,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntpmv_batched performs one of the matrix-vector operations:\n\nx_i = A_i*x_i or\nx_i = A_i**T*x_i or\nx_i = A_i**H*x_i, 0 < i < batch_count\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nThe vectors x_i are overwritten.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix.\n- rocblas_fill_lower:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of matrices A_i. n >= 0.\n\n@param[in]\nA         device pointer to an array of device pointers to the A_i matrices, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.\n\n@param[in, out]\nx         device pointer to an array of device pointers to the x_i vectors. On exit, each x_i is overwritten with the transformed vector x_i.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of vectors x_i.\n\n@param[in]\nbatch_count [rocblas_int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn rocblas_stpmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f32,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f64,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_float_complex,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_double_complex,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stpmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const f32,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const f64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const rocblas_float_complex,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const rocblas_double_complex,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntpmv_strided_batched performs one of the matrix-vector operations:\n\nx_i = A_i*x_i or\nx_i = A_i**T*x_i or\nx_i = A_i**H*x_i, 0 < i < batch_count\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nwith strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).\nThe vectors x_i are overwritten.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix.\n- rocblas_fill_lower:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of matrices A_i. n >= 0.\n\n@param[in]\nA       device pointer to the matrix A_1 of the batch, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one A_i matrix to the next A_{i + 1}.\n\n@param[in, out]\nx       device pointer to the vector x_1 of the batch. On exit, each x_i is overwritten with the transformed vector x_i.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of one vector x.\n\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one x_i vector to the next x_{i + 1}.\n\n@param[in]\nbatch_count [rocblas_int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn rocblas_stpmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stpmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f32,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_float_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_double_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntbmv performs one of the matrix-vector operations:\n\nx := A*x      or\nx := A**T*x   or\nx := A**H*x,\nx is a vectors and A is a banded n by n matrix (see description below).\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: A is an upper banded triangular matrix.\n- rocblas_fill_lower: A is a  lower banded triangular matrix.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\ndiag      [rocblas_diagonal]\n- rocblas_diagonal_unit: The main diagonal of A is assumed to consist of only\n1's and is not referenced.\n- rocblas_diagonal_non_unit: No assumptions are made of A's main diagonal.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of the matrix represented by A.\n@param[in]\nk         [rocblas_int]\n\nif uplo == rocblas_fill_upper, k specifies the number of super-diagonals\nof the matrix A.\n\nif uplo == rocblas_fill_lower, k specifies the number of sub-diagonals\nof the matrix A.\nk must satisfy k > 0 && k < lda.\n@param[in]\nA         device pointer storing banded triangular matrix A.\n\nif uplo == rocblas_fill_upper:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (rocblas_fill_upper; n = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\n\nif uplo == rocblas_fill_lower:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (rocblas_fill_lower; n = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. lda must satisfy lda > k.\n@param[in, out]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n"]
    pub fn rocblas_stbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntbmv_batched performs one of the matrix-vector operations:\n\nx_i := A_i*x_i      or\nx_i := A_i**T*x_i   or\nx_i := A_i**H*x_i,\nwhere (A_i, x_i) is the i-th instance of the batch.\nx_i is a vector and A_i is an n by n matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: each A_i is an upper banded triangular matrix.\n- rocblas_fill_lower: each A_i is a  lower banded triangular matrix.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether each matrix A_i is tranposed (conjugated) or not.\n@param[in]\ndiag      [rocblas_diagonal]\n- rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only\n1's and is not referenced.\n- rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of the matrix represented by each A_i.\n@param[in]\nk         [rocblas_int]\n\nif uplo == rocblas_fill_upper, k specifies the number of super-diagonals\nof each matrix A_i.\n\nif uplo == rocblas_fill_lower, k specifies the number of sub-diagonals\nof each matrix A_i.\nk must satisfy k > 0 && k < lda.\n@param[in]\nA         device array of device pointers storing each banded triangular matrix A_i.\n\nif uplo == rocblas_fill_upper:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (rocblas_fill_upper; n = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\n\nif uplo == rocblas_fill_lower:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (rocblas_fill_lower; n = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. lda must satisfy lda > k.\n@param[in, out]\nx         device array of device pointer storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_stbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntbmv_strided_batched performs one of the matrix-vector operations:\n\nx_i := A_i*x_i      or\nx_i := A_i**T*x_i   or\nx_i := A_i**H*x_i,\nwhere (A_i, x_i) is the i-th instance of the batch.\nx_i is a vector and A_i is an n by n matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\n- rocblas_fill_upper: each A_i is an upper banded triangular matrix.\n- rocblas_fill_lower: each A_i is a  lower banded triangular matrix.\n@param[in]\ntrans     [rocblas_operation]\nindicates whether each matrix A_i is tranposed (conjugated) or not.\n@param[in]\ndiag      [rocblas_diagonal]\n- rocblas_diagonal_unit: The main diagonal of each A_i is assumed to consist of only\n1's and is not referenced.\n- rocblas_diagonal_non_unit: No assumptions are made of each A_i's main diagonal.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of the matrix represented by each A_i.\n@param[in]\nk         [rocblas_int]\n\nif uplo == rocblas_fill_upper, k specifies the number of super-diagonals\nof each matrix A_i.\n\nif uplo == rocblas_fill_lower, k specifies the number of sub-diagonals\nof each matrix A_i.\nk must satisfy k > 0 && k < lda.\n@param[in]\nA         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.\n\nif uplo == rocblas_fill_upper:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (rocblas_fill_upper; n = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\n\nif uplo == rocblas_fill_lower:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (rocblas_fill_lower; n = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. lda must satisfy lda > k.\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in, out]\nx         device array to the first vector x_i of the batch.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one x_i matrix to the next x_(i + 1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_stbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntbsv solves:\n\nA*x = b or\nA**T*x = b or\nA**H*x = b\nwhere x and b are vectors and A is a banded triangular matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none: Solves A*x = b\n- rocblas_operation_transpose: Solves A**T*x = b\n- rocblas_operation_conjugate_transpose: Solves A**H*x = b\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit: A is assumed to be unit triangular (i.e. the diagonal elements\nof A are not used in computations).\n- rocblas_diagonal_non_unit: A is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of b. n >= 0.\n@param[in]\nk         [rocblas_int]\n\nif(uplo == rocblas_fill_upper)\nk specifies the number of super-diagonals of A.\nif(uplo == rocblas_fill_lower)\nk specifies the number of sub-diagonals of A.\nk >= 0.\n\n@param[in]\nA         device pointer storing the matrix A in banded format.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\nlda >= (k + 1).\n\n@param[in, out]\nx         device pointer storing input vector b. Overwritten by the output vector x.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n"]
    pub fn rocblas_stbsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stbsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntbsv_batched solves:\n\nA_i*x_i = b_i or\nA_i**T*x_i = b_i or\nA_i**H*x_i = b_i\nwhere x_i and b_i are vectors and A_i is a banded triangular matrix,\nfor i = [1, batch_count].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix.\n- rocblas_fill_lower:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none: Solves A_i*x_i = b_i\n- rocblas_operation_transpose: Solves A_i**T*x_i = b_i\n- rocblas_operation_conjugate_transpose: Solves A_i**H*x_i = b_i\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\n- rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of each b_i. n >= 0.\n@param[in]\nk         [rocblas_int]\n\nif(uplo == rocblas_fill_upper)\nk specifies the number of super-diagonals of each A_i.\nif(uplo == rocblas_fill_lower)\nk specifies the number of sub-diagonals of each A_i.\nk >= 0.\n\n@param[in]\nA         device vector of device pointers storing each matrix A_i in banded format.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\nlda >= (k + 1).\n\n@param[in, out]\nx         device vector of device pointers storing each input vector b_i. Overwritten by each output\nvector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_stbsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stbsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntbsv_strided_batched solves:\n\nA_i*x_i = b_i or\nA_i**T*x_i = b_i or\nA_i**H*x_i = b_i\nwhere x_i and b_i are vectors and A_i is a banded triangular matrix,\nfor i = [1, batch_count].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix.\n- rocblas_fill_lower:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none: Solves A_i*x_i = b_i\n- rocblas_operation_transpose: Solves A_i**T*x_i = b_i\n- rocblas_operation_conjugate_transpose: Solves A_i**H*x_i = b_i\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\n- rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of each b_i. n >= 0.\n@param[in]\nk         [rocblas_int]\n\nif(uplo == rocblas_fill_upper)\nk specifies the number of super-diagonals of each A_i.\nif(uplo == rocblas_fill_lower)\nk specifies the number of sub-diagonals of each A_i.\nk >= 0.\n\n@param[in]\nA         device pointer pointing to the first banded matrix A_1.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\nlda >= (k + 1).\n@param[in]\nstride_A  [rocblas_stride]\nspecifies the distance between the start of one matrix (A_i) and the next (A_i+1).\n\n@param[in, out]\nx         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nspecifies the distance between the start of one vector (x_i) and the next (x_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_stbsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        k: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stbsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtbsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctbsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztbsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        k: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntrsv solves:\n\nA*x = b or\nA**T*x = b or\nA**H*x = b,\nwhere x and b are vectors and A is a triangular matrix.\nThe vector x is overwritten on b.\n\nAlthough not widespread, some gemm kernels used by trsv may use atomic operations.\nSee Atomic Operations in the API Reference Guide for more information.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of b. n >= 0.\n\n@param[in]\nA         device pointer storing matrix A, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A, otherwise the lower triangular part of the leading n-by-n array contains the matrix A.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. lda must be at least max( 1, n ).\n\n@param[in, out]\nx         device pointer storing vector x. On exit, x is overwritten with the transformed vector x.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n"]
    pub fn rocblas_strsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntrsv_batched solves:\n\nA_i*x_i = b_i or\nA_i**T*x_i = b_i or\nA_i**H*x_i = b_i,\nwhere (A_i, x_i, b_i) is the i-th instance of the batch.\nx_i and b_i are vectors and A_i is an\nn by n triangular matrix.\n\nThe vector x is overwritten on b.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of b. n >= 0.\n\n@param[in]\nA         device pointer to an array of device pointers to the A_i matrices, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A_i. lda must be at least max( 1, n ).\n\n@param[in, out]\nx         device pointer to an array of device pointers to the x_i vectors. On exit, each x_i is overwritten with the transformed vector x_i.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_strsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntrsv_strided_batched solves:\n\nA_i*x_i = b_i or\nA_i**T*x_i = b_i or\nA_i**H*x_i = b_i,\nwhere (A_i, x_i, b_i) is the i-th instance of the batch.\nx_i and b_i are vectors and A_i is an n by n triangular matrix, for i = 1, ..., batch_count.\n\nThe vector x is overwritten on b.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:   op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of each b_i. n >= 0.\n\n@param[in]\nA         device pointer to the matrix A_1 of the batch, of dimension ( lda, n ). If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix A_i, otherwise the lower triangular part of the leading n-by-n array contains the matrix A_i.\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A_i. lda must be at least max( 1, n ).\n\n@param[in, out]\nx         device pointer to the vector x_1 of the batch. On exit, each x_i is overwritten with the transformed vector x_i.\n\n@param[in]\nstride_x [rocblas_stride]\nstride from the start of one x_i vector to the next x_(i + 1)\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_strsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntpsv solves:\n\nA*x = b or\nA**T*x = b or\nA**H*x = b\nwhere x and b are vectors and A is a triangular matrix stored in the packed format.\n\nThe input vector b is overwritten by the output vector x.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_none: Solves A*x = b\n- rocblas_operation_transpose: Solves A**T*x = b\n- rocblas_operation_conjugate_transpose: Solves A**H*x = b\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:  A is assumed to be unit triangular (i.e. the diagonal elements\nof A are not used in computations).\n- rocblas_diagonal_non_unit: A is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of b. n >= 0.\n\n@param[in]\nAP        device pointer storing the packed version of matrix A,\nof dimension >= (n * (n + 1) / 2).\n\n@param[in, out]\nx         device pointer storing vector b on input, overwritten by x on output.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n"]
    pub fn rocblas_stpsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const f32,
        x: *mut f32,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const f64,
        x: *mut f64,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpsv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stpsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const f32,
        x: *mut f32,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const f64,
        x: *mut f64,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpsv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntpsv_batched solves:\n\nA_i*x_i = b_i or\nA_i**T*x_i = b_i or\nA_i**H*x_i = b_i\nwhere x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,\nfor i in [1, batch_count].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  each A_i is an upper triangular matrix.\n- rocblas_fill_lower:  each A_i is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_none: Solves A*x = b\n- rocblas_operation_transpose: Solves A**T*x = b\n- rocblas_operation_conjugate_transpose: Solves A**H*x = b\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit: Each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\n- rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of each b_i. n >= 0.\n\n@param[in]\nAP        device array of device pointers storing the packed versions of each matrix A_i,\nof dimension >= (n * (n + 1) / 2).\n\n@param[in, out]\nx         device array of device pointers storing each input vector b_i, overwritten by x_i on output.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatch_count [rocblas_int]\nspecifies the number of instances in the batch.\n"]
    pub fn rocblas_stpsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const *const rocblas_float_complex,
        x: *const *mut rocblas_float_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpsv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const *const rocblas_double_complex,
        x: *const *mut rocblas_double_complex,
        incx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stpsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const *const rocblas_float_complex,
        x: *const *mut rocblas_float_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpsv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const *const rocblas_double_complex,
        x: *const *mut rocblas_double_complex,
        incx: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\ntpsv_strided_batched solves:\n\nA_i*x_i = b_i or\nA_i**T*x_i = b_i or\nA_i**H*x_i = b_i\nwhere x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,\nfor i in [1, batch_count].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  each A_i is an upper triangular matrix.\n- rocblas_fill_lower:  each A_i is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_none: Solves A*x = b\n- rocblas_operation_transpose: Solves A**T*x = b\n- rocblas_operation_conjugate_transpose: Solves A**H*x = b\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\n- rocblas_diagonal_non_unit: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [rocblas_int]\nn specifies the number of rows of each b_i. n >= 0.\n\n@param[in]\nAP        device pointer pointing to the first packed matrix A_1,\nof dimension >= (n * (n + 1) / 2).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).\n\n@param[in, out]\nx         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.\n\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the beginning of one vector (x_i) and the next (x_i+1).\n@param[in]\nbatch_count [rocblas_int]\nspecifies the number of instances in the batch.\n"]
    pub fn rocblas_stpsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const f32,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const f64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const rocblas_float_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpsv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: rocblas_int,
        AP: *const rocblas_double_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_stpsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const f32,
        stride_A: rocblas_stride,
        x: *mut f32,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtpsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const f64,
        stride_A: rocblas_stride,
        x: *mut f64,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctpsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const rocblas_float_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztpsv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        n: i64,
        AP: *const rocblas_double_complex,
        stride_A: rocblas_stride,
        x: *mut rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsymv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n symmetric matrix.\n\nsymv has an implementation which uses atomic operations. See Atomic Operations\nin the API Reference Guide for more information.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo     [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced.\n- if rocblas_fill_lower, the upper part of A is not referenced.\n@param[in]\nn         [rocblas_int]\n@param[in]\nalpha\nspecifies the scalar alpha.\n@param[in]\nA         pointer storing matrix A on the GPU\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_ssymv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssymv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsymv_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batch_count.\nA a should contain an upper or lower triangular symmetric matrix\nand the opposing triangular part of A is not referenced.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced.\n- if rocblas_fill_lower, the upper part of A is not referenced.\n@param[in]\nn         [rocblas_int]\nnumber of rows and columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssymv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssymv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        beta: *const rocblas_float_complex,
        y: *const *mut rocblas_float_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        beta: *const rocblas_double_complex,
        y: *const *mut rocblas_double_complex,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsymv_strided_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batch_count.\nA a should contain an upper or lower triangular symmetric matrix\nand the opposing triangular part of A is not referenced.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nnumber of rows and columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nA         Device pointer to the first matrix A_1 on the GPU.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nstrideA     [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nstridex     [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nstridey     [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_y. However, ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssymv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssymv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        strideA: rocblas_stride,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        strideA: rocblas_stride,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const rocblas_float_complex,
        y: *mut rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const rocblas_double_complex,
        y: *mut rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      rocblas_fill\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\n@param[in]\nalpha\nspecifies the scalar alpha.\n@param[in]\nA         pointer storing matrix A on the GPU.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      specifies the scalar beta.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_sspmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        x: *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        x: *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspmv_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batch_count.\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nnumber of rows and columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sspmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspmv_strided_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batch_count.\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nnumber of rows and columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nA         Device pointer to the first matrix A_1 on the GPU.\n@param[in]\nstrideA     [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nstridex     [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex. However, ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nstridey     [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey. However, ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sspmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        strideA: rocblas_stride,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        strideA: rocblas_stride,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        strideA: rocblas_stride,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        strideA: rocblas_stride,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsbmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      rocblas_fill\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\n@param[in]\nk         [rocblas_int]\nspecifies the number of sub- and super-diagonals.\n@param[in]\nalpha\nspecifies the scalar alpha.\n@param[in]\nA         pointer storing matrix A on the GPU.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of matrix A.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      specifies the scalar beta.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n"]
    pub fn rocblas_ssbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsbmv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsbmv_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsbmv_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric banded matrix, for i = 1, ..., batch_count.\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nnumber of rows and columns of each matrix A_i.\n@param[in]\nk         [rocblas_int]\nspecifies the number of sub- and super-diagonals.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsbmv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsbmv_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsbmv_strided_batched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric banded matrix, for i = 1, ..., batch_count.\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nnumber of rows and columns of each matrix A_i.\n@param[in]\nk         [rocblas_int]\nspecifies the number of sub- and super-diagonals.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nA         Device pointer to the first matrix A_1 on the GPU.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nstrideA     [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nstridex     [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex. However, ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nstridey     [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey. However, ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsbmv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        strideA: rocblas_stride,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsbmv_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        strideA: rocblas_stride,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nger,geru,gerc performs the matrix-vector operations:\n\nA := A + alpha*x*y**T , OR\nA := A + alpha*x*y**H for gerc\nwhere alpha is a scalar, x and y are vectors, and A is an\nm by n matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nm         [rocblas_int]\nthe number of rows of the matrix A.\n@param[in]\nn         [rocblas_int]\nthe number of columns of the matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n"]
    pub fn rocblas_sger(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        y: *const f32,
        incy: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dger(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        y: *const f64,
        incy: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeru(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeru(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgerc(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgerc(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sger_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        A: *mut f32,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dger_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        A: *mut f64,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeru_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeru_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgerc_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgerc_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nger_batched,geru_batched,gerc_batched perform a batch of the matrix-vector operations:\n\nA := A + alpha*x*y**T , OR\nA := A + alpha*x*y**H for gerc\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha is a scalar, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nm         [rocblas_int]\nthe number of rows of each matrix A_i.\n@param[in]\nn         [rocblas_int]\nthe number of columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in, out]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sger_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        y: *const *const f32,
        incy: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dger_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        y: *const *const f64,
        incy: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeru_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeru_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgerc_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgerc_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sger_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        A: *const *mut f32,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dger_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        A: *const *mut f64,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeru_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeru_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgerc_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgerc_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nger_strided_batched,geru_strided_batched,gerc_strided_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*y_i**T, OR\nA_i := A_i + alpha*x_i*y_i**H  for gerc\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha is a scalar, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nm         [rocblas_int]\nthe number of rows of each matrix A_i.\n@param[in]\nn         [rocblas_int]\nthe number of columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [rocblas_int]\nspecifies the increments for the elements of each vector x_i.\n@param[in]\nstridex   [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical\ncase this means stride_x >= m * incx.\n@param[in, out]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nstridey   [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_y. However, ensure that stride_y is of appropriate size. For a typical\ncase this means stride_y >= n * incy.\n@param[in, out]\nA         device pointer to the first matrix (A_1) in the batch.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA     [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sger_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dger_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeru_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeru_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgerc_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgerc_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sger_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        y: *const f32,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dger_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        y: *const f64,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeru_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeru_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgerc_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgerc_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspr performs the matrix-vector operations:\n\nA := A + alpha*x*x**T\nwhere alpha is a scalar, x is a vector, and A is an\nn by n symmetric matrix, supplied in packed form.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of A is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in, out]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe symmetric matrix A. Of at least size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0"]
    pub fn rocblas_sspr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        AP: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        AP: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cspr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        AP: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zspr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        AP: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        AP: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        AP: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cspr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        AP: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zspr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        AP: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspr_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*x_i**T\nwhere alpha is a scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in, out]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_sspr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        AP: *const *mut f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        AP: *const *mut f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cspr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        AP: *const *mut rocblas_float_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zspr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        AP: *const *mut rocblas_double_complex,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        AP: *const *mut f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        AP: *const *mut f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cspr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        AP: *const *mut rocblas_float_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zspr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        AP: *const *mut rocblas_double_complex,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspr_strided_batched performs the matrix-vector operations:\n\nA_i := A_i + alpha*x_i*x_i**T\nwhere alpha is a scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in, out]\nAP        device pointer storing the packed version of the specified triangular portion of\neach symmetric matrix A_i. Points to the first A_1.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nstride_A    [rocblas_stride]\nstride from the start of one (A_i) and the next (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_sspr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        AP: *mut f32,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        AP: *mut f64,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cspr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        AP: *mut rocblas_float_complex,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zspr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        AP: *mut rocblas_double_complex,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stride_x: rocblas_stride,
        AP: *mut f32,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stride_x: rocblas_stride,
        AP: *mut f64,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cspr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        AP: *mut rocblas_float_complex,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zspr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        AP: *mut rocblas_double_complex,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspr2 performs the matrix-vector operation:\n\nA := A + alpha*x*y**T + alpha*y*x**T\nwhere alpha is a scalar, x and y are vectors, and A is an\nn by n symmetric matrix, supplied in packed form.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of A is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe symmetric matrix A. Of at least size ((n * (n + 1)) / 2).\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0"]
    pub fn rocblas_sspr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        y: *const f32,
        incy: rocblas_int,
        AP: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        y: *const f64,
        incy: rocblas_int,
        AP: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        AP: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        AP: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspr2_batched performs the matrix-vector operation:\n\nA_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T\nwhere alpha is a scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in, out]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batch_count.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_sspr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        y: *const *const f32,
        incy: rocblas_int,
        AP: *const *mut f32,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        y: *const *const f64,
        incy: rocblas_int,
        AP: *const *mut f64,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        AP: *const *mut f32,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        AP: *const *mut f64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nspr2_strided_batched performs the matrix-vector operation:\n\nA_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T\nwhere alpha is a scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- rocblas_fill_upper: The upper triangular part of each A_i is supplied in AP.\n- rocblas_fill_lower: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A_i. Must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector (y_1).\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstride_y  [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in, out]\nAP        device pointer storing the packed version of the specified triangular portion of\neach symmetric matrix A_i. Points to the first A_1.\n\nif uplo == rocblas_fill_upper:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (rocblas_fill_upper; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\n\nif uplo == rocblas_fill_lower:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion\ncolumn-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (rocblas_fill_lower; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nstride_A    [rocblas_stride]\nstride from the start of one (A_i) and the next (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch."]
    pub fn rocblas_sspr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const f32,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        AP: *mut f32,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const f64,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        AP: *mut f64,
        stride_A: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sspr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const f32,
        incy: i64,
        stride_y: rocblas_stride,
        AP: *mut f32,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dspr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const f64,
        incy: i64,
        stride_y: rocblas_stride,
        AP: *mut f64,
        stride_A: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsyr performs the matrix-vector operations:\n\nA := A + alpha*x*x**T\nwhere alpha is a scalar, x is a vector, and A is an\nn by n symmetric matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in, out]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n"]
    pub fn rocblas_ssyr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        A: *mut f32,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        A: *mut f64,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsyr_batched performs a batch of matrix-vector operations:\n\nA[i] := A[i] + alpha*x[i]*x[i]**T\nwhere alpha is a scalar, x is an array of vectors, and A is an array of\nn by n symmetric matrices, for i = 1 , ... , batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in, out]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        A: *const *mut f32,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        A: *const *mut f64,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsyr_strided_batched performs the matrix-vector operations:\n\nA[i] := A[i] + alpha*x[i]*x[i]**T\nwhere alpha is a scalar, vectors, and A is an array of\nn by n symmetric matrices, for i = 1 , ... , batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [rocblas_stride]\nspecifies the pointer increment between vectors (x_i) and (x_i+1).\n@param[in, out]\nA         device pointer to the first matrix A_1.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA   [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsyr2 performs the matrix-vector operations:\n\nA := A + alpha*x*y**T + alpha*y*x**T\nwhere alpha is a scalar, x and y are vectors, and A is an\nn by n symmetric matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n"]
    pub fn rocblas_ssyr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        y: *const f32,
        incy: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        y: *const f64,
        incy: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        A: *mut f32,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        A: *mut f64,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        y: *const rocblas_float_complex,
        incy: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        y: *const rocblas_double_complex,
        incy: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsyr2_batched performs a batch of matrix-vector operations:\n\nA[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T\nwhere alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a\nn by n symmetric matrix, for i = 1 , ... , batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in, out]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: rocblas_int,
        y: *const *const f32,
        incy: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: rocblas_int,
        y: *const *const f64,
        incy: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        y: *const *const rocblas_float_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        y: *const *const rocblas_double_complex,
        incy: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        A: *const *mut f32,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        A: *const *mut f64,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const *const rocblas_float_complex,
        incx: i64,
        y: *const *const rocblas_float_complex,
        incy: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const *const rocblas_double_complex,
        incx: i64,
        y: *const *const rocblas_double_complex,
        incy: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 2 API </b>\n\n\\details\nsyr2_strided_batched the matrix-vector operations:\n\nA[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T\nwhere alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a\nn by n symmetric matrices, for i = 1 , ... , batch_count\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n- if rocblas_fill_upper, the lower part of A is not referenced\n- if rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\nn         [rocblas_int]\nthe number of rows and columns of each matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [rocblas_stride]\nspecifies the pointer increment between vectors (x_i) and (x_i+1).\n@param[in]\ny         device pointer to the first vector y_1.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [rocblas_stride]\nspecifies the pointer increment between vectors (y_i) and (y_i+1).\n@param[in, out]\nA         device pointer to the first matrix A_1.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA   [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f32,
        x: *const f32,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const f32,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const f64,
        x: *const f64,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const f64,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: rocblas_int,
        stridey: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: rocblas_stride,
        y: *const f32,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: rocblas_stride,
        y: *const f64,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_float_complex,
        x: *const rocblas_float_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_float_complex,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        alpha: *const rocblas_double_complex,
        x: *const rocblas_double_complex,
        incx: i64,
        stridex: rocblas_stride,
        y: *const rocblas_double_complex,
        incy: i64,
        stridey: rocblas_stride,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nhemm performs one of the matrix-matrix operations:\n\nC := alpha*A*B + beta*C if side == rocblas_side_left,\nC := alpha*B*A + beta*C if side == rocblas_side_right,\n\nwhere alpha and beta are scalars, B and C are m by n matrices, and\nA is a Hermitian matrix stored as either upper or lower.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside  [rocblas_side]\n- rocblas_side_left:      C := alpha*A*B + beta*C\n- rocblas_side_right:     C := alpha*B*A + beta*C\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix\n- rocblas_fill_lower:  A is a  lower triangular matrix\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B and C. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B and C. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A and B are not referenced.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\n- A is m by m if side == rocblas_side_left\n- A is n by n if side == rocblas_side_right\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nB       pointer storing matrix B on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n"]
    pub fn rocblas_chemm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chemm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nhemm_batched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,\nC_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a Hermitian matrix stored as either upper or lower.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside  [rocblas_side]\n- rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i\n- rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix\n- rocblas_fill_lower:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nA       device array of device pointers storing each matrix A_i on the GPU.\n- A_i is m by m if side == rocblas_side_left\n- A_i is n by n if side == rocblas_side_right\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nB       device array of device pointers storing each matrix B_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C_i need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m ).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chemm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chemm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nhemm_strided_batched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,\nC_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a Hermitian matrix stored as either upper or lower.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside  [rocblas_side]\n- rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i\n- rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix\n- rocblas_fill_lower:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nA       device pointer to first matrix A_1\n- A_i is m by m if side == rocblas_side_left\n- A_i is n by n if side == rocblas_side_right\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nB       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif side = rocblas_operation_none,  ldb >= max( 1, m ),\notherwise ldb >= max( 1, n ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_chemm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_chemm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zhemm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nherk performs one of the matrix-matrix operations for a Hermitian rank-k update:\n\nC := alpha*op( A )*op( A )^H + beta*C,\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A ) = A, and A is n by k if transA == rocblas_operation_none\nop( A ) = A^H and A is k by n if transA == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n- rocblas_operation_none:                 op(A) = A\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\nMatrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif transA = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn rocblas_cherk(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherk(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cherk_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const rocblas_float_complex,
        lda: i64,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherk_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const rocblas_double_complex,
        lda: i64,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nherk_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:\n\nC_i := alpha*op( A_i )*op( A_i )^H + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none\nop( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_conjugate_transpose: op(A) = A^H\n- rocblas_operation_none:                op(A) = A\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen transA is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif transA = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_cherk_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        beta: *const f32,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherk_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        beta: *const f64,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cherk_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const rocblas_float_complex,
        lda: i64,
        beta: *const f32,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherk_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const rocblas_double_complex,
        lda: i64,
        beta: *const f64,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nherk_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:\n\nC_i := alpha*op( A_i )*op( A_i )^H + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none\nop( A_i ) = A_i^H and A_i is k by n if transA == rocblas_operation_conjugate_transpose\n\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_conjugate_transpose: op(A) = A^H\n- rocblas_operation_none:                op(A) = A\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen transA is rocblas_operation_none, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif transA = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_cherk_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherk_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cherk_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherk_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nher2k performs one of the matrix-matrix operations for a Hermitian rank-2k update:\n\nC := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C,\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none\nop( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H\n- rocblas_operation_none:                 op( A ) = A, op( B ) = B\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\nMatrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nB       pointer storing matrix B on the GPU.\nMatrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn rocblas_cher2k(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2k(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher2k_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2k_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nher2k_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update:\n\nC_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_conjugate_transpose: op(A) = A^H\n- rocblas_operation_none:                op(A) = A\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nB       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n).\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_cher2k_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2k_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher2k_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const f32,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2k_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const f64,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nher2k_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update:\n\nC_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H\n- rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nB       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n).\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_cher2k_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2k_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cher2k_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zher2k_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nherkx performs one of the matrix-matrix operations for a Hermitian rank-k update:\n\nC := alpha*op( A )*op( B )^H + beta*C,\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none\nop( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_conjugate_transpose:  op( A ) = A^H, op( B ) = B^H\n- rocblas_operation_none:                 op( A ) = A, op( B ) = B\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\nMatrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nB       pointer storing matrix B on the GPU.\nMatrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn rocblas_cherkx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherkx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cherkx_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherkx_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nherkx_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:\n\nC_i := alpha*op( A_i )*op( B_i )^H + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_conjugate_transpose: op(A) = A^H\n- rocblas_operation_none:                op(A) = A\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nB       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_cherkx_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherkx_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cherkx_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const f32,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherkx_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const f64,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nherkx_strided_batched performs a batch of the matrix-matrix operations for a Hermitian rank-k update:\n\nC_i := alpha*op( A_i )*op( B_i )^H + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_conjugate_transpose: op( A_i ) = A_i^H, op( B_i ) = B_i^H\n- rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nB       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n).\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_cherkx_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherkx_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cherkx_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zherkx_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsymm performs one of the matrix-matrix operations:\n\nC := alpha*A*B + beta*C if side == rocblas_side_left,\nC := alpha*B*A + beta*C if side == rocblas_side_right,\n\nwhere alpha and beta are scalars, B and C are m by n matrices, and\nA is a symmetric matrix stored as either upper or lower.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside  [rocblas_side]\n- rocblas_side_left:      C := alpha*A*B + beta*C\n- rocblas_side_right:     C := alpha*B*A + beta*C\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix\n- rocblas_fill_lower:  A is a  lower triangular matrix\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B and C. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B and C. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A and B are not referenced.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\n- A is m by m if side == rocblas_side_left\n- A is n by n if side == rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nB       pointer storing matrix B on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n"]
    pub fn rocblas_ssymm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssymm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsymm_batched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,\nC_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a symmetric matrix stored as either upper or lower.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside  [rocblas_side]\n- rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i\n- rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix\n- rocblas_fill_lower:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nA       device array of device pointers storing each matrix A_i on the GPU.\n- A_i is m by m if side == rocblas_side_left\n- A_i is n by n if side == rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nB       device array of device pointers storing each matrix B_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C_i need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nMatrix dimension is m by n.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m ).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssymm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssymm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        beta: *const f32,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        beta: *const f64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsymm_strided_batched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == rocblas_side_left,\nC_i := alpha*B_i*A_i + beta*C_i if side == rocblas_side_right,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a symmetric matrix stored as either upper or lower.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside  [rocblas_side]\n- rocblas_side_left:      C_i := alpha*A_i*B_i + beta*C_i\n- rocblas_side_right:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A_i is an upper triangular matrix\n- rocblas_fill_lower:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nA       device pointer to first matrix A_1\n- A_i is m by m if side == rocblas_side_left\n- A_i is n by n if side == rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nB       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssymm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssymm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsymm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csymm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsymm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyrk performs one of the matrix-matrix operations for a symmetric rank-k update:\n\nC := alpha*op( A )*op( A )^T + beta*C,\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nop( A ) = A, and A is n by k if transA == rocblas_operation_none\nop( A ) = A^T and A is k by n if transA == rocblas_operation_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_transpose:           op(A) = A^T\n- rocblas_operation_none:                op(A) = A\n- rocblas_operation_conjugate_transpose: op(A) = A^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types. See cherk\nand zherk.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\nMatrix dimension is ( lda, k ) when if transA = rocblas_operation_none, otherwise (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif transA = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn rocblas_ssyrk(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrk(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrk(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrk(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyrk_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrk_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrk_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrk_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyrk_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:\n\nC_i := alpha*op( A_i )*op( A_i )^T + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) is an n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none\nop( A_i ) = A_i^T and A_i is k by n if transA == rocblas_operation_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_transpose:           op(A) = A^T\n- rocblas_operation_none:                op(A) = A\n- rocblas_operation_conjugate_transpose: op(A) = A^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types. See cherk\nand zherk.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen transA is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif transA = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyrk_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrk_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrk_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrk_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyrk_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        beta: *const f32,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrk_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        beta: *const f64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrk_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrk_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyrk_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:\n\nC_i := alpha*op( A_i )*op( A_i )^T + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) is an n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == rocblas_operation_none\nop( A_i ) = A_i^T and A_i is k by n if transA == rocblas_operation_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [rocblas_operation]\n- rocblas_operation_transpose:           op(A) = A^T\n- rocblas_operation_none:                op(A) = A\n- rocblas_operation_conjugate_transpose: op(A) = A^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types. See cherk\nand zherk.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen transA is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif transA = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       Device pointer to the first matrix C_1 on the GPU. on the GPU.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyrk_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrk_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrk_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrk_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyrk_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrk_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrk_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrk_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyr2k performs one of the matrix-matrix operations for a symmetric rank-2k update:\n\nC := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C,\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none\nop( A ) = A^T, op( B ) = B^T, and A and B are k by n if trans == rocblas_operation_transpose\nor for ssyr2k and dsyr2k when trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_transpose:           op( A ) = A^T, op( B ) = B^T\n- rocblas_operation_none:                op( A ) = A, op( B ) = B\n- rocblas_operation_conjugate_transpose: op( A ) = A^T, op( B ) = B^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types in csyr2k and zsyr2k.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A) and op(B). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\nMatrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nB       pointer storing matrix B on the GPU.\nMatrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B.\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn rocblas_ssyr2k(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2k(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2k(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2k(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr2k_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2k_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2k_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2k_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyr2k_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update:\n\nC_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^T, op( B_i ) = B_i^T, and A_i and B_i are k by n if trans == rocblas_operation_transpose\nor for ssyr2k_batched and dsyr2k_batched when trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T\n- rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i\n- rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types in csyr2k_batched and zsyr2k_batched.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nB       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n).\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyr2k_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2k_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2k_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2k_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr2k_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        beta: *const f32,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2k_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        beta: *const f64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2k_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2k_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyr2k_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-2k update:\n\nC_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^T, op( B_i ) = B_i^T, and A_i and B_i are k by n if trans == rocblas_operation_transpose\nor for ssyr2k_strided_batched and dsyr2k_strided_batched when trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T\n- rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i\n- rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types in csyr2k_strided_batched and zsyr2k_strided_batched.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n).\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nB       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       Device pointer to the first matrix C_1 on the GPU.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyr2k_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2k_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2k_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2k_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyr2k_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyr2k_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyr2k_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyr2k_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyrkx performs one of the matrix-matrix operations for a symmetric rank-k update:\n\nC := alpha*op( A )*op( B )^T + beta*C,\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == rocblas_operation_none\nop( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == rocblas_operation_transpose\nor for ssyrkx and dsyrkx when trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_transpose:           op( A ) = A^T, op( B ) = B^T\n- rocblas_operation_none:                op( A ) = A, op( B ) = B\n- rocblas_operation_conjugate_transpose: op( A ) = A^T, op( B ) = B^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types in csyrkx and zsyrkx.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A) and op(B). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       pointer storing matrix A on the GPU.\nMatrix dimension is ( lda, k ) when if trans = rocblas_operation_none, otherwise (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nB       pointer storing matrix B on the GPU.\nMatrix dimension is ( ldb, k ) when if trans = rocblas_operation_none, otherwise (ldb, n)\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       pointer storing matrix C on the GPU.\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn rocblas_ssyrkx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrkx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrkx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrkx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyrkx_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrkx_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrkx_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrkx_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyrkx_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:\n\nC_i := alpha*op( A_i )*op( B_i )^T + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nThis routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose\nor for ssyrkx_batched and dsyrkx_batched when trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T\n- rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i\n- rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types in csyrkx_batched and zsyrkx_batched.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nB       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       device array of device pointers storing each matrix C_i on the GPU.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyrkx_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrkx_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrkx_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrkx_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyrkx_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        beta: *const f32,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrkx_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        beta: *const f64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrkx_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrkx_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\nsyrkx_strided_batched performs a batch of the matrix-matrix operations for a symmetric rank-k update:\n\nC_i := alpha*op( A_i )*op( B_i )^T + beta*C_i,\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nThis routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == rocblas_operation_none\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == rocblas_operation_transpose\nor for ssyrkx_strided_batched and dsyrkx_strided_batched when trans == rocblas_operation_conjugate_transpose\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C_i is an upper triangular matrix\n- rocblas_fill_lower:  C_i is a  lower triangular matrix\n\n@param[in]\ntrans  [rocblas_operation]\n- rocblas_operation_transpose:           op( A_i ) = A_i^T, op( B_i ) = B_i^T\n- rocblas_operation_none:                op( A_i ) = A_i, op( B_i ) = B_i\n- rocblas_operation_conjugate_transpose: op( A_i ) = A_i^T, op( B_i ) = B_i^T\n\nrocblas_operation_conjugate_transpose is not supported for complex types in csyrkx_strided_batched and zsyrkx_strided_batched.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [rocblas_int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A_i.\n\nif trans = rocblas_operation_none,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nB       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is rocblas_operation_none, otherwise of dimension (ldb, n).\n\n@param[in]\nldb     [rocblas_int]\nldb specifies the first dimension of B_i.\n\nif trans = rocblas_operation_none,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nC       Device pointer to the first matrix C_1 on the GPU.\nonly the upper/lower triangular part of each C_i is accessed.\n\n@param[in]\nldc    [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in, out]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_ssyrkx_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrkx_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrkx_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrkx_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ssyrkx_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dsyrkx_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_csyrkx_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zsyrkx_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrmm performs one of the matrix-matrix operations:\n\nC := alpha*op( A )*B,   or\nC := alpha*B*op( A ),\n\nThe Legacy BLAS in-place trmm functionality,\n\nB := alpha*op( A )*B,   or\nB := alpha*B*op( A ),\n\nis available by setting pointer C equal to pointer B, and ldc equal to ldb.\n\nalpha  is a scalar,  B  is an m by n matrix, C  is an m by n matrix,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of\n\nop( A ) = A     or\nop( A ) = A^T   or\nop( A ) = A^H.\n\nWhen uplo == rocblas_fill_upper the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix and the strictly lower triangular part of\nA is not referenced. Here k is m when side == rocblas_side_left\nand is n when side == rocblas_side_right.\n\nWhen uplo == rocblas_fill_lower the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced. Here k is m when  side == rocblas_side_left\nand is n when side == rocblas_side_right.\n\nNote that when  diag == rocblas_diagonal_unit  the diagonal elements of\nA  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\nSpecifies whether op(A) multiplies B from the left or right as follows:\n- rocblas_side_left:       C := alpha*op( A )*B\n- rocblas_side_right:      C := alpha*B*op( A )\n\n@param[in]\nuplo    [rocblas_fill]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\nSpecifies the form of op(A) to be used in the matrix multiplication as follows:\n- rocblas_operation_none:    op(A) = A\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\nSpecifies whether or not A is unit triangular as follows:\n- rocblas_diagonal_unit:      A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and B need not be set before\nentry.\n\n@param[in]\nA       Device pointer to matrix A on the GPU.\nA has dimension ( lda, k ), where k is m\nwhen  side == rocblas_side_left  and\nis  n  when  side == rocblas_side_right.\n\nWhen uplo == rocblas_fill_upper the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == rocblas_fill_lower the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == rocblas_diagonal_unit  the diagonal elements of\nA  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side == rocblas_side_left,  lda >= max( 1, m ),\nif side == rocblas_side_right, lda >= max( 1, n ).\n\n@param[in]\nB       Device pointer to the matrix B on the GPU.\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[out]\nC      Device pointer to the matrix C on the GPU.\n\n@param[in]\nldc   [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, m).\nIf B and C are pointers to the same matrix then ldc must equal ldb or\nrocblas_status_invalid_value will be returned.\n"]
    pub fn rocblas_strmm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *const f32,
        ldb: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *const f64,
        ldb: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrmm_batched performs one of the matrix-matrix operations:\n\nC_i := alpha*op( A_i )*B_i,   or\nC_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,\n\nThe Legacy BLAS in-place trmm_batched functionality,\n\nB_i := alpha*op( A_i )*B_i,   or\nB_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,\n\nis available by setting pointer C equal to pointer B and ldc equal to ldb.\n\nalpha  is a scalar,  B_i  is an m by n matrix, C_i  is an m by n matrix,  A_i  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of\n\nop( A_i ) = A_i     or\nop( A_i ) = A_i^T   or\nop( A_i ) = A_i^H.\n\nWhen uplo == rocblas_fill_upper the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix and the strictly lower triangular part of\nA is not referenced. Here k is m when side == rocblas_side_left\nand is n when side == rocblas_side_right.\n\nWhen uplo == rocblas_fill_lower the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced. Here k is m when  side == rocblas_side_left\nand is n when side == rocblas_side_right.\n\nNote that when  diag == rocblas_diagonal_unit  the diagonal elements of\nA  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\nSpecifies whether op(A_i) multiplies B_i from the left or right as follows:\n- rocblas_side_left:       C_i := alpha*op( A_i )*B_i\n- rocblas_side_right:      C_i := alpha*B_i*op( A_i )\n\n@param[in]\nuplo    [rocblas_fill]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\nSpecifies the form of op(A_i) to be used in the matrix multiplication as follows:\n- rocblas_operation_none:    op(A_i) = A_i\n- rocblas_operation_transpose:      op(A_i) = A_i^T\n- rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H\n\n@param[in]\ndiag    [rocblas_diagonal]\nSpecifies whether or not A_i is unit triangular as follows:\n- rocblas_diagonal_unit:      A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i is not referenced and B_i need not be set before\nentry.\n\n@param[in]\nA       Device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  side == rocblas_side_left  and\nis  n  when  side == rocblas_side_right.\n\nWhen uplo == rocblas_fill_upper the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == rocblas_fill_lower the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == rocblas_diagonal_unit  the diagonal elements of\nA_i  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side == rocblas_side_left,  lda >= max( 1, m ),\nif side == rocblas_side_right, lda >= max( 1, n ).\n\n@param[in]\nB       device array of device pointers storing each matrix B_i on the GPU.\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[out]\nC      device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc   [rocblas_int]\nldc specifies the first dimension of C. ldc >= max( 1, m).\nIf B and C are pointers to the same array of pointers then ldc must\nequal ldb or rocblas_status_invalid_value will be returned.\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances i in the batch."]
    pub fn rocblas_strmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *const f32,
        ldb: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *const f64,
        ldb: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrmm_strided_batched performs one of the matrix-matrix operations:\n\nC_i := alpha*op( A_i )*B_i,   or\nC_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,\n\nThe Legacy BLAS in-place trmm_strided_batched functionality,\n\nB_i := alpha*op( A_i )*B_i,   or\nB_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batch_count -1,\n\nis available by setting pointer C equal to pointer B, ldc equal to ldb, and stride_C equal to stride_B.\n\nalpha  is a scalar,  B_i  is an m by n matrix, C_i  is an m by n matrix,  A_i  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A_i )  is one  of\n\nop( A_i ) = A_i   or\nop( A_i ) = A_i^T   or\nop( A_i ) = A_i^H.\n\nWhen uplo == rocblas_fill_upper the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix and the strictly lower triangular part of\nA is not referenced. Here k is m when side == rocblas_side_left\nand is n when side == rocblas_side_right.\n\nWhen uplo == rocblas_fill_lower the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced. Here k is m when  side == rocblas_side_left\nand is n when side == rocblas_side_right.\n\nNote that when  diag == rocblas_diagonal_unit  the diagonal elements of\nA  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\nSpecifies whether op(A_i) multiplies B_i from the left or right as follows:\n- rocblas_side_left:       C_i := alpha*op( A_i )*B_i\n- rocblas_side_right:      C_i := alpha*B_i*op( A_i )\n\n@param[in]\nuplo    [rocblas_fill]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\nSpecifies the form of op(A_i) to be used in the matrix multiplication as follows:\n- rocblas_operation_none:    op(A_i) = A_i\n- rocblas_operation_transpose:      op(A_i) = A_i^T\n- rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H\n\n@param[in]\ndiag    [rocblas_diagonal]\nSpecifies whether or not A_i is unit triangular as follows:\n- rocblas_diagonal_unit:      A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i is not referenced and B_i need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  side == rocblas_side_left  and\nis  n  when  side == rocblas_side_right.\n\nWhen uplo == rocblas_fill_upper the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == rocblas_fill_lower the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == rocblas_diagonal_unit  the diagonal elements of\nA_i  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side == rocblas_side_left,  lda >= max( 1, m ),\nif side == rocblas_side_right, lda >= max( 1, n ).\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nB       Device pointer to the first matrix B_0 on the GPU.\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1).\n\n@param[out]\nC      Device pointer to the first matrix C_0 on the GPU.\n\n@param[in]\nldc   [rocblas_int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m).\nIf B and C pointers are to the same matrix then ldc must equal ldb or\nrocblas_status_invalid_size will be returned.\n\n@param[in]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\nIf B == C and ldb == ldc then stride_C should equal stride_B or\nbehavior is undefined.\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances i in the batch."]
    pub fn rocblas_strmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f32,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const f64,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrtri  compute the inverse of a matrix A, namely, invA\nand write the result into invA;\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n\nif rocblas_fill_upper, the lower part of A is not referenced\nif rocblas_fill_lower, the upper part of A is not referenced\n@param[in]\ndiag      [rocblas_diagonal]\n- 'rocblas_diagonal_non_unit', A is non-unit triangular;\n- 'rocblas_diagonal_unit', A is unit triangular;\n@param[in]\nn         [rocblas_int]\nsize of matrix A and invA.\n@param[in]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[out]\ninvA      device pointer storing matrix invA.\nPartial inplace operation is supported. See below:\n-If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA may be cleared.\n- If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA may be cleared.\n@param[in]\nldinvA    [rocblas_int]\nspecifies the leading dimension of invA."]
    pub fn rocblas_strtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        invA: *mut f32,
        ldinvA: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        invA: *mut f64,
        ldinvA: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        invA: *mut rocblas_float_complex,
        ldinvA: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        invA: *mut rocblas_double_complex,
        ldinvA: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrtri_batched  compute the inverse of A_i and write into invA_i where\nA_i and invA_i are the i-th matrices in the batch,\nfor i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n@param[in]\ndiag      [rocblas_diagonal]\n- 'rocblas_diagonal_non_unit', A is non-unit triangular;\n- 'rocblas_diagonal_unit', A is unit triangular;\n@param[in]\nn         [rocblas_int]\n@param[in]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[out]\ninvA      device array of device pointers storing the inverse of each matrix A_i.\nPartial inplace operation is supported. See below:\n-If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA may be cleared.\n- If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA may be cleared.\n@param[in]\nldinvA    [rocblas_int]\nspecifies the leading dimension of each invA_i.\n@param[in]\nbatch_count [rocblas_int]\nnumbers of matrices in the batch."]
    pub fn rocblas_strtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f32,
        lda: rocblas_int,
        invA: *const *mut f32,
        ldinvA: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const f64,
        lda: rocblas_int,
        invA: *const *mut f64,
        ldinvA: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        invA: *const *mut rocblas_float_complex,
        ldinvA: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        invA: *const *mut rocblas_double_complex,
        ldinvA: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrtri_strided_batched compute the inverse of A_i and write into invA_i where\nA_i and invA_i are the i-th matrices in the batch,\nfor i = 1, ..., batch_count.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo      [rocblas_fill]\nspecifies whether the upper 'rocblas_fill_upper' or lower 'rocblas_fill_lower'\n@param[in]\ndiag      [rocblas_diagonal]\n- 'rocblas_diagonal_non_unit', A is non-unit triangular;\n- 'rocblas_diagonal_unit', A is unit triangular;\n@param[in]\nn         [rocblas_int]\n@param[in]\nA         device pointer pointing to address of first matrix A_1.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A.\n@param[in]\nstride_a  [rocblas_stride]\n\"batch stride a\": stride from the start of one A_i matrix to the next A_(i + 1).\n@param[out]\ninvA      device pointer storing the inverses of each matrix A_i.\nPartial inplace operation is supported. See below:\n\n- If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA may be cleared.\n\n- If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA may be cleared.\n@param[in]\nldinvA    [rocblas_int]\nspecifies the leading dimension of each invA_i.\n@param[in]\nstride_invA  [rocblas_stride]\n\"batch stride invA\": stride from the start of one invA_i matrix to the next invA_(i + 1).\n@param[in]\nbatch_count  [rocblas_int]\nnumbers of matrices in the batch."]
    pub fn rocblas_strtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        invA: *mut f32,
        ldinvA: rocblas_int,
        stride_invA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        invA: *mut f64,
        ldinvA: rocblas_int,
        stride_invA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        invA: *mut rocblas_float_complex,
        ldinvA: rocblas_int,
        stride_invA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        invA: *mut rocblas_double_complex,
        ldinvA: rocblas_int,
        stride_invA: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrsm solves:\n\nop(A)*X = alpha*B or  X*op(A) = alpha*B,\n\nwhere alpha is a scalar, X and B are m by n matrices,\n\nA is triangular matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nThe matrix X is overwritten on B.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time\n(where k is m when rocblas_side_left and is n when rocblas_side_right).\n\nAlthough not widespread, some gemm kernels used by trsm may use atomic operations.\nSee Atomic Operations in the API Reference Guide for more information.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\n- rocblas_side_left:       op(A)*X = alpha*B\n- rocblas_side_right:      X*op(A) = alpha*B\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- transB:    op(A) = A.\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n\n@param[in]\nA       device pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen  rocblas_side_left  and\nis  n  when  rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\nif side = rocblas_side_right, lda >= max( 1, n ).\n\n@param[in,out]\nB       device pointer storing matrix B.\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n"]
    pub fn rocblas_strsm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsm(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strsm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *mut f32,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *mut f64,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *mut rocblas_float_complex,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *mut rocblas_double_complex,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrsm_batched performs the following batched operation:\n\nop(A_i)*X_i = alpha*B_i or\nX_i*op(A_i) = alpha*B_i, for i = 1, ..., batch_count,\n\nwhere alpha is a scalar, X and B are batched m by n matrices,\n\nA is triangular batched matrix and op(A) is one of\n\nop( A ) = A   or\nop( A ) = A^T   or\nop( A ) = A^H.\n\nEach matrix X_i is overwritten on B_i for i = 1, ..., batch_count.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time\n(where k is m when rocblas_side_left and is n when rocblas_side_right).\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nside    [rocblas_side]\n- rocblas_side_left:       op(A)*X = alpha*B\n- rocblas_side_right:      X*op(A) = alpha*B\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  each A_i is an upper triangular matrix.\n- rocblas_fill_lower:  each A_i is a  lower triangular matrix.\n@param[in]\ntransA  [rocblas_operation]\n- transB:    op(A) = A\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of each B_i. m >= 0.\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of each B_i. n >= 0.\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n@param[in]\nA       device array of device pointers storing each matrix A_i on the GPU.\nMatricies are of dimension ( lda, k ), where k is m\nwhen  rocblas_side_left  and is  n  when  rocblas_side_right\nonly the upper/lower triangular part is accessed.\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of each A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\nif side = rocblas_side_right, lda >= max( 1, n ).\n@param[in,out]\nB       device array of device pointers storing each matrix B_i on the GPU.\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n@param[in]\nbatch_count [rocblas_int]\nnumber of trsm operatons in the batch."]
    pub fn rocblas_strsm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strsm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *mut f32,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *mut f64,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *mut rocblas_float_complex,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *mut rocblas_double_complex,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ntrsm_srided_batched performs the following strided batched operation:\n\nop(A_i)*X_i = alpha*B_i or\nX_i*op(A_i) = alpha*B_i, for i = 1, ..., batch_count,\n\nwhere alpha is a scalar, X and B are strided batched m by n matrices,\n\nA is triangular strided batched matrix and op(A) is one of\n\nop( A ) = A   or\nop( A ) = A^T   or\nop( A ) = A^H.\n\nEach matrix X_i is overwritten on B_i for i = 1, ..., batch_count.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time\n(where k is m when rocblas_side_left and is n when rocblas_side_right).\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nside    [rocblas_side]\n- rocblas_side_left:       op(A)*X = alpha*B.\n- rocblas_side_right:      X*op(A) = alpha*B.\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  each A_i is an upper triangular matrix.\n- rocblas_fill_lower:  each A_i is a  lower triangular matrix.\n@param[in]\ntransA  [rocblas_operation]\n- transB:    op(A) = A.\n- rocblas_operation_transpose:      op(A) = A^T.\n- rocblas_operation_conjugate_transpose:  op(A) = A^H.\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of each B_i. m >= 0.\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of each B_i. n >= 0.\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n@param[in]\nA       device pointer pointing to the first matrix A_1.\nof dimension ( lda, k ), where k is m\nwhen  rocblas_side_left  and\nis  n  when  rocblas_side_right\nonly the upper/lower triangular part is accessed.\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of each A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ).\nif side = rocblas_side_right, lda >= max( 1, n ).\n@param[in]\nstride_a [rocblas_stride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in,out]\nB       device pointer pointing to the first matrix B_1.\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n@param[in]\nstride_b [rocblas_stride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of trsm operatons in the batch."]
    pub fn rocblas_strsm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_strsm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_a: rocblas_stride,
        B: *mut f32,
        ldb: i64,
        stride_b: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dtrsm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_a: rocblas_stride,
        B: *mut f64,
        ldb: i64,
        stride_b: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ctrsm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_a: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: i64,
        stride_b: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ztrsm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_a: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: i64,
        stride_b: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemm_kernel_name functions were never fully implemented and are deprecated for removal in a future release.\n\nReturns rocblas_status_not_implemented."]
    pub fn rocblas_hgemm_kernel_name(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_half,
        A: *const rocblas_half,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const rocblas_half,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const rocblas_half,
        C: *mut rocblas_half,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemm_kernel_name(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm_kernel_name(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemm performs one of the matrix-matrix operations:\n\nC = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.\n\nAlthough not widespread, some gemm kernels may use atomic operations. See Atomic Operations\nin the API Reference Guide for more information.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nnumber or rows of matrices op( A ) and C.\n@param[in]\nn         [rocblas_int]\nnumber of columns of matrices op( B ) and C.\n@param[in]\nk         [rocblas_int]\nnumber of columns of matrix op( A ) and number of rows of matrix op( B ).\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nB         device pointer storing matrix B.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nC         device pointer storing matrix C on the GPU.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n"]
    pub fn rocblas_sgemm(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hgemm(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_half,
        A: *const rocblas_half,
        lda: rocblas_int,
        B: *const rocblas_half,
        ldb: rocblas_int,
        beta: *const rocblas_half,
        C: *mut rocblas_half,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemm(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemm(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemm_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hgemm_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_half,
        A: *const rocblas_half,
        lda: i64,
        B: *const rocblas_half,
        ldb: i64,
        beta: *const rocblas_half,
        C: *mut rocblas_half,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemm_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemm_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemm_batched performs one of the batched matrix-matrix operations:\n\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are strided batched matrices, with\n\nop( A ) an m by k by batch_count matrices,\nop( B ) an k by n by batch_count matrices and\nC an m by n by batch_count matrices.\n\n@param[in]\nhandle    [rocblas_handle\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimention m.\n@param[in]\nn         [rocblas_int]\nmatrix dimention n.\n@param[in]\nk         [rocblas_int]\nmatrix dimention k.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nB         device array of device pointers storing each matrix B_i.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of each B_i.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nC         device array of device pointers storing each matrix C_i.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of each C_i.\n@param[in]\nbatch_count\n[rocblas_int]\nnumber of gemm operations in the batch."]
    pub fn rocblas_sgemm_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hgemm_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_half,
        A: *const *const rocblas_half,
        lda: rocblas_int,
        B: *const *const rocblas_half,
        ldb: rocblas_int,
        beta: *const rocblas_half,
        C: *const *mut rocblas_half,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemm_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemm_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemm_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        beta: *const f32,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        beta: *const f64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hgemm_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_half,
        A: *const *const rocblas_half,
        lda: i64,
        B: *const *const rocblas_half,
        ldb: i64,
        beta: *const rocblas_half,
        C: *const *mut rocblas_half,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemm_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemm_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemm_strided_batched performs one of the strided batched matrix-matrix operations:\n\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are strided batched matrices, with\nop( A ) an m by k by batch_count strided_batched matrix,\nop( B ) an k by n by batch_count strided_batched matrix and\nC an m by n by batch_count strided_batched matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimention m.\n@param[in]\nn         [rocblas_int]\nmatrix dimention n.\n@param[in]\nk         [rocblas_int]\nmatrix dimention k.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device pointer pointing to the first matrix A_1.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstride_a  [rocblas_stride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in]\nB         device pointer pointing to the first matrix B_1.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of each B_i.\n@param[in]\nstride_b  [rocblas_stride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nC         device pointer pointing to the first matrix C_1.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of each C_i.\n@param[in]\nstride_c  [rocblas_stride]\nstride from the start of one C_i matrix to the next C_(i + 1).\n@param[in]\nbatch_count\n[rocblas_int]\nnumber of gemm operatons in the batch.\n"]
    pub fn rocblas_sgemm_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hgemm_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_half,
        A: *const rocblas_half,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const rocblas_half,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const rocblas_half,
        C: *mut rocblas_half,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemm_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemm_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemm_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const f32,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemm_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const f64,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_hgemm_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_half,
        A: *const rocblas_half,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const rocblas_half,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const rocblas_half,
        C: *mut rocblas_half,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemm_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemm_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ndgmm performs one of the matrix-matrix operations:\n\nC = A * diag(x) if side == rocblas_side_right\nC = diag(x) * A if side == rocblas_side_left\n\nwhere C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix\nand x is vector of dimension n if side == rocblas_side_right and dimension m\nif side == rocblas_side_left.\n\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nside      [rocblas_side]\nspecifies the side of diag(x).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment between values of x\n@param[in, out]\nC         device pointer storing matrix C.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n"]
    pub fn rocblas_sdgmm(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        x: *const f32,
        incx: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddgmm(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        x: *const f64,
        incx: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdgmm(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdgmm(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sdgmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddgmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdgmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        x: *const rocblas_float_complex,
        incx: i64,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdgmm_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        x: *const rocblas_double_complex,
        incx: i64,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ndgmm_batched performs one of the batched matrix-matrix operations:\n\nC_i = A_i * diag(x_i) for i = 0, 1, ... batch_count-1 if side == rocblas_side_right\nC_i = diag(x_i) * A_i for i = 0, 1, ... batch_count-1 if side == rocblas_side_left,\n\nwhere C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix\nand x_i is vector of dimension n if side == rocblas_side_right and dimension m\nif side == rocblas_side_left.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nside      [rocblas_side]\nspecifies the side of diag(x).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nA         device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, n ).\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A_i.\n@param[in]\nx         device array of device pointers storing each vector x_i on the GPU.\nEach x_i is of dimension n if side == rocblas_side_right and dimension\nm if side == rocblas_side_left.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment between values of x_i.\n@param[in, out]\nC         device array of device pointers storing each matrix C_i on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n"]
    pub fn rocblas_sdgmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *const f32,
        lda: rocblas_int,
        x: *const *const f32,
        incx: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddgmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *const f64,
        lda: rocblas_int,
        x: *const *const f64,
        incx: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdgmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        x: *const *const rocblas_float_complex,
        incx: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdgmm_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        x: *const *const rocblas_double_complex,
        incx: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sdgmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddgmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdgmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const *const rocblas_float_complex,
        lda: i64,
        x: *const *const rocblas_float_complex,
        incx: i64,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdgmm_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const *const rocblas_double_complex,
        lda: i64,
        x: *const *const rocblas_double_complex,
        incx: i64,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ndgmm_strided_batched performs one of the batched matrix-matrix operations:\n\nC_i = A_i * diag(x_i)   if side == rocblas_side_right   for i = 0, 1, ... batch_count-1\nC_i = diag(x_i) * A_i   if side == rocblas_side_left    for i = 0, 1, ... batch_count-1,\n\nwhere C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix\nand x_i is vector of dimension n if side == rocblas_side_right and dimension m\nif side == rocblas_side_left.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nside      [rocblas_side]\nspecifies the side of diag(x).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nA         device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, n ).\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n@param[in]\nx         pointer to the first vector x_0 on the GPU.\nEach x_i is of dimension n if side == rocblas_side_right and dimension\nm if side == rocblas_side_left.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment between values of x.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector(x_i) and the next one (x_i+1).\n@param[in, out]\nC         device pointer to the first matrix C_0 on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n@param[in]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances i in the batch.\n"]
    pub fn rocblas_sdgmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const f32,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddgmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const f64,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdgmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdgmm_strided_batched(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sdgmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const f32,
        incx: i64,
        stride_x: rocblas_stride,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_ddgmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const f64,
        incx: i64,
        stride_x: rocblas_stride,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cdgmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_float_complex,
        incx: i64,
        stride_x: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zdgmm_strided_batched_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        x: *const rocblas_double_complex,
        incx: i64,
        stride_x: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngeam performs one of the matrix-matrix operations:\n\nC = alpha*op( A ) + beta*op( B ),\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are matrices, with\nop( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device pointer storing matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in]\nB         device pointer storing matrix B.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B.\n@param[in, out]\nC         device pointer storing matrix C.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n"]
    pub fn rocblas_sgeam(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        beta: *const f32,
        B: *const f32,
        ldb: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgeam(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        beta: *const f64,
        B: *const f64,
        ldb: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeam(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        beta: *const rocblas_float_complex,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeam(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        beta: *const rocblas_double_complex,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgeam_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        beta: *const f32,
        B: *const f32,
        ldb: i64,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgeam_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        beta: *const f64,
        B: *const f64,
        ldb: i64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeam_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        beta: *const rocblas_float_complex,
        B: *const rocblas_float_complex,
        ldb: i64,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeam_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        beta: *const rocblas_double_complex,
        B: *const rocblas_double_complex,
        ldb: i64,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngeam_batched performs one of the batched matrix-matrix operations:\n\nC_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batch_count - 1,\n\nwhere alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices\nand op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  transA == rocblas_operation_none and\nis  n  when  transA == rocblas_operation_transpose.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in]\nB         device array of device pointers storing each matrix B_i on the GPU.\nEach B_i is of dimension ( ldb, k ), where k is m\nwhen  transB == rocblas_operation_none and\nis  n  when  transB == rocblas_operation_transpose.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B.\n@param[in, out]\nC         device array of device pointers storing each matrix C_i on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances i in the batch.\n"]
    pub fn rocblas_sgeam_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        beta: *const f32,
        B: *const *const f32,
        ldb: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgeam_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        beta: *const f64,
        B: *const *const f64,
        ldb: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeam_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        beta: *const rocblas_float_complex,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeam_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        beta: *const rocblas_double_complex,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgeam_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        beta: *const f32,
        B: *const *const f32,
        ldb: i64,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgeam_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        beta: *const f64,
        B: *const *const f64,
        ldb: i64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeam_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        beta: *const rocblas_float_complex,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeam_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        beta: *const rocblas_double_complex,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngeam_strided_batched performs one of the batched matrix-matrix operations:\n\nC_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batch_count - 1,\n\nwhere alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices\nand op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n\n@param[in]\nA         device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  transA == rocblas_operation_none and\nis  n  when  transA == rocblas_operation_transpose.\n\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n\n@param[in]\nstride_A  [rocblas_stride]\nstride from the start of one matrix (A_i) and the next one (A_i+1).\n\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n\n@param[in]\nB         pointer to the first matrix B_0 on the GPU.\nEach B_i is of dimension ( ldb, k ), where k is m\nwhen  transB == rocblas_operation_none and\nis  n  when  transB == rocblas_operation_transpose.\n\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B.\n\n@param[in]\nstride_B  [rocblas_stride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in, out]\nC         pointer to the first matrix C_0 on the GPU.\nEach C_i is of dimension ( ldc, n ).\n\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n\n@param[in]\nstride_C  [rocblas_stride]\nstride from the start of one matrix (C_i) and the next one (C_i+1).\n\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances i in the batch.\n"]
    pub fn rocblas_sgeam_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const f32,
        B: *const f32,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgeam_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const f64,
        B: *const f64,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeam_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const rocblas_float_complex,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeam_strided_batched(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        beta: *const rocblas_double_complex,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_C: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgeam_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const f32,
        B: *const f32,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut f32,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgeam_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const f64,
        B: *const f64,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut f64,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgeam_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const rocblas_float_complex,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgeam_strided_batched_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_A: rocblas_stride,
        beta: *const rocblas_double_complex,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_B: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_C: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ngemm_ex performs one of the matrix-matrix operations:\n\nD = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B, C, and D are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C and D are m by n matrices.\nC and D may point to the same matrix if their parameters are identical.\n\nSupported types are as follows:\n- rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =\ncompute_type\n- rocblas_datatype_f16_r = a_type = b_type; rocblas_datatype_f32_r = c_type = d_type =\ncompute_type\n- rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =\ncompute_type\n- rocblas_datatype_bf16_r = a_type = b_type; rocblas_datatype_f32_r = c_type = d_type =\ncompute_type\n- rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =\ncompute_type\n- rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type\n\nAlthough not widespread, some gemm kernels used by gemm_ex may use atomic operations.\nSee Atomic Operations in the API Reference Guide for more information.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nk         [rocblas_int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.\n@param[in]\na         [void *]\ndevice pointer storing matrix A.\n@param[in]\na_type    [rocblas_datatype]\nspecifies the datatype of matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A.\n@param[in]\nb         [void *]\ndevice pointer storing matrix B.\n@param[in]\nb_type    [rocblas_datatype]\nspecifies the datatype of matrix B.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B.\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as compute_type.\n@param[in]\nc         [void *]\ndevice pointer storing matrix C.\n@param[in]\nc_type    [rocblas_datatype]\nspecifies the datatype of matrix C.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C.\n@param[out]\nd         [void *]\ndevice pointer storing matrix D.\nIf d and c pointers are to the same matrix then d_type must equal c_type and ldd must equal ldc\nor the respective invalid status will be returned.\n@param[in]\nd_type    [rocblas_datatype]\nspecifies the datatype of matrix D.\n@param[in]\nldd       [rocblas_int]\nspecifies the leading dimension of D.\n@param[in]\ncompute_type\n[rocblas_datatype]\nspecifies the datatype of computation.\n@param[in]\nalgo      [rocblas_gemm_algo]\nenumerant specifying the algorithm type.\n@param[in]\nsolution_index\n[int32_t]\nif algo is rocblas_gemm_algo_solution_index, this controls which solution is used.\nWhen algo is not rocblas_gemm_algo_solution_index, or if solution_index <= 0, the default solution is used.\nThis parameter was unused in previous releases and instead always used the default solution\n@param[in]\nflags     [uint32_t]\noptional gemm flags.\n"]
    pub fn rocblas_gemm_ex(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        a: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: rocblas_int,
        b: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: rocblas_int,
        beta: *const ::std::os::raw::c_void,
        c: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: rocblas_int,
        d: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: rocblas_int,
        compute_type: rocblas_datatype,
        algo: rocblas_gemm_algo,
        solution_index: i32,
        flags: u32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_gemm_ex_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::std::os::raw::c_void,
        a: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: i64,
        b: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: i64,
        beta: *const ::std::os::raw::c_void,
        c: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: i64,
        d: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: i64,
        compute_type: rocblas_datatype,
        algo: rocblas_gemm_algo,
        solution_index: i32,
        flags: u32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ngemm_batched_ex performs one of the batched matrix-matrix operations:\nD_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batch_count.\nwhere op( X ) is one of\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\nalpha and beta are scalars, and A, B, C, and D are batched pointers to matrices, with\nop( A ) an m by k by batch_count batched matrix,\nop( B ) a k by n by batch_count batched matrix and\nC and D are m by n by batch_count batched matrices.\nThe batched matrices are an array of pointers to matrices.\nThe number of pointers to matrices is batch_count.\nC and D may point to the same matrices if their parameters are identical.\n\nSupported types are as follows:\n- rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =\ncompute_type\n- rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =\ncompute_type\n- rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =\ncompute_type\n- rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nk         [rocblas_int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.\n@param[in]\na         [void *]\ndevice pointer storing array of pointers to each matrix A_i.\n@param[in]\na_type    [rocblas_datatype]\nspecifies the datatype of each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nb         [void *]\ndevice pointer storing array of pointers to each matrix B_i.\n@param[in]\nb_type    [rocblas_datatype]\nspecifies the datatype of each matrix B_i.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of each B_i.\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as compute_type.\n@param[in]\nc         [void *]\ndevice array of device pointers to each matrix C_i.\n@param[in]\nc_type    [rocblas_datatype]\nspecifies the datatype of each matrix C_i.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of each C_i.\n@param[out]\nd         [void *]\ndevice array of device pointers to each matrix D_i.\nIf d and c are the same array of matrix pointers then d_type must equal c_type and ldd must equal ldc\nor the respective invalid status will be returned.\n@param[in]\nd_type    [rocblas_datatype]\nspecifies the datatype of each matrix D_i.\n@param[in]\nldd       [rocblas_int]\nspecifies the leading dimension of each D_i.\n@param[in]\nbatch_count\n[rocblas_int]\nnumber of gemm operations in the batch.\n@param[in]\ncompute_type\n[rocblas_datatype]\nspecifies the datatype of computation.\n@param[in]\nalgo      [rocblas_gemm_algo]\nenumerant specifying the algorithm type.\n@param[in]\nsolution_index\n[int32_t]\nif algo is rocblas_gemm_algo_solution_index, this controls which solution is used.\nWhen algo is not rocblas_gemm_algo_solution_index, or if solution_index <= 0, the default solution is used.\nThis parameter was unused in previous releases and instead always used the default solution\n@param[in]\nflags     [uint32_t]\noptional gemm flags.\n"]
    pub fn rocblas_gemm_batched_ex(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        a: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: rocblas_int,
        b: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: rocblas_int,
        beta: *const ::std::os::raw::c_void,
        c: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: rocblas_int,
        d: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: rocblas_int,
        batch_count: rocblas_int,
        compute_type: rocblas_datatype,
        algo: rocblas_gemm_algo,
        solution_index: i32,
        flags: u32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_gemm_batched_ex_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::std::os::raw::c_void,
        a: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: i64,
        b: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: i64,
        beta: *const ::std::os::raw::c_void,
        c: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: i64,
        d: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: i64,
        batch_count: i64,
        compute_type: rocblas_datatype,
        algo: rocblas_gemm_algo,
        solution_index: i32,
        flags: u32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ngemm_strided_batched_ex performs one of the strided_batched matrix-matrix operations:\n\nD_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batch_count\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B, C, and D are strided_batched matrices, with\nop( A ) an m by k by batch_count strided_batched matrix,\nop( B ) a k by n by batch_count strided_batched matrix and\nC and D are m by n by batch_count strided_batched matrices.\nC and D may point to the same matrices if their parameters are identical.\n\nThe strided_batched matrices are multiple matrices separated by a constant stride.\nThe number of matrices is batch_count.\n\nSupported types are as follows:\n- rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =\ncompute_type\n- rocblas_datatype_bf16_r = a_type = b_type = c_type = d_type; rocblas_datatype_f32_r =\ncompute_type\n- rocblas_datatype_i8_r = a_type = b_type; rocblas_datatype_i32_r = c_type = d_type =\ncompute_type\n- rocblas_datatype_f32_c  = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f64_c  = a_type = b_type = c_type = d_type = compute_type\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nk         [rocblas_int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.\n@param[in]\na         [void *]\ndevice pointer pointing to first matrix A_1.\n@param[in]\na_type    [rocblas_datatype]\nspecifies the datatype of each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstride_a  [rocblas_stride]\nspecifies stride from start of one A_i matrix to the next A_(i + 1).\n@param[in]\nb         [void *]\ndevice pointer pointing to first matrix B_1.\n@param[in]\nb_type    [rocblas_datatype]\nspecifies the datatype of each matrix B_i.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of each B_i.\n@param[in]\nstride_b  [rocblas_stride]\nspecifies stride from start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as compute_type.\n@param[in]\nc         [void *]\ndevice pointer pointing to first matrix C_1.\n@param[in]\nc_type    [rocblas_datatype]\nspecifies the datatype of each matrix C_i.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of each C_i.\n@param[in]\nstride_c  [rocblas_stride]\nspecifies stride from start of one C_i matrix to the next C_(i + 1).\n@param[out]\nd         [void *]\ndevice pointer storing each matrix D_i.\nIf d and c pointers are to the same matrix then d_type must equal c_type and ldd must equal ldc\nand stride_d must equal stride_c or the respective invalid status will be returned.\n@param[in]\nd_type    [rocblas_datatype]\nspecifies the datatype of each matrix D_i.\n@param[in]\nldd       [rocblas_int]\nspecifies the leading dimension of each D_i.\n@param[in]\nstride_d  [rocblas_stride]\nspecifies stride from start of one D_i matrix to the next D_(i + 1).\n@param[in]\nbatch_count\n[rocblas_int]\nnumber of gemm operations in the batch.\n@param[in]\ncompute_type\n[rocblas_datatype]\nspecifies the datatype of computation.\n@param[in]\nalgo      [rocblas_gemm_algo]\nenumerant specifying the algorithm type.\n@param[in]\nsolution_index\n[int32_t]\nif algo is rocblas_gemm_algo_solution_index, this controls which solution is used.\nWhen algo is not rocblas_gemm_algo_solution_index, or if solution_index <= 0, the default solution is used.\nThis parameter was unused in previous releases and instead always used the default solution\n@param[in]\nflags     [uint32_t]\noptional gemm flags.\n"]
    pub fn rocblas_gemm_strided_batched_ex(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        a: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        b: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const ::std::os::raw::c_void,
        c: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        d: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: rocblas_int,
        stride_d: rocblas_stride,
        batch_count: rocblas_int,
        compute_type: rocblas_datatype,
        algo: rocblas_gemm_algo,
        solution_index: i32,
        flags: u32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_gemm_strided_batched_ex_64(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::std::os::raw::c_void,
        a: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: i64,
        stride_a: rocblas_stride,
        b: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const ::std::os::raw::c_void,
        c: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: i64,
        stride_c: rocblas_stride,
        d: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: i64,
        stride_d: rocblas_stride,
        batch_count: i64,
        compute_type: rocblas_datatype,
        algo: rocblas_gemm_algo,
        solution_index: i32,
        flags: u32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemmt performs matrix-matrix operations and updates the upper or lower triangular part of the result matrix:\n\nC = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars. A, B  are general matrices and C is either an upper or lower triangular matrix, with\nop( A ) an n by k matrix, op( B ) a k by n matrix and C an n by n matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n@param[in]\ntransA    [rocblas_operation]\n- rocblas_operation_none:    op(A) = A.\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n@param[in]\ntransB    [rocblas_operation]\n- rocblas_operation_none:    op(B) = B.\n- rocblas_operation_transpose:      op(B) = B^T\n- rocblas_operation_conjugate_transpose:  op(B) = B^H\n@param[in]\nn         [rocblas_int]\nnumber or rows of matrices op( A ), columns of op( B ), and (rows, columns) of C.\n@param[in]\nk         [rocblas_int]\nnumber of rows of matrices op( B ) and columns of op( A ).\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device pointer storing matrix A. If transa = rocblas_operation_none, then, the leading n-by-k part of the array contains the matrix A, otherwise the leading k-by-n part of the array contains the matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A. If transA == rocblas_operation_none, must have lda >= max(1, n), otherwise, must have lda >= max(1, k).\n@param[in]\nB         device pointer storing matrix B. If transB = rocblas_operation_none, then, the leading k-by-n part of the array contains the matrix B, otherwise the leading n-by-k part of the array contains the matrix B.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B. If transB == rocblas_operation_none, must have ldb >= max(1, k), otherwise, must have ldb >= max(1, n)\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nC         device pointer storing matrix C on the GPU. If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains the matrix C, otherwise the lower triangular part of the leading n-by-n array contains the matrix C.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C. Must have ldc >= max(1, n).\n"]
    pub fn rocblas_sgemmt(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        B: *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemmt(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        B: *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemmt(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemmt(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemmt_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemmt_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemmt_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        B: *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemmt_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        B: *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemmt_batched performs matrix-matrix operations and updates the upper or lower triangular part of the result matrix:\n\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars. A, B  are general matrices and C is either an upper or lower triangular matrix, with\n\nop( A ) an n by k by batch_count matrices,\nop( B ) an k by n by batch_count matrices and\nC an n by n by batch_count matrices.\n\n@param[in]\nhandle    [rocblas_handle\nhandle to the rocblas library context queue.\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n@param[in]\ntransA    [rocblas_operation]\n- rocblas_operation_none:    op(A_i) = A_i.\n- rocblas_operation_transpose:      op(A_i) = A_i^T\n- rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H\n@param[in]\ntransB    [rocblas_operation]\n- rocblas_operation_none:    op(B_i) = B_i.\n- rocblas_operation_transpose:      op(B_i) = B_i^T\n- rocblas_operation_conjugate_transpose:  op(B_i) = B_i^H\n@param[in]\nn         [rocblas_int]\nnumber or rows of matrices op( A_i ), columns of op( B_i ), and (rows, columns) of C_i.\n@param[in]\nk         [rocblas_int]\nnumber of rows of matrices op( B_i ) and columns of op( A_i ).\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i. If transa = rocblas_operation_none, then, the leading n-by-k part of the array contains each matrix A_i, otherwise the leading k-by-n part of the array contains each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. If transA == rocblas_operation_none, must have lda >= max(1, n), otherwise, must have lda >= max(1, k).\n@param[in]\nB         device array of device pointers storing each matrix B_i. If transB = rocblas_operation_none, then, the leading k-by-n part of the array contains each matrix B_i, otherwise the leading n-by-k part of the array contains each matrix B_i.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of each B_i. If transB == rocblas_operation_none, must have ldb >= max(1, k), otherwise, must have ldb >= max(1, n).\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nC         device array of device pointers storing each matrix C_i. If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains each matrix C_i, otherwise the lower triangular part of the leading n-by-n array contains each matrix C_i.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of each C_i. Must have ldc >= max(1, n).\n@param[in]\nbatch_count\n[rocblas_int]\nnumber of gemm operations in the batch."]
    pub fn rocblas_sgemmt_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: rocblas_int,
        B: *const *const f32,
        ldb: rocblas_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemmt_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: rocblas_int,
        B: *const *const f64,
        ldb: rocblas_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemmt_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: rocblas_int,
        B: *const *const rocblas_float_complex,
        ldb: rocblas_int,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemmt_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: rocblas_int,
        B: *const *const rocblas_double_complex,
        ldb: rocblas_int,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemmt_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        beta: *const f32,
        C: *const *mut f32,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemmt_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        beta: *const f64,
        C: *const *mut f64,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemmt_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const *const rocblas_float_complex,
        lda: i64,
        B: *const *const rocblas_float_complex,
        ldb: i64,
        beta: *const rocblas_float_complex,
        C: *const *mut rocblas_float_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemmt_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const *const rocblas_double_complex,
        lda: i64,
        B: *const *const rocblas_double_complex,
        ldb: i64,
        beta: *const rocblas_double_complex,
        C: *const *mut rocblas_double_complex,
        ldc: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 3 API </b>\n\n\\details\ngemmt_strided_batched performs matrix-matrix operations and updates the upper or lower triangular part of the result matrix:\n\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batch_count,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars. A, B  are general matrices and C is either an upper or lower triangular matrix, with\nop( A ) an n by k by batch_count strided_batched matrix,\nop( B ) an k by n by batch_count strided_batched matrix and\nC an n by n by batch_count strided_batched matrix.\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  C is an upper triangular matrix\n- rocblas_fill_lower:  C is a  lower triangular matrix\n@param[in]\ntransA    [rocblas_operation]\n- rocblas_operation_none:    op(A_i) = A_i.\n- rocblas_operation_transpose:      op(A_i) = A_i^T\n- rocblas_operation_conjugate_transpose:  op(A_i) = A_i^H\n@param[in]\ntransB    [rocblas_operation]\n- rocblas_operation_none:    op(B_i) = B_i.\n- rocblas_operation_transpose:      op(B_i) = B_i^T\n- rocblas_operation_conjugate_transpose:  op(B_i) = B_i^H\n@param[in]\nn         [rocblas_int]\nnumber or rows of matrices op( A_i ), columns of op( B_i ), and (rows, columns) of C_i.\n@param[in]\nk         [rocblas_int]\nnumber of rows of matrices op( B_i ) and columns of op( A_i ).\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nA         device array of device pointers storing each matrix A_i. If transa = rocblas_operation_none, then, the leading n-by-k part of the array contains each matrix A_i, otherwise the leading k-by-n part of the array contains each matrix A_i.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of each A_i. If transA == rocblas_operation_none, must have lda >= max(1, n), otherwise, must have lda >= max(1, k).\n@param[in]\nstride_a  [rocblas_stride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in]\nB         device array of device pointers storing each matrix B_i. If transB = rocblas_operation_none, then, the leading k-by-n part of the array contains each matrix B_i, otherwise the leading n-by-k part of the array contains each matrix B_i.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of each B_i. If transB == rocblas_operation_none, must have ldb >= max(1, k), otherwise, must have ldb >= max(1, n).\n@param[in]\nstride_b  [rocblas_stride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nC         device array of device pointers storing each matrix C_i. If uplo == rocblas_fill_upper, the upper triangular part of the leading n-by-n array contains each matrix C_i, otherwise the lower triangular part of the leading n-by-n array contains each matrix C_i.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of each C_i. Must have ldc >= max(1, n).\n@param[in]\nstride_c  [rocblas_stride]\nstride from the start of one C_i matrix to the next C_(i + 1).\n@param[in]\nbatch_count\n[rocblas_int]\nnumber of gemm operatons in the batch.\n"]
    pub fn rocblas_sgemmt_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const f32,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemmt_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const f64,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemmt_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemmt_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: rocblas_int,
        stride_a: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: rocblas_int,
        stride_b: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        stride_c: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_sgemmt_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const f32,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const f32,
        C: *mut f32,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dgemmt_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const f64,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const f64,
        C: *mut f64,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_cgemmt_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_float_complex,
        A: *const rocblas_float_complex,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const rocblas_float_complex,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_zgemmt_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        transB: rocblas_operation,
        n: i64,
        k: i64,
        alpha: *const rocblas_double_complex,
        A: *const rocblas_double_complex,
        lda: i64,
        stride_a: rocblas_stride,
        B: *const rocblas_double_complex,
        ldb: i64,
        stride_b: rocblas_stride,
        beta: *const rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: i64,
        stride_c: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ngeam_ex performs one of the matrix-matrix operations:\n\nDij = min(alpha * (Aik + Bkj), beta * Cij)\nDij = min(alpha * Aik, alpha * Bkj) + beta * Cij\n\nalpha and beta are scalars, and A, B, C, and D are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C and D are m by n matrices.\nC and D may point to the same matrix if their type and leading dimensions are identical.\n\nAik refers to the element at the i-th row and k-th column of op( A ), Bkj refers to\nthe element at the k-th row and j-th column of op( B ), and Cij/Dij refers to the element\nat the i-th row and j-th column of C/D.\n\nSupported types are as follows:\n- rocblas_datatype_f64_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f32_r = a_type = b_type = c_type = d_type = compute_type\n- rocblas_datatype_f16_r = a_type = b_type = c_type = d_type = compute_type\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\ntransA    [rocblas_operation]\nspecifies the form of op( A ).\n@param[in]\ntransB    [rocblas_operation]\nspecifies the form of op( B ).\n@param[in]\nm         [rocblas_int]\nmatrix dimension m.\n@param[in]\nn         [rocblas_int]\nmatrix dimension n.\n@param[in]\nk         [rocblas_int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as compute_type.\n@param[in]\nA         [void *]\ndevice pointer storing matrix A.\n@param[in]\na_type    [rocblas_datatype]\nspecifies the datatype of matrix A.\n@param[in]\nlda       [rocblas_int]\nspecifies the leading dimension of A\n\nif transA == N, must have lda >= max(1, m)\notherwise, must have lda >= max(1, k)\n@param[in]\nB         [void *]\ndevice pointer storing matrix B.\n@param[in]\nb_type    [rocblas_datatype]\nspecifies the datatype of matrix B.\n@param[in]\nldb       [rocblas_int]\nspecifies the leading dimension of B\n\nif transB == N, must have ldb >= max(1, k)\notherwise, must have ldb >= max(1, n)\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as compute_type.\n@param[in]\nC         [void *]\ndevice pointer storing matrix C.\n@param[in]\nc_type    [rocblas_datatype]\nspecifies the datatype of matrix C.\n@param[in]\nldc       [rocblas_int]\nspecifies the leading dimension of C, must have ldc >= max(1, m).\n@param[out]\nD         [void *]\ndevice pointer storing matrix D.\nIf D and C pointers are to the same matrix then d_type must equal c_type and ldd must equal ldc\nor the respective invalid status will be returned.\n@param[in]\nd_type    [rocblas_datatype]\nspecifies the datatype of matrix D.\n@param[in]\nldd       [rocblas_int]\nspecifies the leading dimension of D, must have ldd >= max(1, m).\n@param[in]\ncompute_type\n[rocblas_datatype]\nspecifies the datatype of computation.\n@param[in]\ngeam_ex_op [rocblas_geam_ex_operation]\nenumerant specifying the operation type, support for rocblas_geam_ex_operation_min_plus and rocblas_geam_ex_operation_plus_min.\n"]
    pub fn rocblas_geam_ex(
        handle: rocblas_handle,
        transA: rocblas_operation,
        transB: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        a_type: rocblas_datatype,
        lda: rocblas_int,
        B: *const ::std::os::raw::c_void,
        b_type: rocblas_datatype,
        ldb: rocblas_int,
        beta: *const ::std::os::raw::c_void,
        C: *const ::std::os::raw::c_void,
        c_type: rocblas_datatype,
        ldc: rocblas_int,
        D: *mut ::std::os::raw::c_void,
        d_type: rocblas_datatype,
        ldd: rocblas_int,
        compute_type: rocblas_datatype,
        geam_ex_op: rocblas_geam_ex_operation,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ntrsm_ex solves:\n\nop(A)*X = alpha*B or X*op(A) = alpha*B,\n\nwhere alpha is a scalar, X and B are m by n matrices,\nA is triangular matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nThe matrix X is overwritten on B.\n\nThis function gives the user the ability to reuse the invA matrix between runs.\nIf invA == NULL, rocblas_trsm_ex will automatically calculate invA on every run.\n\nSetting up invA:\nThe accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A, followed by any smaller diagonal block that remains.\nTo set up invA it is recommended that rocblas_trtri_batched be used with matrix A as the input.\n\nDevice memory of size 128 x k should be allocated for invA ahead of time, where k is m when\nrocblas_side_left and is n when rocblas_side_right. The actual number of elements in invA\nshould be passed as invA_size.\n\nTo begin, rocblas_trtri_batched must be called on the full 128x128-sized diagonal blocks of\nmatrix A. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batch_count = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previous_batch_count\n- ldinvA = 128\n- batch_count = 1\n\nAlthough not widespread, some gemm kernels used by trsm_ex may use atomic operations.\nSee Atomic Operations in the API Reference Guide for more information.\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\n- rocblas_side_left:       op(A)*X = alpha*B\n- rocblas_side_right:      X*op(A) = alpha*B\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  A is an upper triangular matrix.\n- rocblas_fill_lower:  A is a lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- transB:    op(A) = A.\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     A is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen rocblas_side_left and\nis n when rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\nif side = rocblas_side_right, lda >= max( 1, n ).\n\n@param[in, out]\nB       [void *]\ndevice pointer storing matrix B.\nB is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of the array B must\ncontain the right-hand side matrix B, and on exit is\noverwritten by the solution matrix X.\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\ninvA    [void *]\ndevice pointer storing the inverse diagonal blocks of A.\ninvA is of dimension ( ld_invA, k ), where k is m\nwhen rocblas_side_left and\nis n when rocblas_side_right.\nld_invA must be equal to 128.\n\n@param[in]\ninvA_size [rocblas_int]\ninvA_size specifies the number of elements of device memory in invA.\n\n@param[in]\ncompute_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_trsm_ex(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        B: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
        invA: *const ::std::os::raw::c_void,
        invA_size: rocblas_int,
        compute_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ntrsm_batched_ex solves:\n\nop(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,\n\nfor i = 1, ..., batch_count; and where alpha is a scalar, X and B are arrays of m by n matrices,\nA is an array of triangular matrix and each op(A_i) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nEach matrix X_i is overwritten on B_i.\n\nThis function gives the user the ability to reuse the invA matrix between runs.\nIf invA == NULL, rocblas_trsm_batched_ex will automatically calculate each invA_i on every run.\n\nSetting up invA:\nEach accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A_i, followed by any smaller diagonal block that remains.\nTo set up each invA_i it is recommended that rocblas_trtri_batched be used with matrix A_i as the input.\ninvA is an array of pointers of batch_count length holding each invA_i.\n\nDevice memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when\nrocblas_side_left and is n when rocblas_side_right. The actual number of elements in each invA_i\nshould be passed as invA_size.\n\nTo begin, rocblas_trtri_batched must be called on the full 128x128-sized diagonal blocks of each\nmatrix A_i. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batch_count = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previous_batch_count\n- ldinvA = 128\n- batch_count = 1\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\n- rocblas_side_left:       op(A)*X = alpha*B\n- rocblas_side_right:      X*op(A) = alpha*B\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  each A_i is an upper triangular matrix.\n- rocblas_fill_lower:  each A_i is a lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- transB:    op(A) = A.\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of each B_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of each B_i. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer alpha specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice array of device pointers storing each matrix A_i.\neach A_i is of dimension ( lda, k ), where k is m\nwhen rocblas_side_left and\nis n when rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of each A_i.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\nif side = rocblas_side_right, lda >= max( 1, n ).\n\n@param[in, out]\nB       [void *]\ndevice array of device pointers storing each matrix B_i.\neach B_i is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of the array B_i must\ncontain the right-hand side matrix B_i, and on exit is\noverwritten by the solution matrix X_i\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n\n@param[in]\nbatch_count [rocblas_int]\nspecifies how many batches.\n\n@param[in]\ninvA    [void *]\ndevice array of device pointers storing the inverse diagonal blocks of each A_i.\neach invA_i is of dimension ( ld_invA, k ), where k is m\nwhen rocblas_side_left and\nis n when rocblas_side_right.\nld_invA must be equal to 128.\n\n@param[in]\ninvA_size [rocblas_int]\ninvA_size specifies the number of elements of device memory in each invA_i.\n\n@param[in]\ncompute_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_trsm_batched_ex(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        B: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
        batch_count: rocblas_int,
        invA: *const ::std::os::raw::c_void,
        invA_size: rocblas_int,
        compute_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ntrsm_strided_batched_ex solves:\n\nop(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,\n\nfor i = 1, ..., batch_count; and where alpha is a scalar, X and B are strided batched m by n matrices,\nA is a strided batched triangular matrix and op(A_i) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nEach matrix X_i is overwritten on B_i.\n\nThis function gives the user the ability to reuse each invA_i matrix between runs.\nIf invA == NULL, rocblas_trsm_batched_ex will automatically calculate each invA_i on every run.\n\nSetting up invA:\nEach accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A_i, followed by any smaller diagonal block that remains.\nTo set up invA_i it is recommended that rocblas_trtri_batched be used with matrix A_i as the input.\ninvA is a contiguous piece of memory holding each invA_i.\n\nDevice memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when\nrocblas_side_left and is n when rocblas_side_right. The actual number of elements in each invA_i\nshould be passed as invA_size.\n\nTo begin, rocblas_trtri_batched must be called on the full 128x128-sized diagonal blocks of each\nmatrix A_i. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batch_count = k / 128\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previous_batch_count\n- ldinvA = 128\n- batch_count = 1\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n\n@param[in]\nside    [rocblas_side]\n- rocblas_side_left:       op(A)*X = alpha*B\n- rocblas_side_right:      X*op(A) = alpha*B\n\n@param[in]\nuplo    [rocblas_fill]\n- rocblas_fill_upper:  each A_i is an upper triangular matrix.\n- rocblas_fill_lower:  each A_i is a lower triangular matrix.\n\n@param[in]\ntransA  [rocblas_operation]\n- transB:    op(A) = A.\n- rocblas_operation_transpose:      op(A) = A^T\n- rocblas_operation_conjugate_transpose:  op(A) = A^H\n\n@param[in]\ndiag    [rocblas_diagonal]\n- rocblas_diagonal_unit:     each A_i is assumed to be unit triangular.\n- rocblas_diagonal_non_unit:  each A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [rocblas_int]\nm specifies the number of rows of each B_i. m >= 0.\n\n@param[in]\nn       [rocblas_int]\nn specifies the number of columns of each B_i. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen rocblas_side_left and\nis n when rocblas_side_right\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [rocblas_int]\nlda specifies the first dimension of A.\n\nif side = rocblas_side_left,  lda >= max( 1, m ),\nif side = rocblas_side_right, lda >= max( 1, n ).\n\n@param[in]\nstride_A [rocblas_stride]\nThe stride between each A matrix.\n\n@param[in, out]\nB       [void *]\ndevice pointer pointing to first matrix B_i.\neach B_i is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of each array B_i must\ncontain the right-hand side of matrix B_i, and on exit is\noverwritten by the solution matrix X_i.\n\n@param[in]\nldb    [rocblas_int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n\n@param[in]\nstride_B [rocblas_stride]\nThe stride between each B_i matrix.\n\n@param[in]\nbatch_count [rocblas_int]\nspecifies how many batches.\n\n@param[in]\ninvA    [void *]\ndevice pointer storing the inverse diagonal blocks of each A_i.\ninvA points to the first invA_1.\neach invA_i is of dimension ( ld_invA, k ), where k is m\nwhen rocblas_side_left and\nis n when rocblas_side_right.\nld_invA must be equal to 128.\n\n@param[in]\ninvA_size [rocblas_int]\ninvA_size specifies the number of elements of device memory in each invA_i.\n\n@param[in]\nstride_invA [rocblas_stride]\nThe stride between each invA matrix.\n\n@param[in]\ncompute_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_trsm_strided_batched_ex(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        transA: rocblas_operation,
        diag: rocblas_diagonal,
        m: rocblas_int,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        A: *const ::std::os::raw::c_void,
        lda: rocblas_int,
        stride_A: rocblas_stride,
        B: *mut ::std::os::raw::c_void,
        ldb: rocblas_int,
        stride_B: rocblas_stride,
        batch_count: rocblas_int,
        invA: *const ::std::os::raw::c_void,
        invA_size: rocblas_int,
        stride_invA: rocblas_stride,
        compute_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\naxpy_ex   computes constant alpha multiplied by vector x, plus vector y.\n\ny := alpha * x + y\n\nCurrently supported datatypes are as follows:\n\n-------------------------------------------------\n| alpha_type | x_type | y_type | execution_type |\n|------------|--------|--------|----------------|\n|  bf16_r    | bf16_r |  bf16_r|      f32_r     |\n|  f32_r     | bf16_r |  bf16_r|      f32_r     |\n|  f16_r     | f16_r  |  f16_r |      f16_r     |\n|  f16_r     | f16_r  |  f16_r |      f32_r     |\n|  f32_r     | f16_r  |  f16_r |      f32_r     |\n|  f32_r     | f32_r  |  f32_r |      f32_r     |\n|  f64_r     | f64_r  |  f64_r |      f64_r     |\n|  f32_c     | f32_c  |  f32_c |      f32_c     |\n|  f64_c     | f64_c  |  f64_c |      f64_c     |\n-------------------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x and y.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalpha_type [rocblas_datatype]\nspecifies the datatype of alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in, out]\ny         device pointer storing vector y.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_axpy_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_axpy_ex_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\naxpy_batched_ex   computes constant alpha multiplied by vector x, plus vector y over\na set of batched vectors.\n\ny := alpha * x + y\n\nCurrently supported datatypes are as follows:\n\n-------------------------------------------------\n| alpha_type | x_type | y_type | execution_type |\n|------------|--------|--------|----------------|\n|  bf16_r    | bf16_r |  bf16_r|      f32_r     |\n|  f32_r     | bf16_r |  bf16_r|      f32_r     |\n|  f16_r     | f16_r  |  f16_r |      f16_r     |\n|  f16_r     | f16_r  |  f16_r |      f32_r     |\n|  f32_r     | f16_r  |  f16_r |      f32_r     |\n|  f32_r     | f32_r  |  f32_r |      f32_r     |\n|  f64_r     | f64_r  |  f64_r |      f64_r     |\n|  f32_c     | f32_c  |  f32_c |      f32_c     |\n|  f64_c     | f64_c  |  f64_c |      f64_c     |\n-------------------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalpha_type [rocblas_datatype]\nspecifies the datatype of alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in, out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_axpy_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        batch_count: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_axpy_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        batch_count: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\naxpy_strided_batched_ex   computes constant alpha multiplied by vector x, plus vector y over\na set of strided batched vectors.\n\ny := alpha * x + y\n\nCurrently supported datatypes are as follows:\n\n-------------------------------------------------\n| alpha_type | x_type | y_type | execution_type |\n|------------|--------|--------|----------------|\n|  bf16_r    | bf16_r |  bf16_r|      f32_r     |\n|  f32_r     | bf16_r |  bf16_r|      f32_r     |\n|  f16_r     | f16_r  |  f16_r |      f16_r     |\n|  f16_r     | f16_r  |  f16_r |      f32_r     |\n|  f32_r     | f16_r  |  f16_r |      f32_r     |\n|  f32_r     | f32_r  |  f32_r |      f32_r     |\n|  f64_r     | f64_r  |  f64_r |      f64_r     |\n|  f32_c     | f32_c  |  f32_c |      f32_c     |\n|  f64_c     | f64_c  |  f64_c |      f64_c     |\n-------------------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalpha_type [rocblas_datatype]\nspecifies the datatype of alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [rocblas_stride]\nstride from the start of one vector (x_i) to the next one (x_i+1).\nThere are no restrictions placed on stridex. However, ensure that stridex is of appropriate size. For a typical\ncase this means stridex >= n * incx.\n@param[in, out]\ny         device pointer to the first vector y_1.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [rocblas_stride]\nstride from the start of one vector (y_i) to the next one (y_i+1).\nThere are no restrictions placed on stridey. However, ensure that stridey is of appropriate size. For a typical\ncase this means stridey >= n * incy.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_axpy_strided_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        stridex: rocblas_stride,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        stridey: rocblas_stride,
        batch_count: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_axpy_strided_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        stridex: rocblas_stride,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        stridey: rocblas_stride,
        batch_count: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ndot_ex  performs the dot product of vectors x and y.\n\nresult = x * y;\n\ndotc_ex  performs the dot product of the conjugate of complex vector x and complex vector y\n\nresult = conjugate (x) * y;\n\nCurrently supported datatypes are as follows:\n\n--------------------------------------------------\n| x_type | y_type | result_type | execution_type |\n|--------|--------|-------------|----------------|\n| f16_r  | f16_r  |    f16_r    |     f16_r      |\n| f16_r  | f16_r  |    f16_r    |     f32_r      |\n| bf16_r | bf16_r |    bf16_r   |     f32_r      |\n| f32_r  | f32_r  |    f32_r    |     f32_r      |\n| f32_r  | f32_r  |    f64_r    |     f64_r      |\n| f64_r  | f64_r  |    f64_r    |     f64_r      |\n| f32_c  | f32_c  |    f32_c    |     f32_c      |\n| f64_c  | f64_c  |    f64_c    |     f64_c      |\n--------------------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of vector y.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nresult\ndevice pointer or host pointer to store the dot product.\nreturn is 0.0 if n <= 0.\n@param[in]\nresult_type [rocblas_datatype]\nspecifies the datatype of the result.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_dot_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dotc_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dot_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dotc_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ndot_batched_ex performs a batch of dot products of vectors x and y.\n\nresult_i = x_i * y_i;\n\ndotc_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batch_count\n\nCurrently supported datatypes are as follows:\n\n--------------------------------------------------\n| x_type | y_type | result_type | execution_type |\n|--------|--------|-------------|----------------|\n| f16_r  | f16_r  |    f16_r    |     f16_r      |\n| f16_r  | f16_r  |    f16_r    |     f32_r      |\n| bf16_r | bf16_r |    bf16_r   |     f32_r      |\n| f32_r  | f32_r  |    f32_r    |     f32_r      |\n| f32_r  | f32_r  |    f64_r    |     f64_r      |\n| f64_r  | f64_r  |    f64_r    |     f64_r      |\n| f32_c  | f32_c  |    f32_c    |     f32_c      |\n| f64_c  | f64_c  |    f64_c    |     f64_c      |\n--------------------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in, out]\nresult\ndevice array or host array of batch_count size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n@param[in]\nresult_type [rocblas_datatype]\nspecifies the datatype of the result.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_dot_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dotc_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        batch_count: rocblas_int,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dot_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        batch_count: i64,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dotc_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        batch_count: i64,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\ndot_strided_batched_ex  performs a batch of dot products of vectors x and y.\n\nresult_i = x_i * y_i;\n\ndotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batch_count\n\nCurrently supported datatypes are as follows:\n\n--------------------------------------------------\n| x_type | y_type | result_type | execution_type |\n|--------|--------|-------------|----------------|\n| f16_r  | f16_r  |    f16_r    |     f16_r      |\n| f16_r  | f16_r  |    f16_r    |     f32_r      |\n| bf16_r | bf16_r |    bf16_r   |     f32_r      |\n| f32_r  | f32_r  |    f32_r    |     f32_r      |\n| f32_r  | f32_r  |    f64_r    |     f64_r      |\n| f64_r  | f64_r  |    f64_r    |     f64_r      |\n| f32_c  | f32_c  |    f32_c    |     f32_c      |\n| f64_c  | f64_c  |    f64_c    |     f64_c      |\n--------------------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstride_x    [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [rocblas_int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstride_y    [rocblas_stride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in, out]\nresult\ndevice array or host array of batch_count size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n@param[in]\nresult_type [rocblas_datatype]\nspecifies the datatype of the result.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_dot_strided_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dotc_strided_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        batch_count: rocblas_int,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dot_strided_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_dotc_strided_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        stride_x: rocblas_stride,
        y: *const ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        stride_y: rocblas_stride,
        batch_count: i64,
        result: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief BLAS_EX API\n\n\\details\nnrm2_ex computes the euclidean norm of a real or complex vector.\n\nresult := sqrt( x'*x ) for real vectors\nresult := sqrt( x**H*x ) for complex vectors\n\nCurrently supported datatypes are as follows:\n\n-------------------------------------\n|  x_type | result | execution_type |\n|---------|--------|----------------|\n|  bf16_r |  bf16_r|     f32_r      |\n|  f16_r  |  f16_r |     f32_r      |\n|  f32_r  |  f32_r |     f32_r      |\n|  f64_r  |  f64_r |     f64_r      |\n|  f32_c  |  f32_r |     f32_r      |\n|  f64_c  |  f64_r |     f64_r      |\n-------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of the vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of y.\n@param[in, out]\nresults\ndevice pointer or host pointer to store the nrm2 product.\nreturn is 0.0 if n, incx<=0.\n@param[in]\nresult_type [rocblas_datatype]\nspecifies the datatype of the result.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_nrm2_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        results: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_nrm2_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        results: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief BLAS_EX API\n\n\\details\nnrm2_batched_ex computes the euclidean norm over a batch of real or complex vectors.\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count\nresult := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batch_count\n\nCurrently supported datatypes are as follows:\n\n-------------------------------------\n|  x_type | result | execution_type |\n|---------|--------|----------------|\n|  bf16_r |  bf16_r|     f32_r      |\n|  f16_r  |  f16_r |     f32_r      |\n|  f32_r  |  f32_r |     f32_r      |\n|  f64_r  |  f64_r |     f64_r      |\n|  f32_c  |  f32_r |     f32_r      |\n|  f64_c  |  f64_r |     f64_r      |\n-------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresults\ndevice pointer or host pointer to array of batch_count size for nrm2 results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n@param[in]\nresult_type [rocblas_datatype]\nspecifies the datatype of the result.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_nrm2_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        batch_count: rocblas_int,
        results: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_nrm2_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        batch_count: i64,
        results: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief BLAS_EX API\n\n\\details\nnrm2_strided_batched_ex computes the euclidean norm over a batch of real or complex vectors.\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batch_count\nresult := sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batch_count\n\nCurrently supported datatypes are as follows:\n\n-------------------------------------\n|  x_type | result | execution_type |\n|---------|--------|----------------|\n|  bf16_r |  bf16_r|     f32_r      |\n|  f16_r  |  f16_r |     f32_r      |\n|  f32_r  |  f32_r |     f32_r      |\n|  f64_r  |  f64_r |     f64_r      |\n|  f32_c  |  f32_r |     f32_r      |\n|  f64_c  |  f64_r |     f64_r      |\n-------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nnumber of elements in each x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstride_x  [rocblas_stride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x. However, ensure that stride_x is of appropriate size. For a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[out]\nresults\ndevice pointer or host pointer to array for storing contiguous batch_count results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n@param[in]\nresult_type [rocblas_datatype]\nspecifies the datatype of the result.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_nrm2_strided_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        batch_count: rocblas_int,
        results: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_nrm2_strided_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *const ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        stride_x: rocblas_stride,
        batch_count: i64,
        results: *mut ::std::os::raw::c_void,
        result_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\nrot_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.\nScalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.\n\nIn the case where cs_type is real:\n\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\n\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\nCurrently supported datatypes are as follows:\n\n------------------------------------------------\n|  x_type | y_type  | cs_type | execution_type |\n|---------|---------|---------|----------------|\n|  bf16_r |  bf16_r | bf16_r  |  f32_r         |\n|  f16_r  |  f16_r  | f16_r   |  f32_r         |\n|  f32_r  |  f32_r  | f32_r   |  f32_r         |\n|  f64_r  |  f64_r  | f64_r   |  f64_r         |\n|  f32_c  |  f32_c  | f32_c   |  f32_c         |\n|  f32_c  |  f32_c  | f32_r   |  f32_c         |\n|  f64_c  |  f64_c  | f64_c   |  f64_c         |\n|  f64_c  |  f64_c  | f64_r   |  f64_c         |\n------------------------------------------------\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in the x and y vectors.\n@param[in, out]\nx       device pointer storing vector x.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of vector x.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of x.\n@param[in, out]\ny       device pointer storing vector y.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of vector y.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of y.\n@param[in]\nc       device pointer or host pointer storing scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer storing scalar sine component of the rotation matrix.\n@param[in]\ncs_type [rocblas_datatype]\nspecifies the datatype of c and s.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_rot_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        cs_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_rot_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        cs_type: rocblas_datatype,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\nrot_batched_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batch_count.\nScalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.\n\nIn the case where cs_type is real:\n\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\n\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\nCurrently supported datatypes are as follows:\n\n------------------------------------------------\n|  x_type | y_type  | cs_type | execution_type |\n|---------|---------|---------|----------------|\n|  bf16_r |  bf16_r | bf16_r  |  f32_r         |\n|  f16_r  |  f16_r  | f16_r   |  f32_r         |\n|  f32_r  |  f32_r  | f32_r   |  f32_r         |\n|  f64_r  |  f64_r  | f64_r   |  f64_r         |\n|  f32_c  |  f32_c  | f32_c   |  f32_c         |\n|  f32_c  |  f32_c  | f32_r   |  f32_c         |\n|  f64_c  |  f64_c  | f64_c   |  f64_c         |\n|  f64_c  |  f64_c  | f64_r   |  f64_c         |\n------------------------------------------------\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in each x_i and y_i vectors.\n@param[in, out]\nx       device array of deivce pointers storing each vector x_i.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of each x_i.\n@param[in, out]\ny       device array of device pointers storing each vector y_i.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of each y_i.\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\ncs_type [rocblas_datatype]\nspecifies the datatype of c and s.\n@param[in]\nbatch_count [rocblas_int]\nthe number of x and y arrays, the number of batches.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_rot_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        cs_type: rocblas_datatype,
        batch_count: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_rot_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        cs_type: rocblas_datatype,
        batch_count: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS Level 1 API </b>\n\n\\details\nrot_strided_batched_ex applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batch_count.\nScalars c and s may be stored in either host or device memory. Location is specified by calling rocblas_set_pointer_mode.\n\nIn the case where cs_type is real:\n\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\n\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\nCurrently supported datatypes are as follows:\n\n------------------------------------------------\n|  x_type | y_type  | cs_type | execution_type |\n|---------|---------|---------|----------------|\n|  bf16_r |  bf16_r | bf16_r  |  f32_r         |\n|  f16_r  |  f16_r  | f16_r   |  f32_r         |\n|  f32_r  |  f32_r  | f32_r   |  f32_r         |\n|  f64_r  |  f64_r  | f64_r   |  f64_r         |\n|  f32_c  |  f32_c  | f32_c   |  f32_c         |\n|  f32_c  |  f32_c  | f32_r   |  f32_c         |\n|  f64_c  |  f64_c  | f64_c   |  f64_c         |\n|  f64_c  |  f64_c  | f64_r   |  f64_c         |\n------------------------------------------------\n\n@param[in]\nhandle  [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn       [rocblas_int]\nnumber of elements in each x_i and y_i vectors.\n@param[in, out]\nx       device pointer to the first vector x_1.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx    [rocblas_int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstride_x [rocblas_stride]\nspecifies the increment from the beginning of x_i to the beginning of x_(i+1)\n@param[in, out]\ny       device pointer to the first vector y_1.\n@param[in]\ny_type [rocblas_datatype]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy    [rocblas_int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstride_y [rocblas_stride]\nspecifies the increment from the beginning of y_i to the beginning of y_(i+1)\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\ncs_type [rocblas_datatype]\nspecifies the datatype of c and s.\n@param[in]\nbatch_count [rocblas_int]\nthe number of x and y arrays, the number of batches.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_rot_strided_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        stride_x: rocblas_stride,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: rocblas_int,
        stride_y: rocblas_stride,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        cs_type: rocblas_datatype,
        batch_count: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_rot_strided_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        stride_x: rocblas_stride,
        y: *mut ::std::os::raw::c_void,
        y_type: rocblas_datatype,
        incy: i64,
        stride_y: rocblas_stride,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        cs_type: rocblas_datatype,
        batch_count: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\nscal_ex  scales each element of vector x with scalar alpha.\n\nx := alpha * x\n\nCurrently supported datatypes are as follows:\n\n----------------------------------------\n| alpha_type | x_type | execution_type |\n|------------|--------|----------------|\n|  f32_r     | bf16_r |     f32_r      |\n|  bf16_r    | bf16_r |     f32_r      |\n|  f16_r     | f16_r  |     f16_r      |\n|  f16_r     | f16_r  |     f32_r      |\n|  f32_r     | f16_r  |     f32_r      |\n|  f32_r     | f32_r  |     f32_r      |\n|  f64_r     | f64_r  |     f64_r      |\n|  f32_c     | f32_c  |     f32_c      |\n|  f64_c     | f64_c  |     f64_c      |\n|  f32_r     | f32_c  |     f32_c      |\n|  f64_r     | f64_c  |     f64_c      |\n----------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalpha_type [rocblas_datatype]\nspecifies the datatype of alpha.\n@param[in, out]\nx         device pointer storing vector x.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of vector x.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of x.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_scal_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scal_ex_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\nscal_batched_ex  scales each element of each vector x_i with scalar alpha.\n\nx_i := alpha * x_i\n\nCurrently supported datatypes are as follows:\n\n----------------------------------------\n| alpha_type | x_type | execution_type |\n|------------|--------|----------------|\n|  f32_r     | bf16_r |     f32_r      |\n|  bf16_r    | bf16_r |     f32_r      |\n|  f16_r     | f16_r  |     f16_r      |\n|  f16_r     | f16_r  |     f32_r      |\n|  f32_r     | f16_r  |     f32_r      |\n|  f32_r     | f32_r  |     f32_r      |\n|  f64_r     | f64_r  |     f64_r      |\n|  f32_c     | f32_c  |     f32_c      |\n|  f64_c     | f64_c  |     f64_c      |\n|  f32_r     | f32_c  |     f32_c      |\n|  f64_r     | f64_c  |     f64_c      |\n----------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalpha_type [rocblas_datatype]\nspecifies the datatype of alpha.\n@param[in, out]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n"]
    pub fn rocblas_scal_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        batch_count: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scal_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        batch_count: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief <b> BLAS EX API </b>\n\n\\details\nscal_strided_batched_ex  scales each element of vector x with scalar alpha over a set\nof strided batched vectors.\n\nx := alpha * x\n\nCurrently supported datatypes are as follows:\n\n----------------------------------------\n| alpha_type | x_type | execution_type |\n|------------|--------|----------------|\n|  f32_r     | bf16_r |     f32_r      |\n|  bf16_r    | bf16_r |     f32_r      |\n|  f16_r     | f16_r  |     f16_r      |\n|  f16_r     | f16_r  |     f32_r      |\n|  f32_r     | f16_r  |     f32_r      |\n|  f32_r     | f32_r  |     f32_r      |\n|  f64_r     | f64_r  |     f64_r      |\n|  f32_c     | f32_c  |     f32_c      |\n|  f64_c     | f64_c  |     f64_c      |\n|  f32_r     | f32_c  |     f32_c      |\n|  f64_r     | f64_c  |     f64_c      |\n----------------------------------------\n\n@param[in]\nhandle    [rocblas_handle]\nhandle to the rocblas library context queue.\n@param[in]\nn         [rocblas_int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalpha_type [rocblas_datatype]\nspecifies the datatype of alpha.\n@param[in, out]\nx         device pointer to the first vector x_1.\n@param[in]\nx_type [rocblas_datatype]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [rocblas_int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [rocblas_stride]\nstride from the start of one vector (x_i) to the next one (x_i+1).\nThere are no restrictions placed on stridex. However, ensure that stridex is of appropriate size. For a typical\ncase this means stridex >= n * incx.\n@param[in]\nbatch_count [rocblas_int]\nnumber of instances in the batch.\n@param[in]\nexecution_type [rocblas_datatype]\nspecifies the datatype of computation.\n\n"]
    pub fn rocblas_scal_strided_batched_ex(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: rocblas_int,
        stridex: rocblas_stride,
        batch_count: rocblas_int,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_scal_strided_batched_ex_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *const ::std::os::raw::c_void,
        alpha_type: rocblas_datatype,
        x: *mut ::std::os::raw::c_void,
        x_type: rocblas_datatype,
        incx: i64,
        stridex: rocblas_stride,
        batch_count: i64,
        execution_type: rocblas_datatype,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " BLAS Auxiliary API\n\n\\details\nrocblas_status_to_string\n\nReturns string representing rocblas_status value\n\n@param[in]\nstatus  [rocblas_status]\nrocBLAS status to convert to string"]
    pub fn rocblas_status_to_string(status: rocblas_status) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " \\brief Initialize rocBLAS on the current HIP device, to avoid costly startup time at the first call on that device.\n\\details\n\nCalling `rocblas_initialize()` allows upfront initialization including device specific kernel setup.\nOtherwise this function is automatically called on the first function call that requires these initializations (mainly GEMM).\n"]
    pub fn rocblas_initialize();
}
unsafe extern "C" {
    #[doc = " \\brief   Loads char* buf with the rocblas library version. size_t len\nis the maximum length of char* buf.\n\\details\n\n@param[in, out]\nbuf             pointer to buffer for version string\n\n@param[in]\nlen             length of buf\n"]
    pub fn rocblas_get_version_string(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief   Queries the minimum buffer size for a successful call to\n\\ref rocblas_get_version_string\n\\details\n\n@param[out]\nlen             pointer to size_t for storing the length\n"]
    pub fn rocblas_get_version_string_size(len: *mut usize) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nIndicates that subsequent rocBLAS kernel calls should collect the optimal device memory size in bytes for their given kernel arguments\nand keep track of the maximum.\nEach kernel call can reuse temporary device memory on the same stream so the maximum is collected.\nReturns rocblas_status_size_query_mismatch if another size query is already in progress; returns rocblas_status_success otherwise\n@param[in]\nhandle          rocblas handle"]
    pub fn rocblas_start_device_memory_size_query(handle: rocblas_handle) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nStops collecting optimal device memory size information.\nReturns rocblas_status_size_query_mismatch if a collection is not underway; rocblas_status_invalid_handle if handle is nullptr;\nrocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise\n@param[in]\nhandle          rocblas handle\n@param[out]\nsize            maximum of the optimal sizes collected"]
    pub fn rocblas_stop_device_memory_size_query(
        handle: rocblas_handle,
        size: *mut usize,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_is_device_memory_size_query(handle: rocblas_handle) -> bool;
}
unsafe extern "C" {
    pub fn rocblas_set_optimal_device_memory_size_impl(
        handle: rocblas_handle,
        count: usize,
        ...
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_device_malloc_alloc(
        handle: rocblas_handle,
        res: *mut *mut rocblas_device_malloc_base,
        count: usize,
        ...
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_device_malloc_success(ptr: *mut rocblas_device_malloc_base) -> bool;
}
unsafe extern "C" {
    pub fn rocblas_device_malloc_ptr(
        ptr: *mut rocblas_device_malloc_base,
        res: *mut *mut ::std::os::raw::c_void,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_device_malloc_get(
        ptr: *mut rocblas_device_malloc_base,
        index: usize,
        res: *mut *mut ::std::os::raw::c_void,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_device_malloc_free(ptr: *mut rocblas_device_malloc_base) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocblas_device_malloc_set_default_memory_size(size: usize);
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nGets the current device memory size for the handle.\nReturns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise\n@param[in]\nhandle          rocblas handle\n@param[out]\nsize            current device memory size for the handle"]
    pub fn rocblas_get_device_memory_size(
        handle: rocblas_handle,
        size: *mut usize,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nChanges the size of allocated device memory at runtime.\n\nAny previously allocated device memory managed by the handle is freed.\n\nIf size > 0 sets the device memory size to the specified size (in bytes).\nIf size == 0, frees the memory allocated so far, and lets rocBLAS manage device memory in the future, expanding it when necessary.\nReturns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_invalid_pointer if size is nullptr; rocblas_status_success otherwise\n@param[in]\nhandle          rocblas handle\n@param[in]\nsize            size of allocated device memory"]
    pub fn rocblas_set_device_memory_size(handle: rocblas_handle, size: usize) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nSets the device workspace for the handle to use.\n\nAny previously allocated device memory managed by the handle is freed.\n\nReturns rocblas_status_invalid_handle if handle is nullptr; rocblas_status_success otherwise\n@param[in]\nhandle          rocblas handle\n@param[in]\naddr            address of workspace memory\n@param[in]\nsize            size of workspace memory\n"]
    pub fn rocblas_set_workspace(
        handle: rocblas_handle,
        addr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nReturns true when device memory in handle is managed by rocBLAS\n@param[in]\nhandle          rocblas handle"]
    pub fn rocblas_is_managing_device_memory(handle: rocblas_handle) -> bool;
}
unsafe extern "C" {
    #[doc = " \\brief\n\\details\nReturns true when device memory in handle is managed by the user\n@param[in]\nhandle          rocblas handle"]
    pub fn rocblas_is_user_managing_device_memory(handle: rocblas_handle) -> bool;
}
unsafe extern "C" {
    pub fn rocblas_abort() -> !;
}
#[doc = " \\deprecated Use \\c rocblas_int."]
pub type rocsolver_int = rocblas_int;
#[doc = " \\deprecated Use \\c rocblas_stride."]
pub type rocsolver_stride = rocblas_stride;
#[doc = " \\deprecated Use \\c rocblas_float_complex."]
pub type rocsolver_float_complex = rocblas_float_complex;
#[doc = " \\deprecated Use \\c rocblas_double_complex."]
pub type rocsolver_double_complex = rocblas_double_complex;
#[doc = " \\deprecated Use \\c rocblas_half."]
pub type rocsolver_half = rocblas_half;
#[doc = " \\deprecated Use \\c rocblas_handle."]
pub type rocsolver_handle = rocblas_handle;
#[doc = " \\deprecated Use \\c rocblas_diagonal."]
pub use self::rocblas_diagonal as rocsolver_diagonal;
#[doc = " \\deprecated Use \\c rocblas_direct"]
pub use self::rocblas_direct as rocsolver_direction;
#[doc = " \\deprecated Use \\c rocblas_fill."]
pub use self::rocblas_fill as rocsolver_fill;
#[doc = " \\deprecated Use \\c rocblas_layer_mode."]
pub use self::rocblas_layer_mode as rocsolver_layer_mode;
#[doc = " \\deprecated Use \\c rocblas_operation."]
pub use self::rocblas_operation as rocsolver_operation;
#[doc = " \\deprecated Use \\c rocblas_stide."]
pub use self::rocblas_side as rocsolver_side;
#[doc = " \\deprecated Use \\c rocblas_status."]
pub use self::rocblas_status as rocsolver_status;
#[doc = " \\deprecated Use \\c rocblas_storev."]
pub use self::rocblas_storev as rocsolver_storev;
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_create_handle."]
    pub fn rocsolver_create_handle(handle: *mut rocsolver_handle) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_destroy_handle."]
    pub fn rocsolver_destroy_handle(handle: rocsolver_handle) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_set_stream."]
    pub fn rocsolver_set_stream(handle: rocsolver_handle, stream: hipStream_t) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_get_stream."]
    pub fn rocsolver_get_stream(
        handle: rocsolver_handle,
        stream: *mut hipStream_t,
    ) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_set_vector."]
    pub fn rocsolver_set_vector(
        n: rocsolver_int,
        elem_size: rocsolver_int,
        x: *const ::std::os::raw::c_void,
        incx: rocsolver_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocsolver_int,
    ) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_get_vector."]
    pub fn rocsolver_get_vector(
        n: rocsolver_int,
        elem_size: rocsolver_int,
        x: *const ::std::os::raw::c_void,
        incx: rocsolver_int,
        y: *mut ::std::os::raw::c_void,
        incy: rocsolver_int,
    ) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_set_matrix."]
    pub fn rocsolver_set_matrix(
        rows: rocsolver_int,
        cols: rocsolver_int,
        elem_size: rocsolver_int,
        a: *const ::std::os::raw::c_void,
        lda: rocsolver_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocsolver_int,
    ) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\deprecated Use \\c rocblas_get_matrix."]
    pub fn rocsolver_get_matrix(
        rows: rocsolver_int,
        cols: rocsolver_int,
        elem_size: rocsolver_int,
        a: *const ::std::os::raw::c_void,
        lda: rocsolver_int,
        b: *mut ::std::os::raw::c_void,
        ldb: rocsolver_int,
    ) -> rocsolver_status;
}
unsafe extern "C" {
    #[doc = " \\brief GET_VERSION_STRING Queries the library version.\n\n\\details\n@param[out]\nbuf         A buffer that the version string will be written into.\n@param[in]\nlen         The size of the given buffer in bytes."]
    pub fn rocsolver_get_version_string(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief GET_VERSION_STRING_SIZE Queries the minimum buffer size for a\nsuccessful call to \\ref rocsolver_get_version_string.\n\n\\details\n@param[out]\nlen         pointer to size_t.\nThe minimum length of buffer to pass to\n\\ref rocsolver_get_version_string."]
    pub fn rocsolver_get_version_string_size(len: *mut usize) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_BEGIN begins a rocSOLVER multi-level logging session.\n\n\\details\nInitializes the rocSOLVER logging environment with default values (no\nlogging and one level depth). Default mode can be overridden by using the\nenvironment variables ROCSOLVER_LAYER and ROCSOLVER_LEVELS.\n\nThis function also sets the streams where the log results will be outputted.\nThe default is STDERR for all the modes. This default can also be overridden\nusing the environment variable ROCSOLVER_LOG_PATH, or specifically\nROCSOLVER_LOG_TRACE_PATH, ROCSOLVER_LOG_BENCH_PATH, and/or ROCSOLVER_LOG_PROFILE_PATH."]
    pub fn rocsolver_log_begin() -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_END ends the multi-level rocSOLVER logging session.\n\n\\details\nIf applicable, this function also prints the profile logging results\nbefore cleaning the logging environment."]
    pub fn rocsolver_log_end() -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_SET_LAYER_MODE sets the logging mode for the rocSOLVER multi-level\nlogging environment.\n\n\\details\n@param[in]\nlayer_mode  rocblas_layer_mode_flags.\nSpecifies the logging mode."]
    pub fn rocsolver_log_set_layer_mode(layer_mode: rocblas_layer_mode_flags) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_SET_MAX_LEVELS sets the maximum trace log depth for the rocSOLVER\nmulti-level logging environment.\n\n\\details\n@param[in]\nmax_levels  rocblas_int. max_levels >= 1.\nSpecifies the maximum depth at which nested function calls\nwill appear in the trace and profile logs."]
    pub fn rocsolver_log_set_max_levels(max_levels: rocblas_int) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_RESTORE_DEFAULTS restores the default values of the rocSOLVER\nmulti-level logging environment.\n\n\\details\nThis function sets the logging mode and maximum trace log depth to their\ndefault values (no logging and one level depth)."]
    pub fn rocsolver_log_restore_defaults() -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_WRITE_PROFILE prints the profile logging results."]
    pub fn rocsolver_log_write_profile() -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief LOG_FLUSH_PROFILE prints the profile logging results and clears the\nprofile record."]
    pub fn rocsolver_log_flush_profile() -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LACGV conjugates the complex vector x.\n\n\\details\nIt conjugates the n entries of a complex vector x with increment incx.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe dimension of vector x.\n@param[inout]\nx           pointer to type. Array on the GPU of size at least n (size depends on the value of incx).\nOn entry, the vector x.\nOn exit, each entry is overwritten with its conjugate value.\n@param[in]\nincx        rocblas_int. incx != 0.\nThe distance between two consecutive elements of x.\nIf incx is negative, the elements of x are indexed in\nreverse order."]
    pub fn rocsolver_clacgv(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlacgv(
        handle: rocblas_handle,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clacgv_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlacgv_64(
        handle: rocblas_handle,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LASWP performs a series of row interchanges on the matrix A.\n\n\\details\nRow interchanges are done one by one. If \\f$\\text{ipiv}[k_1 + (j - k_1) \\cdot \\text{abs}(\\text{incx})] = r\\f$, then the j-th row of A\nwill be interchanged with the r-th row of A, for \\f$j = k_1,k_1+1,\\dots,k_2\\f$. Indices \\f$k_1\\f$ and \\f$k_2\\f$ are 1-based indices.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to which the row\ninterchanges will be applied. On exit, the resulting permuted matrix.\n@param[in]\nlda         rocblas_int. lda > 0.\nThe leading dimension of the array A.\n@param[in]\nk1          rocblas_int. k1 > 0.\nThe k_1 index. It is the first element of ipiv for which a row interchange will\nbe done. This is a 1-based index.\n@param[in]\nk2          rocblas_int. k2 > k1 > 0.\nThe k_2 index. k_2 - k_1 + 1 is the number of elements of ipiv for which a row\ninterchange will be done. This is a 1-based index.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension at least \\f$k_1 + (k_2 - k_1)\\cdot \\text{abs}(\\text{incx})\\f$.\nThe vector of pivot indices. Only the elements in positions\n\\f$k_1\\f$ through \\f$k_1 + (k_2 - k_1)\\cdot \\text{abs}(\\text{incx})\\f$ of this vector are accessed.\nElements of ipiv are considered 1-based.\n@param[in]\nincx        rocblas_int. incx != 0.\nThe distance between successive values of ipiv.  If incx\nis negative, the pivots are applied in reverse order."]
    pub fn rocsolver_slaswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlaswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_claswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlaswp(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        k1: rocblas_int,
        k2: rocblas_int,
        ipiv: *const rocblas_int,
        incx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LARFG generates a Householder reflector H of order n.\n\n\\details\nThe reflector H is such that\n\n\\f[\nH'\\left[\\begin{array}{c}\n\\text{alpha}\\\\\nx\n\\end{array}\\right]=\\left[\\begin{array}{c}\n\\text{beta}\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere x is an n-1 vector, and alpha and beta are scalars. Matrix H can be\ngenerated as\n\n\\f[\nH = I - \\text{tau}\\left[\\begin{array}{c}\n1\\\\\nv\n\\end{array}\\right]\\left[\\begin{array}{cc}\n1 & v'\n\\end{array}\\right]\n\\f]\n\nwhere v is an n-1 vector, and tau is a scalar known as the Householder scalar. The vector\n\n\\f[\n\\bar{v}=\\left[\\begin{array}{c}\n1\\\\\nv\n\\end{array}\\right]\n\\f]\n\nis the Householder vector associated with the reflection.\n\n\\note\nThe matrix H is orthogonal/unitary (i.e. \\f$H'H=HH'=I\\f$). It is symmetric when real (i.e. \\f$H^T=H\\f$), but not Hermitian when complex\n(i.e. \\f$H^H\\neq H\\f$ in general).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order (size) of reflector H.\n@param[inout]\nalpha       pointer to type. A scalar on the GPU.\nOn entry, the scalar alpha.\nOn exit, it is overwritten with beta.\n@param[inout]\nx           pointer to type. Array on the GPU of size at least n-1 (size depends on the value of incx).\nOn entry, the vector x,\nOn exit, it is overwritten with vector v.\n@param[in]\nincx        rocblas_int. incx > 0.\nThe distance between two consecutive elements of x.\n@param[out]\ntau         pointer to type. A scalar on the GPU.\nThe Householder scalar tau."]
    pub fn rocsolver_slarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut f32,
        x: *mut f32,
        incx: rocblas_int,
        tau: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut f64,
        x: *mut f64,
        incx: rocblas_int,
        tau: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlarfg(
        handle: rocblas_handle,
        n: rocblas_int,
        alpha: *mut rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_slarfg_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *mut f32,
        x: *mut f32,
        incx: i64,
        tau: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlarfg_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *mut f64,
        x: *mut f64,
        incx: i64,
        tau: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clarfg_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *mut rocblas_float_complex,
        x: *mut rocblas_float_complex,
        incx: i64,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlarfg_64(
        handle: rocblas_handle,
        n: i64,
        alpha: *mut rocblas_double_complex,
        x: *mut rocblas_double_complex,
        incx: i64,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LARFT generates the triangular factor T of a block reflector H of\norder n.\n\n\\details\nThe block reflector H is defined as the product of k Householder matrices\n\n\\f[\n\\begin{array}{cl}\nH = H(1)H(2)\\cdots H(k) & \\: \\text{if direct indicates forward direction, or} \\\\\nH = H(k)\\cdots H(2)H(1) & \\: \\text{if direct indicates backward direction}\n\\end{array}\n\\f]\n\nThe triangular factor T is upper triangular in the forward direction and lower triangular in the backward direction.\nIf storev is column-wise, then\n\n\\f[\nH = I - VTV'\n\\f]\n\nwhere the \\f$j\\f$th column of matrix V contains the Householder vector associated with \\f$H(j)\\f$. If storev is row-wise, then\n\n\\f[\nH = I - V'TV\n\\f]\n\nwhere the \\f$i\\f$th row of matrix V contains the Householder vector associated with \\f$H(i)\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ndirect      #rocblas_direct.\nSpecifies the direction in which the Householder matrices are applied.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies how the Householder vectors are stored in matrix V.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order (size) of the block reflector.\n@param[in]\nk           rocblas_int. k >= 1.\nThe number of Householder matrices forming H.\n@param[in]\nV           pointer to type. Array on the GPU of size ldv*k if column-wise, or ldv*n if row-wise.\nThe matrix of Householder vectors.\n@param[in]\nldv         rocblas_int. ldv >= n if column-wise, or ldv >= k if row-wise.\nLeading dimension of V.\n@param[in]\ntau         pointer to type. Array of k scalars on the GPU.\nThe vector of all the Householder scalars.\n@param[out]\nT           pointer to type. Array on the GPU of dimension ldt*k.\nThe triangular factor. T is upper triangular if direct indicates forward direction, otherwise it is\nlower triangular. The rest of the array is not used.\n@param[in]\nldt         rocblas_int. ldt >= k.\nThe leading dimension of T."]
    pub fn rocsolver_slarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        tau: *mut f32,
        T: *mut f32,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        tau: *mut f64,
        T: *mut f64,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        tau: *mut rocblas_float_complex,
        T: *mut rocblas_float_complex,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlarft(
        handle: rocblas_handle,
        direct: rocblas_direct,
        storev: rocblas_storev,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        tau: *mut rocblas_double_complex,
        T: *mut rocblas_double_complex,
        ldt: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LARF applies a Householder reflector H to a general matrix A.\n\n\\details\nThe Householder reflector H, of order m or n, is to be applied to an m-by-n matrix A\nfrom the left or the right, depending on the value of side. H is given by\n\n\\f[\nH = I - \\text{alpha}\\cdot xx'\n\\f]\n\nwhere alpha is the Householder scalar and x is a Householder vector. H is never actually computed.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nDetermines whether H is applied from the left or the right.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of A.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of A.\n@param[in]\nx           pointer to type. Array on the GPU of size at least 1 + (m-1)*abs(incx) if left side, or\nat least 1 + (n-1)*abs(incx) if right side.\nThe Householder vector x.\n@param[in]\nincx        rocblas_int. incx != 0.\nDistance between two consecutive elements of x.\nIf incx < 0, the elements of x are indexed in reverse order.\n@param[in]\nalpha       pointer to type. A scalar on the GPU.\nThe Householder scalar. If alpha = 0, then H = I (A will remain the same; x is never used)\n@param[inout]\nA           pointer to type. Array on the GPU of size lda*n.\nOn entry, the matrix A. On exit, it is overwritten with\nH*A (or A*H).\n@param[in]\nlda         rocblas_int. lda >= m.\nLeading dimension of A."]
    pub fn rocsolver_slarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut f32,
        incx: rocblas_int,
        alpha: *const f32,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut f64,
        incx: rocblas_int,
        alpha: *const f64,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut rocblas_float_complex,
        incx: rocblas_int,
        alpha: *const rocblas_float_complex,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlarf(
        handle: rocblas_handle,
        side: rocblas_side,
        m: rocblas_int,
        n: rocblas_int,
        x: *mut rocblas_double_complex,
        incx: rocblas_int,
        alpha: *const rocblas_double_complex,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_slarf_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        x: *mut f32,
        incx: i64,
        alpha: *const f32,
        A: *mut f32,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlarf_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        x: *mut f64,
        incx: i64,
        alpha: *const f64,
        A: *mut f64,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clarf_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        x: *mut rocblas_float_complex,
        incx: i64,
        alpha: *const rocblas_float_complex,
        A: *mut rocblas_float_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlarf_64(
        handle: rocblas_handle,
        side: rocblas_side,
        m: i64,
        n: i64,
        x: *mut rocblas_double_complex,
        incx: i64,
        alpha: *const rocblas_double_complex,
        A: *mut rocblas_double_complex,
        lda: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LARFB applies a block reflector H to a general m-by-n matrix A.\n\n\\details\nThe block reflector H is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nHA & \\: \\text{(No transpose from the left),}\\\\\nH'A & \\:  \\text{(Transpose or conjugate transpose from the left),}\\\\\nAH & \\: \\text{(No transpose from the right), or}\\\\\nAH' & \\: \\text{(Transpose or conjugate transpose from the right).}\n\\end{array}\n\\f]\n\nThe block reflector H is defined as the product of k Householder matrices as\n\n\\f[\n\\begin{array}{cl}\nH = H(1)H(2)\\cdots H(k) & \\: \\text{if direct indicates forward direction, or} \\\\\nH = H(k)\\cdots H(2)H(1) & \\: \\text{if direct indicates backward direction}\n\\end{array}\n\\f]\n\nH is never stored. It is calculated as\n\n\\f[\nH = I - VTV'\n\\f]\n\nwhere the \\f$j\\f$th column of matrix V contains the Householder vector associated with \\f$H(j)\\f$, if storev is column-wise; or\n\n\\f[\nH = I - V'TV\n\\f]\n\nwhere the \\f$i\\f$th row of matrix V contains the Householder vector associated with \\f$H(i)\\f$, if storev is row-wise.\nT is the associated triangular factor as computed by \\ref rocsolver_slarft \"LARFT\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply H.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the block reflector or its transpose/conjugate transpose is to be applied.\n@param[in]\ndirect      #rocblas_direct.\nSpecifies the direction in which the Householder matrices are to be applied to generate H.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies how the Householder vectors are stored in matrix V.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix A.\n@param[in]\nk           rocblas_int. k >= 1.\nThe number of Householder matrices.\n@param[in]\nV           pointer to type. Array on the GPU of size ldv*k if column-wise, ldv*n if row-wise and applying from the right,\nor ldv*m if row-wise and applying from the left.\nThe matrix of Householder vectors.\n@param[in]\nldv         rocblas_int. ldv >= k if row-wise, ldv >= m if column-wise and applying from the left, or ldv >= n if\ncolumn-wise and applying from the right.\nLeading dimension of V.\n@param[in]\nT           pointer to type. Array on the GPU of dimension ldt*k.\nThe triangular factor of the block reflector.\n@param[in]\nldt         rocblas_int. ldt >= k.\nThe leading dimension of T.\n@param[inout]\nA           pointer to type. Array on the GPU of size lda*n.\nOn entry, the matrix A. On exit, it is overwritten with\nH*A, A*H, H'*A, or A*H'.\n@param[in]\nlda         rocblas_int. lda >= m.\nLeading dimension of A."]
    pub fn rocsolver_slarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        T: *mut f32,
        ldt: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        T: *mut f64,
        ldt: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        T: *mut rocblas_float_complex,
        ldt: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlarfb(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        direct: rocblas_direct,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        T: *mut rocblas_double_complex,
        ldt: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LABRD computes the bidiagonal form of the first k rows and columns of\na general m-by-n matrix A, as well as the matrices X and Y needed to reduce\nthe remaining part of A.\n\n\\details\nThe reduced form is given by:\n\n\\f[\nB = Q'AP\n\\f]\n\nwhere the leading k-by-k block of B is upper bidiagonal if m >= n, or lower bidiagonal if m < n. Q and\nP are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(k), & \\text{and} \\\\\nP = G(1)G(2)\\cdots G(k).\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ and \\f$G(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH(i) = I - \\text{tauq}[i]\\cdot v_i^{}v_i', & \\text{and} \\\\\nG(i) = I - \\text{taup}[i]\\cdot u_i^{}u_i'.\n\\end{array}\n\\f]\n\nIf m >= n, the first \\f$i-1\\f$ elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i]=1\\f$;\nwhile the first \\f$i\\f$ elements of the Householder vector \\f$u_i\\f$ are zero, and  \\f$u_i[i+1]=1\\f$.\nIf m < n, the first \\f$i\\f$ elements of the Householder vector  \\f$v_i\\f$ are zero, and  \\f$v_i[i+1]=1\\f$;\nwhile the first \\f$i-1\\f$ elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i]=1\\f$.\n\nThe unreduced part of the matrix A can be updated using the block update\n\n\\f[\nA = A - VY' - XU'\n\\f]\n\nwhere V and U are the m-by-k and n-by-k matrices formed with the vectors \\f$v_i\\f$ and \\f$u_i\\f$, respectively.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[in]\nk           rocblas_int. min(m,n) >= k >= 0.\nThe number of leading rows and columns of matrix A that will be reduced.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be reduced.\nOn exit, the first k elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n), contain the bidiagonal form B.\nIf m >= n, the elements below the diagonal of the first k columns are the possibly non-zero elements\nof the Householder vectors associated with Q, while the elements above the\nsuperdiagonal of the first k rows are the n - i - 1 possibly non-zero elements of the Householder vectors related to P.\nIf m < n, the elements below the subdiagonal of the first k columns are the m - i - 1 possibly non-zero\nelements of the Householder vectors related to Q, while the elements above the\ndiagonal of the first k rows are the n - i possibly non-zero elements of the vectors associated with P.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension k.\nThe diagonal elements of B.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension k.\nThe off-diagonal elements of B.\n@param[out]\ntauq        pointer to type. Array on the GPU of dimension k.\nThe Householder scalars associated with matrix Q.\n@param[out]\ntaup        pointer to type. Array on the GPU of dimension k.\nThe Householder scalars associated with matrix P.\n@param[out]\nX           pointer to type. Array on the GPU of dimension ldx*k.\nThe m-by-k matrix needed to update the unreduced part of A.\n@param[in]\nldx         rocblas_int. ldx >= m.\nThe leading dimension of X.\n@param[out]\nY           pointer to type. Array on the GPU of dimension ldy*k.\nThe n-by-k matrix needed to update the unreduced part of A.\n@param[in]\nldy         rocblas_int. ldy >= n.\nThe leading dimension of Y."]
    pub fn rocsolver_slabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
        X: *mut f32,
        ldx: rocblas_int,
        Y: *mut f32,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
        X: *mut f64,
        ldx: rocblas_int,
        Y: *mut f64,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut rocblas_float_complex,
        taup: *mut rocblas_float_complex,
        X: *mut rocblas_float_complex,
        ldx: rocblas_int,
        Y: *mut rocblas_float_complex,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlabrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut rocblas_double_complex,
        taup: *mut rocblas_double_complex,
        X: *mut rocblas_double_complex,
        ldx: rocblas_int,
        Y: *mut rocblas_double_complex,
        ldy: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LATRD computes the tridiagonal form of k rows and columns of\na symmetric/hermitian matrix A, as well as the matrix W needed to update\nthe remaining part of A.\n\n\\details\nThe reduced form is given by:\n\n\\f[\nT = Q'AQ\n\\f]\n\nIf uplo is lower, the first k rows and columns of T form the tridiagonal block. If uplo is upper, then the last\nk rows and columns of T form the tridiagonal block. Q is an orthogonal/unitary matrix represented as the\nproduct of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(k) & \\text{if uplo indicates lower, or}\\\\\nQ = H(n)H(n-1)\\cdots H(n-k+1) & \\text{if uplo is upper}.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i]\\cdot v_i^{}v_i'\n\\f]\n\nwhere tau[\\f$i\\f$] is the corresponding Householder scalar. When uplo indicates lower, the first \\f$i\\f$\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo is upper,\nthe last n-\\f$i\\f$ elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\nThe unreduced part of the matrix A can be updated using a rank update of the form:\n\n\\f[\nA = A - VW' - WV'\n\\f]\n\nwhere V is the n-by-k matrix formed by the vectors \\f$v_i\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of rows and columns of the matrix A to be reduced.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the n-by-n matrix to be reduced.\nOn exit, if uplo is lower, the first k columns have been reduced to tridiagonal form\n(given in the diagonal elements of A and the array E), the elements below the diagonal\ncontain the possibly non-zero entries of the Householder vectors associated with Q, stored as columns.\nIf uplo is upper, the last k columns have been reduced to tridiagonal form\n(given in the diagonal elements of A and the array E), the elements above the diagonal\ncontain the possibly non-zero entries of the Householder vectors associated with Q, stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n-1.\nIf upper (lower), the last (first) k elements of E are the off-diagonal elements of the\ncomputed tridiagonal block.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nIf upper (lower), the last (first) k elements of tau are the Householder scalars related to Q.\n@param[out]\nW           pointer to type. Array on the GPU of dimension ldw*k.\nThe n-by-k matrix needed to update the unreduced part of A.\n@param[in]\nldw         rocblas_int. ldw >= n.\nThe leading dimension of W."]
    pub fn rocsolver_slatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        E: *mut f32,
        tau: *mut f32,
        W: *mut f32,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        E: *mut f64,
        tau: *mut f64,
        W: *mut f64,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        E: *mut f32,
        tau: *mut rocblas_float_complex,
        W: *mut rocblas_float_complex,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlatrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        E: *mut f64,
        tau: *mut rocblas_double_complex,
        W: *mut rocblas_double_complex,
        ldw: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LASYF computes a partial factorization of a symmetric matrix \\f$A\\f$\nusing Bunch-Kaufman diagonal pivoting.\n\n\\details\nThe partial factorization has the form\n\n\\f[\nA = \\left[ \\begin{array}{cc}\nI & U_{12} \\\\\n0 & U_{22}\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nA_{11} & 0 \\\\\n0 & D\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nI & 0 \\\\\nU_{12}^T & U_{22}^T\n\\end{array} \\right]\n\\f]\n\nor\n\n\\f[\nA = \\left[ \\begin{array}{cc}\nL_{11} & 0 \\\\\nL_{21} & I\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nD & 0 \\\\\n0 & A_{22}\n\\end{array} \\right] \\left[ \\begin{array}{cc}\nL_{11}^T & L_{21}^T \\\\\n0 & I\n\\end{array} \\right]\n\\f]\n\ndepending on the value of uplo. The order of the block diagonal matrix \\f$D\\f$\nis either \\f$nb\\f$ or \\f$nb-1\\f$, and is returned in the argument \\f$kb\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nnb          rocblas_int. 2 <= nb <= n.\nThe number of columns of A to be factored.\n@param[out]\nkb          pointer to a rocblas_int on the GPU.\nThe number of columns of A that were actually factored (either nb or\nnb-1).\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A to be factored.\nOn exit, the partially factored matrix.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nIf uplo is upper, then only the last kb elements of ipiv will be\nset. For n - kb < k <= n, if ipiv[k] > 0 then rows and columns k\nand ipiv[k] were interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k-1] < 0, then rows and columns k-1\nand -ipiv[k] were interchanged and D[k-1,k-1] to D[k,k] is a 2-by-2\ndiagonal block.\nIf uplo is lower, then only the first kb elements of ipiv will be\nset. For 1 <= k <= kb, if ipiv[k] > 0 then rows and columns k\nand ipiv[k] were interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k+1] < 0, then rows and columns k+1\nand -ipiv[k] were interchanged and D[k,k] to D[k+1,k+1] is a 2-by-2\ndiagonal block.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, D is singular. D[i,i] is the first diagonal zero."]
    pub fn rocsolver_slasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlasyf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nb: rocblas_int,
        kb: *mut rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief LAUUM computes the product of the upper (or lower) triangular part U (or L) of a\nsymmetric/Hemitian matrix A with its transpose.\n\n\\details\nIf uplo indicates upper, then \\f$UU'\\f$ is computed. If uplo indicates lower, then \\f$L'L\\f$ is computed instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower triangular part of A will be used.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not referenced.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns and rows of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, it contains the upper (or lower) part of the symmetric/Hermitian matrix.\nOn exit, the upper (or lower) part is overwritten with the result of U*U' (or L'*L).\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of the array A."]
    pub fn rocsolver_slauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dlauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_clauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zlauum(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORG2R generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k).\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_sorg2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorg2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNG2R generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_cung2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zung2r(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORGQR generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_sorgqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorgqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNGQR generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first n columns of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nHouseholder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQRF\", with the Householder vectors in the first k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\"."]
    pub fn rocsolver_cungqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zungqr(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORGL2 generates an m-by-n Matrix Q with orthonormal rows.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_sorgl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorgl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNGL2 generates an m-by-n complex Matrix Q with orthonormal rows.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_cungl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zungl2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORGLQ generates an m-by-n Matrix Q with orthonormal rows.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_sorglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNGLQ generates an m-by-n complex Matrix Q with orthonormal rows.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the first m rows of the product of k Householder\nreflectors of order n\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. 0 <= m <= n.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= m.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GELQF\", with the Householder vectors in the first k rows.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\"."]
    pub fn rocsolver_cunglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunglq(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORG2L generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the last n columns of the product of k\nHouseholder reflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_sorg2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorg2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNG2L generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is defined as the last n columns of the product of k\nHouseholder reflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_cung2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zung2l(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORGQL generates an m-by-n Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the last n column of the product of k Householder\nreflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_sorgql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorgql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNGQL generates an m-by-n complex Matrix Q with orthonormal columns.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is defined as the last n columns of the product of k\nHouseholder reflectors of order m\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\n@param[in]\nn           rocblas_int. 0 <= n <= m.\nThe number of columns of the matrix Q.\n@param[in]\nk           rocblas_int. 0 <= k <= n.\nThe number of Householder reflectors.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A as returned by \\ref rocsolver_sgeqrf \"GEQLF\", with the Householder vectors in the last k columns.\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqlf \"GEQLF\"."]
    pub fn rocsolver_cungql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zungql(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORGBR generates an m-by-n Matrix Q with orthonormal rows or columns.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns. If m >= k, Q is defined as the first\nn columns of the product of k Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nIf m < k, Q is defined as the product of Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(m-1)\n\\f]\n\nOn the other hand, if storev is row-wise, then the matrix Q has orthonormal rows. If n > k, Q is defined as the\nfirst m rows of the product of k Householder reflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nIf n <= k, Q is defined as the product of Householder reflectors of order n\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\nIf row-wise, then min(n,k) <= m <= n.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\nIf column-wise, then min(m,k) <= n <= m.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension min(m,k) if column-wise, or min(n,k) if row-wise.\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\"."]
    pub fn rocsolver_sorgbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorgbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNGBR generates an m-by-n complex Matrix Q with orthonormal rows or\ncolumns.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns. If m >= k, Q is defined as the first\nn columns of the product of k Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nIf m < k, Q is defined as the product of Householder reflectors of order m\n\n\\f[\nQ = H(1)H(2)\\cdots H(m-1)\n\\f]\n\nOn the other hand, if storev is row-wise, then the matrix Q has orthonormal rows. If n > k, Q is defined as the\nfirst m rows of the product of k Householder reflectors of order n\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nIf n <= k, Q is defined as the product of Householder reflectors of order n\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix Q.\nIf row-wise, then min(n,k) <= m <= n.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix Q.\nIf column-wise, then min(m,k) <= n <= m.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\nOn exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension min(m,k) if column-wise, or min(n,k) if row-wise.\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\"."]
    pub fn rocsolver_cungbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zungbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORGTR generates an n-by-n orthogonal Matrix Q.\n\n\\details\nQ is defined as the product of n-1 Householder reflectors of order n. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(n-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by\n\\ref rocsolver_ssytrd \"SYTRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_ssytrd \"SYTRD\" factorization was upper or lower\ntriangular. If uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix Q.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned\nby \\ref rocsolver_ssytrd \"SYTRD\". On exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars as returned by \\ref rocsolver_ssytrd \"SYTRD\"."]
    pub fn rocsolver_sorgtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorgtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNGTR generates an n-by-n unitary Matrix Q.\n\n\\details\nQ is defined as the product of n-1 Householder reflectors of order n. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(n-1)H(n-2)\\cdots H(1)\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(n-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors \\f$v_i\\f$ and scalars \\f$\\text{ipiv}[i]\\f$, as returned by\n\\ref rocsolver_chetrd \"HETRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_chetrd \"HETRD\" factorization was upper or lower\ntriangular. If uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix Q.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the Householder vectors as returned\nby \\ref rocsolver_chetrd \"HETRD\". On exit, the computed matrix Q.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars as returned by \\ref rocsolver_chetrd \"HETRD\"."]
    pub fn rocsolver_cungtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zungtr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORM2R multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2) \\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sorm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNM2R multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C.\n"]
    pub fn rocsolver_cunm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunm2r(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORMQR multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dormqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNMQR multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the QR factorization \\ref rocsolver_sgeqrf \"GEQRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqrf \"GEQRF\"\nin the first k columns of its argument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, or lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgeqrf \"GEQRF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunmqr(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORML2 multiplies a matrix Q with orthonormal rows by a general m-by-n\nmatrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C.\n"]
    pub fn rocsolver_sorml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNML2 multiplies a complex matrix Q with orthonormal rows by a general\nm-by-n matrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunml2(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORMLQ multiplies a matrix Q with orthonormal rows by a general m-by-n\nmatrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dormlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNMLQ multiplies a complex matrix Q with orthonormal rows by a general\nm-by-n matrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)^HH(k-1)^H\\cdots H(1)^H\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is never stored, it is\ncalculated from the Householder vectors and scalars returned by the LQ factorization \\ref rocsolver_sgelqf \"GELQF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*m if side is left, or lda*n if side is right.\nThe Householder vectors as returned by \\ref rocsolver_sgelqf \"GELQF\"\nin the first k rows of its argument A.\n@param[in]\nlda         rocblas_int. lda >= k.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by \\ref rocsolver_sgelqf \"GELQF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunmlq(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORM2L multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be\napplied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sorm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dorm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNM2L multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate\ntranspose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunm2l(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORMQL multiplies a matrix Q with orthonormal columns by a general m-by-n\nmatrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be\napplied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dormql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNMQL multiplies a complex matrix Q with orthonormal columns by a\ngeneral m-by-n matrix C.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nQ is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1)\n\\f]\n\nof order m if applying from the left, or n if applying from the right. Q is\nnever stored, it is calculated from the Householder vectors and scalars\nreturned by the QL factorization \\ref rocsolver_sgeqlf \"GEQLF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate\ntranspose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0; k <= m if side is left, k <= n if side is right.\nThe number of Householder reflectors that form Q.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*k.\nThe Householder vectors as returned by \\ref rocsolver_sgeqlf \"GEQLF\" in the last k columns of its\nargument A.\n@param[in]\nlda         rocblas_int. lda >= m if side is left, lda >= n if side is right.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least k.\nThe Householder scalars as returned by\n\\ref rocsolver_sgeqlf \"GEQLF\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunmql(
        handle: rocblas_handle,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORMBR multiplies a matrix Q with orthonormal rows or columns by a\ngeneral m-by-n matrix C.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns.\nIf storev is row-wise, then the matrix Q has orthonormal rows.\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the orthogonal matrix Q is q = m if applying from the left, or q = n if applying from the right.\n\nWhen storev is column-wise, if q >= k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q < k, then Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nWhen storev is row-wise, if q > k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q <= k, Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors and scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nA           pointer to type. Array on the GPU of size lda*min(q,k) if column-wise, or lda*q if row-wise.\nThe Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nlda         rocblas_int. lda >= q if column-wise, or lda >= min(q,k) if row-wise.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least min(q,k).\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dormbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNMBR multiplies a complex matrix Q with orthonormal rows or columns by\na general m-by-n matrix C.\n\n\\details\nIf storev is column-wise, then the matrix Q has orthonormal columns.\nIf storev is row-wise, then the matrix Q has orthonormal rows.\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the unitary matrix Q is q = m if applying from the left, or q = n if applying from the right.\n\nWhen storev is column-wise, if q >= k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q < k, then Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nWhen storev is row-wise, if q > k, then Q is defined as the product of k Householder reflectors\n\n\\f[\nQ = H(1)H(2)\\cdots H(k),\n\\f]\n\nand if q <= k, Q is defined as the product\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1).\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its corresponding\nHouseholder vectors and scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\" in its arguments A and tauq or taup.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nstorev      #rocblas_storev.\nSpecifies whether to work column-wise or row-wise.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate transpose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nk           rocblas_int. k >= 0.\nThe number of columns (if storev is column-wise) or rows (if row-wise) of the\noriginal matrix reduced by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nA           pointer to type. Array on the GPU of size lda*min(q,k) if column-wise, or lda*q if row-wise.\nThe Householder vectors as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[in]\nlda         rocblas_int. lda >= q if column-wise, or lda >= min(q,k) if row-wise.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least min(q,k).\nThe Householder scalars as returned by \\ref rocsolver_sgebrd \"GEBRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunmbr(
        handle: rocblas_handle,
        storev: rocblas_storev,
        side: rocblas_side,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        k: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief ORMTR multiplies an orthogonal matrix Q by a general m-by-n matrix C.\n\n\\details\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^TC & \\: \\text{Transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^T & \\: \\text{Transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the orthogonal matrix Q is q = m if applying from the left, or\nq = n if applying from the right.\n\nQ is defined as a product of q-1 Householder reflectors. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(q-1)H(q-2)\\cdots H(1).\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors and scalars as returned by\n\\ref rocsolver_ssytrd \"SYTRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_ssytrd \"SYTRD\" factorization was upper or\nlower triangular. If uplo indicates lower (or upper), then the upper (or\nlower) part of A is not used.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its transpose is to be\napplied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*q.\nOn entry, the Householder vectors as\nreturned by \\ref rocsolver_ssytrd \"SYTRD\".\n@param[in]\nlda         rocblas_int. lda >= q.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least q-1.\nThe Householder scalars as returned by\n\\ref rocsolver_ssytrd \"SYTRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_sormtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dormtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief UNMTR multiplies a unitary matrix Q by a general m-by-n matrix C.\n\n\\details\nThe matrix Q is applied in one of the following forms, depending on\nthe values of side and trans:\n\n\\f[\n\\begin{array}{cl}\nQC & \\: \\text{No transpose from the left,}\\\\\nQ^HC & \\: \\text{Conjugate transpose from the left,}\\\\\nCQ & \\: \\text{No transpose from the right, and}\\\\\nCQ^H & \\: \\text{Conjugate transpose from the right.}\n\\end{array}\n\\f]\n\nThe order q of the unitary matrix Q is q = m if applying from the left, or\nq = n if applying from the right.\n\nQ is defined as a product of q-1 Householder reflectors. If\nuplo indicates upper, then Q has the form\n\n\\f[\nQ = H(q-1)H(q-2)\\cdots H(1).\n\\f]\n\nOn the other hand, if uplo indicates lower, then Q has the form\n\n\\f[\nQ = H(1)H(2)\\cdots H(q-1)\n\\f]\n\nThe Householder matrices \\f$H(i)\\f$ are never stored, they are computed from its\ncorresponding Householder vectors and scalars as returned by\n\\ref rocsolver_chetrd \"HETRD\" in its arguments A and tau.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nside        rocblas_side.\nSpecifies from which side to apply Q.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the \\ref rocsolver_chetrd \"HETRD\" factorization was upper or\nlower triangular. If uplo indicates lower (or upper), then the upper (or\nlower) part of A is not used.\n@param[in]\ntrans       rocblas_operation.\nSpecifies whether the matrix Q or its conjugate\ntranspose is to be applied.\n@param[in]\nm           rocblas_int. m >= 0.\nNumber of rows of matrix C.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of columns of matrix C.\n@param[in]\nA           pointer to type. Array on the GPU of size lda*q.\nOn entry, the Householder vectors as\nreturned by \\ref rocsolver_chetrd \"HETRD\".\n@param[in]\nlda         rocblas_int. lda >= q.\nLeading dimension of A.\n@param[in]\nipiv        pointer to type. Array on the GPU of dimension at least q-1.\nThe Householder scalars as returned by\n\\ref rocsolver_chetrd \"HETRD\".\n@param[inout]\nC           pointer to type. Array on the GPU of size ldc*n.\nOn entry, the matrix C. On exit, it is overwritten with\nQ*C, C*Q, Q'*C, or C*Q'.\n@param[in]\nldc         rocblas_int. ldc >= m.\nLeading dimension of C."]
    pub fn rocsolver_cunmtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zunmtr(
        handle: rocblas_handle,
        side: rocblas_side,
        uplo: rocblas_fill,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief BDSQR computes the singular value decomposition (SVD) of an\nn-by-n bidiagonal matrix B, using the implicit QR algorithm.\n\n\\details\nThe SVD of B has the form:\n\n\\f[\nB = QSP'\n\\f]\n\nwhere S is the n-by-n diagonal matrix of singular values of B, the columns of Q are the left\nsingular vectors of B, and the columns of P are its right singular vectors.\n\nThe computation of the singular vectors is optional; this function accepts input matrices\nU (of size nu-by-n) and V (of size n-by-nv) that are overwritten with \\f$UQ\\f$ and \\f$P'V\\f$. If nu = 0\nno left vectors are computed; if nv = 0 no right vectors are computed.\n\nOptionally, this function can also compute \\f$Q'C\\f$ for a given n-by-nc input matrix C.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether B is upper or lower bidiagonal.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix B.\n@param[in]\nnv          rocblas_int. nv >= 0.\nThe number of columns of matrix V.\n@param[in]\nnu          rocblas_int. nu >= 0.\nThe number of rows of matrix U.\n@param[in]\nnc          rocblas_int. nc >= 0.\nThe number of columns of matrix C.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of B. On exit, if info = 0,\nthe singular values of B in decreasing order; if info > 0,\nthe diagonal elements of a bidiagonal matrix\northogonally equivalent to B.\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of B. On exit, if info > 0,\nthe off-diagonal elements of a bidiagonal matrix\northogonally equivalent to B (if info = 0 this matrix converges to zero).\n@param[inout]\nV           pointer to type. Array on the GPU of dimension ldv*nv.\nOn entry, the matrix V. On exit, it is overwritten with P'*V.\n(Not referenced if nv = 0).\n@param[in]\nldv         rocblas_int. ldv >= n if nv > 0, or ldv >=1 if nv = 0.\nThe leading dimension of V.\n@param[inout]\nU           pointer to type. Array on the GPU of dimension ldu*n.\nOn entry, the matrix U. On exit, it is overwritten with U*Q.\n(Not referenced if nu = 0).\n@param[in]\nldu         rocblas_int. ldu >= nu.\nThe leading dimension of U.\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*nc.\nOn entry, the matrix C. On exit, it is overwritten with Q'*C.\n(Not referenced if nc = 0).\n@param[in]\nldc         rocblas_int. ldc >= n if nc > 0, or ldc >=1 if nc = 0.\nThe leading dimension of C.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i elements of E have not converged to zero."]
    pub fn rocsolver_sbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        V: *mut f32,
        ldv: rocblas_int,
        U: *mut f32,
        ldu: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        V: *mut f64,
        ldv: rocblas_int,
        U: *mut f64,
        ldu: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zbdsqr(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nv: rocblas_int,
        nu: rocblas_int,
        nc: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief STERF computes the eigenvalues of a symmetric tridiagonal matrix.\n\n\\details\nThe eigenvalues of the symmetric tridiagonal matrix are computed by the\nPal-Walker-Kahan variant of the QL/QR algorithm, and returned in\nincreasing order.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the eigenvalues in increasing order.\nIf info > 0, the diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, this array converges to zero.\nIf info > 0, the off-diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, STERF did not converge. i elements of E did not\nconverge to zero."]
    pub fn rocsolver_ssterf(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsterf(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief STEQR computes the eigenvalues and (optionally) eigenvectors of\na symmetric tridiagonal matrix.\n\n\\details\nThe eigenvalues of the symmetric tridiagonal matrix are computed by the\nimplicit QL/QR algorithm, and returned in increasing order.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\nWhen D and E correspond to the tridiagonal form of a full symmetric/Hermitian matrix, as returned by, e.g.,\n\\ref rocsolver_ssytrd \"SYTRD\" or \\ref rocsolver_chetrd \"HETRD\", the eigenvectors of the original matrix can also\nbe computed, depending on the value of evect.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies how the eigenvectors are computed.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the eigenvalues in increasing order.\nIf info > 0, the diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, this array converges to zero.\nIf info > 0, the off-diagonal elements of a tridiagonal matrix\nthat is similar to the original matrix (i.e. has the same\neigenvalues).\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nOn entry, if evect is original, the orthogonal/unitary matrix\nused for the reduction to tridiagonal form as returned by, e.g.,\n\\ref rocsolver_sorgtr \"ORGTR\" or \\ref rocsolver_cungtr \"UNGTR\".\nOn exit, it is overwritten with the eigenvectors of the original\nsymmetric/Hermitian matrix (if evect is original), or the\neigenvectors of the tridiagonal matrix (if evect is tridiagonal).\n(Not referenced if evect is none).\n@param[in]\nldc         rocblas_int. ldc >= n if evect is original or tridiagonal.\nSpecifies the leading dimension of C.\n(Not referenced if evect is none).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, STEQR did not converge. i elements of E did not\nconverge to zero."]
    pub fn rocsolver_ssteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsteqr(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief STEDC computes the eigenvalues and (optionally) eigenvectors of\na symmetric tridiagonal matrix.\n\n\\details\nThis function uses the divide and conquer method to compute the eigenvectors.\nThe eigenvalues are returned in increasing order.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\nWhen D and E correspond to the tridiagonal form of a full symmetric/Hermitian matrix, as returned by, e.g.,\n\\ref rocsolver_ssytrd \"SYTRD\" or \\ref rocsolver_chetrd \"HETRD\", the eigenvectors of the original matrix can also\nbe computed, depending on the value of evect.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies how the eigenvectors are computed.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[inout]\nD           pointer to real type. Array on the GPU of dimension n.\nOn entry, the diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the eigenvalues in increasing order.\n@param[inout]\nE           pointer to real type. Array on the GPU of dimension n-1.\nOn entry, the off-diagonal elements of the tridiagonal matrix.\nOn exit, if info = 0, the values of this array are destroyed.\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nOn entry, if evect is original, the orthogonal/unitary matrix\nused for the reduction to tridiagonal form as returned by, e.g.,\n\\ref rocsolver_sorgtr \"ORGTR\" or \\ref rocsolver_cungtr \"UNGTR\".\nOn exit, if info = 0, it is overwritten with the eigenvectors of the original\nsymmetric/Hermitian matrix (if evect is original), or the\neigenvectors of the tridiagonal matrix (if evect is tridiagonal).\n(Not referenced if evect is none).\n@param[in]\nldc         rocblas_int. ldc >= n if evect is original or tridiagonal.\nSpecifies the leading dimension of C. (Not referenced if evect is none).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, STEDC failed to compute an eigenvalue on the sub-matrix formed by\nthe rows and columns info/(n+1) through mod(info,n+1)."]
    pub fn rocsolver_sstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zstedc(
        handle: rocblas_handle,
        evect: rocblas_evect,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief STEBZ computes a set of eigenvalues of a symmetric tridiagonal matrix T.\n\n\\details\nThis function computes all the eigenvalues of T, all the eigenvalues in the half-open interval (vl, vu],\nor the il-th through iu-th eigenvalues, depending on the value of erange.\n\nThe eigenvalues are returned in increasing order either for the entire matrix, or grouped by independent\ndiagonal blocks (if they exist), depending on the value of eorder.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\neorder      #rocblas_eorder.\nSpecifies whether the computed eigenvalues will be ordered by their position in the\nentire spectrum, or grouped by independent diagonal (split off) blocks.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the tridiagonal matrix T.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest eigenvalue to be computed. Ignored if erange indicates to look\nfor all the eigenvalues of T or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[in]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of the tridiagonal matrix.\n@param[in]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of the tridiagonal matrix.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found.\n@param[out]\nnsplit      pointer to a rocblas_int on the GPU.\nThe number of split off blocks in the matrix.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\niblock      pointer to rocblas_int. Array on the GPU of dimension n.\nThe block indices corresponding to each eigenvalue. When matrix T has\nsplit off blocks (nsplit > 1), then if iblock[i] = k, the\neigenvalue W[i] belongs to the k-th diagonal block from the top.\n@param[out]\nisplit      pointer to rocblas_int. Array on the GPU of dimension n.\nThe splitting indices that divide the tridiagonal matrix into\ndiagonal blocks. The k-th block stretches from the end of the (k-1)-th\nblock (or the top left corner of the tridiagonal matrix,\nin the case of the 1st block) to the isplit[k]-th row/column.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = 1, the bisection did not converge for some eigenvalues, i.e. the returned\nvalues are not as accurate as the given tolerance. The non-converged eigenvalues\nare flagged by negative entries in iblock.\n"]
    pub fn rocsolver_sstebz(
        handle: rocblas_handle,
        erange: rocblas_erange,
        eorder: rocblas_eorder,
        n: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        D: *mut f32,
        E: *mut f32,
        nev: *mut rocblas_int,
        nsplit: *mut rocblas_int,
        W: *mut f32,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dstebz(
        handle: rocblas_handle,
        erange: rocblas_erange,
        eorder: rocblas_eorder,
        n: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        D: *mut f64,
        E: *mut f64,
        nev: *mut rocblas_int,
        nsplit: *mut rocblas_int,
        W: *mut f64,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief STEIN computes the eigenvectors associated with a set of\nprovided eigenvalues of a symmetric tridiagonal matrix.\n\n\\details\nThe eigenvectors of the symmetric tridiagonal matrix are computed using\ninverse iteration.\n\nThe matrix is not represented explicitly, but rather as the array of\ndiagonal elements D and the array of symmetric off-diagonal elements E.\nThe eigenvalues must be provided in the array W, as returned by \\ref rocsolver_sstebz \"STEBZ\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the tridiagonal matrix.\n@param[in]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of the tridiagonal matrix.\n@param[in]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of the tridiagonal matrix.\n@param[in]\nnev         pointer to a rocblas_int on the GPU. 0 <= nev <= n.\nThe number of provided eigenvalues, and the number of eigenvectors\nto be computed.\n@param[in]\nW           pointer to real type. Array on the GPU of dimension >= nev.\nA subset of nev eigenvalues of the tridiagonal matrix, as returned\nby \\ref rocsolver_sstebz \"STEBZ\".\n@param[in]\niblock      pointer to rocblas_int. Array on the GPU of dimension n.\nThe block indices corresponding to each eigenvalue, as\nreturned by \\ref rocsolver_sstebz \"STEBZ\". If iblock[i] = k,\nthen eigenvalue W[i] belongs to the k-th block from the top.\n@param[in]\nisplit      pointer to rocblas_int. Array on the GPU of dimension n.\nThe splitting indices that divide the tridiagonal matrix into\ndiagonal blocks, as returned by \\ref rocsolver_sstebz \"STEBZ\".\nThe k-th block stretches from the end of the (k-1)-th\nblock (or the top left corner of the tridiagonal matrix,\nin the case of the 1st block) to the isplit[k]-th row/column.\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, contains the eigenvectors of the tridiagonal matrix\ncorresponding to the provided eigenvalues, stored by columns.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i eigenvectors did not converge; their indices are stored in\nIFAIL.\n"]
    pub fn rocsolver_sstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zstein(
        handle: rocblas_handle,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        iblock: *mut rocblas_int,
        isplit: *mut rocblas_int,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief BDSVDX computes a set of singular values of a bidiagonal matrix B.\n\n\\details\nThis function computes all the singular values of B, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nDepending on the value of svect, the corresponding singular vectors will be computed and stored as blocks\nin the output matrix Z. That is,\n\n\\f[\nZ = \\left[\\begin{array}{c}\nU\\\\\nV\n\\end{array}\\right]\n\\f]\n\nwhere U contains the corresponding left singular vectors of B, and V contains the corresponding right\nsingular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether B is upper or lower bidiagonal.\n@param[in]\nsvect       #rocblas_svect.\nSpecifies how the singular vectors are computed. Only rocblas_svect_none and\nrocblas_svect_singular are accepted.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the bidiagonal matrix B.\n@param[in]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of the bidiagonal matrix.\n@param[in]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of the bidiagonal matrix.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of B or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of B or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of B or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of B or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to a rocblas_int on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv = n.\nIf srange is rocblas_srange_index, nsv = iu - il + 1. Otherwise, 0 <= nsv <= n.\n@param[out]\nS           pointer to real type. Array on the GPU of dimension nsv.\nThe first nsv elements contain the computed singular values in descending order.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that S is large enough to hold n values.\n@param[out]\nZ           pointer to real type. Array on the GPU of dimension ldz*nsv.\nIf info = 0, the first nsv columns contain the computed singular vectors corresponding to the\nsingular values in S. The first n rows of Z contain the matrix U, and the next n rows contain\nthe matrix V. Not referenced if svect is rocblas_svect_none.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that Z is large enough to hold n columns.\n@param[in]\nldz         rocblas_int. ldz >= 2*n if svect is rocblas_svect_singular; ldz >= 1 otherwise.\nSpecifies the leading dimension of Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nsv elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sstein \"STEIN\".\nNot referenced if svect is rocblas_svect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i eigenvectors did not converge in \\ref rocsolver_sstein \"STEIN\"; their\nindices are stored in ifail.\n"]
    pub fn rocsolver_sbdsvdx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        svect: rocblas_svect,
        srange: rocblas_srange,
        n: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dbdsvdx(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        svect: rocblas_svect,
        srange: rocblas_srange,
        n: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETF2_NPVT computes the LU factorization of a general m-by-n matrix A\nwithout partial pivoting.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = LU\n\\f]\n\nwhere L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\n\\note\nAlthough this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK API \\ref rocsolver_sgetf2 \"GETF2\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete."]
    pub fn rocsolver_sgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetf2_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETF2_NPVT_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices without partial pivoting.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n\\note\nAlthough this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK API \\ref rocsolver_sgetf2_batched \"GETF2_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[in,out]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetf2_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETF2_NPVT_STRIDED_BATCHED computes the LU factorization of a batch\nof general m-by-n matrices without partial pivoting.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n\\note\nAlthough this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetf2_strided_batched \"GETF2_STRIDED_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetf2_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRF_NPVT computes the LU factorization of a general m-by-n matrix A\nwithout partial pivoting.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = LU\n\\f]\n\nwhere L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\nNote: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetrf \"GETRF\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete."]
    pub fn rocsolver_sgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_npvt(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrf_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_npvt_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRF_NPVT_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices without partial pivoting.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\nNote: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch.\n"]
    pub fn rocsolver_sgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_npvt_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrf_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_npvt_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRF_NPVT_STRIDED_BATCHED computes the LU factorization of a batch\nof general m-by-n matrices without partial pivoting.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = L_lU_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\nNote: Although this routine can offer better performance, Gaussian elimination without pivoting is not backward stable.\nIf numerical accuracy is compromised, use the legacy-LAPACK-like API \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\" routines instead.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero element in the diagonal. The factorization from\nthis point might be incomplete.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch.\n"]
    pub fn rocsolver_sgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_npvt_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrf_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_npvt_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETF2 computes the LU factorization of a general m-by-n matrix A\nusing partial pivoting with row interchanges.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = PLU\n\\f]\n\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension min(m,n).\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= i <= min(m,n), the row i of the\nmatrix was interchanged with row ipiv[i].\nMatrix P of the factorization can be derived from ipiv.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetf2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETF2_BATCHED computes the LU factorization of a batch of general\nm-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivot indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetf2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETF2_STRIDED_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the unblocked Level-2-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with small and mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivots indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetf2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetf2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetf2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetf2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRF computes the LU factorization of a general m-by-n matrix A\nusing partial pivoting with row interchanges.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization has the form\n\n\\f[\nA = PLU\n\\f]\n\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension min(m,n).\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= i <= min(m,n), the row i of the\nmatrix was interchanged with row ipiv[i].\nMatrix P of the factorization can be derived from ipiv.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRF_BATCHED computes the LU factorization of a batch of general\nm-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorizations.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivot indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRF_STRIDED_BATCHED computes the LU factorization of a batch of\ngeneral m-by-n matrices using partial pivoting with row interchanges.\n\n\\details\n(This is the blocked Level-3-BLAS version of the algorithm. An optimized internal implementation without rocBLAS calls\ncould be executed with mid-size matrices if optimizations are enabled (default option). For more details, see the\n\"Tuning rocSOLVER performance\" section of the Library Design Guide).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = P_lL_lU_l\n\\f]\n\nwhere \\f$P_l\\f$ is a permutation matrix, \\f$L_l\\f$ is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and \\f$U_l\\f$ is upper\ntriangular (upper trapezoidal if m < n).\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the factors L_l and U_l from the factorization.\nThe unit diagonal elements of L_l are not stored.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors of pivots indices ipiv_l (corresponding to A_l).\nDimension of ipiv_l is min(m,n).\nElements of ipiv_l are 1-based indices.\nFor each instance A_l in the batch and for 1 <= i <= min(m,n), the row i of the\nmatrix A_l was interchanged with row ipiv_l[i].\nMatrix P_l of the factorization can be derived from ipiv_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= min(m,n).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut i64,
        strideP: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQR2 computes a QR factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\nR\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)H(2)\\cdots H(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R; the elements below the diagonal are the last m - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqr2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgeqr2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqr2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqr2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqr2_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQR2_BATCHED computes the QR factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqr2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgeqr2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqr2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqr2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqr2_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQR2_STRIDED_BATCHED computes the QR factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqr2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgeqr2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqr2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqr2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqr2_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GERQ2 computes a RQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\n0 & R\n\\end{array}\\right] Q\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)'H(2)' \\cdots H(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgerq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GERQ2_BATCHED computes the RQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgerq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GERQ2_STRIDED_BATCHED computes the RQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgerq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQL2 computes a QL factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\n0\\\\\nL\n\\end{array}\\right]\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeql2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQL2_BATCHED computes the QL factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeql2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQL2_STRIDED_BATCHED computes the QL factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeql2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELQ2 computes a LQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\nL & 0\n\\end{array}\\right] Q\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)'H(k-1)' \\cdots H(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i' v_i^{}\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L; the elements above the diagonal are the last n - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgelq2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELQ2_BATCHED computes the LQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgelq2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELQ2_STRIDED_BATCHED computes the LQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle    rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgelq2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQRF computes a QR factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\nR\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)H(2)\\cdots H(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R; the elements below the diagonal are the last m - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqrf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgeqrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqrf_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQRF_BATCHED computes the QR factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqrf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgeqrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqrf_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQRF_STRIDED_BATCHED computes the QR factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\nR_l\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)H_l(2)\\cdots H_l(k), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_l. The elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqrf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgeqrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqrf_strided_batched_64(
        handle: rocblas_handle,
        m: i64,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GERQF computes a RQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\n0 & R\n\\end{array}\\right] Q\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(1)'H(2)' \\cdots H(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgerqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GERQF_BATCHED computes the RQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgerqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GERQF_STRIDED_BATCHED computes the RQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\n0 & R_l\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$R_l\\f$ is upper triangular (upper trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(1)'H_l(2)' \\cdots H_l(k)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last n-i elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and above the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor R_l; the elements below the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgerqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQLF computes a QL factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\n0\\\\\nL\n\\end{array}\\right]\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)H(k-1)\\cdots H(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i^{} v_i'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqlf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQLF_BATCHED computes the QL factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqlf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEQLF_STRIDED_BATCHED computes the QL factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = Q_l\\left[\\begin{array}{c}\n0\\\\\nL_l\n\\end{array}\\right]\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m < n), and \\f$Q_l\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)H_l(k-1)\\cdots H_l(1), \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}'\n\\f]\n\nwhere the last m-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the (m-n)-th subdiagonal (when\nm >= n) or the (n-m)-th superdiagonal (when n > m) contain the\nfactor L_l; the elements above the sub/superdiagonal are the first i - 1\nelements of Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeqlf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELQF computes a LQ factorization of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\nA = \\left[\\begin{array}{cc}\nL & 0\n\\end{array}\\right] Q\n\\f]\n\nwhere L is lower triangular (lower trapezoidal if m > n), and Q is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H(k)'H(k-1)' \\cdots H(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{ipiv}[i] \\cdot v_i' v_i^{}\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L; the elements above the diagonal are the last n - i elements\nof Householder vector v_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars."]
    pub fn rocsolver_sgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgelqf(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELQF_BATCHED computes the LQ factorization of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgelqf_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELQF_STRIDED_BATCHED computes the LQ factorization of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form\n\n\\f[\nA_l = \\left[\\begin{array}{cc}\nL_l & 0\n\\end{array}\\right] Q_l\n\\f]\n\nwhere \\f$L_l\\f$ is lower triangular (lower trapezoidal if m > n), and \\f$Q_l\\f$ is\na n-by-n orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_l = H_l(k)'H_l(k-1)' \\cdots H_l(1)', \\quad \\text{with} \\: k = \\text{min}(m,n).\n\\f]\n\nEach Householder matrices \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{ipiv}_l^{}[i] \\cdot v_{l_i}' v_{l_i}^{}\n\\f]\n\nwhere the first i-1 elements of Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on and below the diagonal contain the\nfactor L_l. The elements above the diagonal are the last n - i elements\nof Householder vector v_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgelqf_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBD2 computes the bidiagonal form of a general m-by-n matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe bidiagonal form is given by:\n\n\\f[\nB = Q'  A  P\n\\f]\n\nwhere B is upper bidiagonal if m >= n and lower bidiagonal if m < n, and Q and\nP are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ = H(1)H(2)\\cdots H(m-1)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ and \\f$G(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH(i) = I - \\text{tauq}[i] \\cdot v_i^{} v_i', & \\: \\text{and}\\\\\nG(i) = I - \\text{taup}[i] \\cdot u_i' u_i^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_i, and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_i.\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_i, and the elements above the\ndiagonal are the last n - i elements of Householder vector u_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nspecifies the leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension min(m,n).\nThe diagonal elements of B.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension min(m,n)-1.\nThe off-diagonal elements of B.\n@param[out]\ntauq        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix Q.\n@param[out]\ntaup        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix P."]
    pub fn rocsolver_sgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut rocblas_float_complex,
        taup: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgebd2(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut rocblas_double_complex,
        taup: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBD2_BATCHED computes the bidiagonal form of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgebd2_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBD2_STRIDED_BATCHED computes the bidiagonal form of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_1 = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_1 = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgebd2_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBRD computes the bidiagonal form of a general m-by-n matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe bidiagonal form is given by:\n\n\\f[\nB = Q'  A  P\n\\f]\n\nwhere B is upper bidiagonal if m >= n and lower bidiagonal if m < n, and Q and\nP are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ = H(1)H(2)\\cdots H(m-1)\\:  \\text{and} \\: P = G(1)G(2)\\cdots G(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ and \\f$G(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH(i) = I - \\text{tauq}[i] \\cdot v_i^{} v_i', & \\: \\text{and}\\\\\nG(i) = I - \\text{taup}[i] \\cdot u_i' u_i^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_i\\f$ are zero, and \\f$u_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of the matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_i, and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_i.\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_i, and the elements above the\ndiagonal are the last n - i elements of Householder vector u_i.\n@param[in]\nlda         rocblas_int. lda >= m.\nspecifies the leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension min(m,n).\nThe diagonal elements of B.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension min(m,n)-1.\nThe off-diagonal elements of B.\n@param[out]\ntauq        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix Q.\n@param[out]\ntaup        pointer to type. Array on the GPU of dimension min(m,n).\nThe Householder scalars associated with matrix P."]
    pub fn rocsolver_sgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut f32,
        taup: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut f64,
        taup: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tauq: *mut rocblas_float_complex,
        taup: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgebrd(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tauq: *mut rocblas_double_complex,
        taup: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBRD_BATCHED computes the bidiagonal form of a batch of general\nm-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgebrd_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBRD_STRIDED_BATCHED computes the bidiagonal form of a batch of\ngeneral m-by-n matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the bidiagonal form is given by:\n\n\\f[\nB_l^{} = Q_l'  A_l^{}  P_l^{}\n\\f]\n\nwhere \\f$B_l\\f$ is upper bidiagonal if m >= n and lower bidiagonal if m < n, and \\f$Q_l\\f$ and\n\\f$P_l\\f$ are orthogonal/unitary matrices represented as the product of Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(n-1), & \\: \\text{if}\\: m >= n, \\:\\text{or}\\\\\nQ_l = H_l(1)H_l(2)\\cdots H_l(m-1)\\:  \\text{and} \\: P_l = G_l(1)G_l(2)\\cdots G_l(m), & \\: \\text{if}\\: m < n.\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ and \\f$G_l(i)\\f$ is given by\n\n\\f[\n\\begin{array}{cl}\nH_l^{}(i) = I - \\text{tauq}_l^{}[i] \\cdot v_{l_i}^{} v_{l_i}', & \\: \\text{and}\\\\\nG_l^{}(i) = I - \\text{taup}_l^{}[i] \\cdot u_{l_i}' u_{l_i}^{}.\n\\end{array}\n\\f]\n\nIf m >= n, the first i-1 elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$;\nwhile the first i elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i+1] = 1\\f$.\nIf m < n, the first i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$;\nwhile the first i-1 elements of the Householder vector \\f$u_{l_i}\\f$ are zero, and \\f$u_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all the matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all the matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the m-by-n matrices A_l to be factored.\nOn exit, the elements on the diagonal and superdiagonal (if m >= n), or\nsubdiagonal (if m < n) contain the bidiagonal form B_l.\nIf m >= n, the elements below the diagonal are the last m - i elements\nof Householder vector v_(l_i), and the elements above the\nsuperdiagonal are the last n - i - 1 elements of Householder vector u_(l_i).\nIf m < n, the elements below the subdiagonal are the last m - i - 1\nelements of Householder vector v_(l_i), and the elements above the\ndiagonal are the last n - i elements of Householder vector u_(l_i).\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of B_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= min(m,n).\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of B_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[out]\ntauq        pointer to type. Array on the GPU (the size depends on the value of strideQ).\nContains the vectors tauq_l of Householder scalars associated with matrices Q_l.\n@param[in]\nstrideQ     rocblas_stride.\nStride from the start of one vector tauq_l to the next one tauq_(l+1).\nThere is no restriction for the value\nof strideQ. Normal use is strideQ >= min(m,n).\n@param[out]\ntaup        pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors taup_l of Householder scalars associated with matrices P_l.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector taup_l to the next one taup_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut f32,
        strideQ: rocblas_stride,
        taup: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut f64,
        strideQ: rocblas_stride,
        taup: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tauq: *mut rocblas_float_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgebrd_strided_batched(
        handle: rocblas_handle,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tauq: *mut rocblas_double_complex,
        strideQ: rocblas_stride,
        taup: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRS solves a system of n linear equations on n variables in its factorized form.\n\n\\details\nIt solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed,}\\\\\nA^T X = B & \\: \\text{transposed, or}\\\\\nA^H X = B & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix A is defined by its triangular factors as returned by \\ref rocsolver_sgetrf \"GETRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factors L and U of the factorization A = P*L*U returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B."]
    pub fn rocsolver_sgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrs(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrs_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut f32,
        lda: i64,
        ipiv: *const i64,
        B: *mut f32,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrs_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut f64,
        lda: i64,
        ipiv: *const i64,
        B: *mut f64,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrs_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        ipiv: *const i64,
        B: *mut rocblas_float_complex,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrs_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        ipiv: *const i64,
        B: *mut rocblas_double_complex,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRS_BATCHED solves a batch of systems of n linear equations on n\nvariables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed,}\\\\\nA_l^T X_l^{} = B_l^{} & \\: \\text{transposed, or}\\\\\nA_l^H X_l^{} = B_l^{} & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_l\\f$ is defined by its triangular factors as returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrs_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrs_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *const *mut f32,
        lda: i64,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *const *mut f32,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrs_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *const *mut f64,
        lda: i64,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *const *mut f64,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrs_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *const *mut rocblas_float_complex,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrs_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *const *mut rocblas_double_complex,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRS_STRIDED_BATCHED solves a batch of systems of n linear equations\non n variables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed,}\\\\\nA_l^T X_l^{} = B_l^{} & \\: \\text{transposed, or}\\\\\nA_l^H X_l^{} = B_l^{} & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_l\\f$ is defined by its triangular factors as returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nContains the vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrs_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *const rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_sgetrs_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *mut f32,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetrs_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *mut f64,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetrs_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetrs_strided_batched_64(
        handle: rocblas_handle,
        trans: rocblas_operation,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        ipiv: *const i64,
        strideP: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESV solves a general system of n linear equations on n variables.\n\n\\details\nThe linear system is of the form\n\n\\f[\nA X = B\n\\f]\n\nwhere A is a general n-by-n matrix. Matrix A is first factorized in triangular factors L and U\nusing \\ref rocsolver_sgetrf \"GETRF\"; then, the solution is computed with \\ref rocsolver_sgetrs \"GETRS\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, if info = 0, the factors L and U of the LU decomposition of A returned by\n\\ref rocsolver_sgetrf \"GETRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular, and the solution could not be computed.\nU[i,i] is the first zero element in the diagonal."]
    pub fn rocsolver_sgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesv(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESV_BATCHED solves a batch of general systems of n linear equations on n\nvariables.\n\n\\details\nThe linear systems are of the form\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a general n-by-n matrix. Matrix \\f$A_l\\f$ is first factorized in triangular factors \\f$L_l\\f$ and \\f$U_l\\f$\nusing \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\"; then, the solutions are computed with \\ref rocsolver_sgetrs_batched \"GETRS_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, if info[l] = 0, the factors L_l and U_l of the LU decomposition of A_l returned by\n\\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for A_l.\nIf info[l] = i > 0, U_l is singular, and the solution could not be computed.\nU_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesv_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESV_STRIDED_BATCHED solves a batch of general systems of n linear equations\non n variables.\n\n\\details\nThe linear systems are of the form\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a general n-by-n matrix. Matrix \\f$A_l\\f$ is first factorized in triangular factors \\f$L_l\\f$ and \\f$U_l\\f$\nusing \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\"; then, the solutions are computed with\n\\ref rocsolver_sgetrs_strided_batched \"GETRS_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, if info[l] = 0, the factors L_l and U_l of the LU decomposition of A_l returned by\n\\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[inout]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe vectors ipiv_l of pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for A_l.\nIf info[l] = i > 0, U_l is singular, and the solution could not be computed.\nU_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesv_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI inverts a general n-by-n matrix A using the LU factorization\ncomputed by \\ref rocsolver_sgetrf \"GETRF\".\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA^{-1}L = U^{-1}\n\\f]\n\nwhere L is the lower triangular factor of A with unit diagonal elements, and U is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the factors L and U of the factorization A = P*L*U returned by \\ref rocsolver_sgetrf \"GETRF\".\nOn exit, the inverse of A if info = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_BATCHED inverts a batch of general n-by-n matrices using\nthe LU factorization computed by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by\n\\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+j).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_STRIDED_BATCHED inverts a batch of general n-by-n matrices\nusing the LU factorization computed by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by\n\\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_NPVT inverts a general n-by-n matrix A using the LU factorization\ncomputed by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA^{-1}L = U^{-1}\n\\f]\n\nwhere L is the lower triangular factor of A with unit diagonal elements, and U is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the factors L and U of the factorization A = L*U returned by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\nOn exit, the inverse of A if info = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_npvt(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_NPVT_BATCHED inverts a batch of general n-by-n matrices using\nthe LU factorization computed by \\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the factors L_l and U_l of the factorization A_l = L_l*U_l returned by\n\\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_npvt_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_NPVT_STRIDED_BATCHED inverts a batch of general n-by-n matrices\nusing the LU factorization computed by \\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed by solving the linear system\n\n\\f[\nA_l^{-1} L_l^{} = U_l^{-1}\n\\f]\n\nwhere \\f$L_l\\f$ is the lower triangular factor of \\f$A_l\\f$ with unit diagonal elements, and \\f$U_l\\f$ is the\nupper triangular factor.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the factors L_l and U_l of the factorization A_l = L_l*U_l returned by\n\\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0; otherwise undefined.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_npvt_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n\nmatrix A, and a corresponding matrix B, using the QR factorization computed by \\ref rocsolver_sgeqrf \"GEQRF\" (or the LQ\nfactorization computed by \\ref rocsolver_sgelqf \"GELQF\").\n\n\\details\nDepending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed, or}\\\\\nA' X = B & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X is found by minimizing\n\n\\f[\n|| B - A  X || \\quad \\text{(or} \\: || B - A' X ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X is chosen such that \\f$|| X ||\\f$ is minimal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of columns of matrices B and X;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, the QR (or LQ) factorization of A as returned by \\ref rocsolver_sgeqrf \"GEQRF\" (or \\ref rocsolver_sgelqf \"GELQF\").\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the matrix B.\nOn exit, when info = 0, B is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         rocblas_int. ldb >= max(m,n).\nSpecifies the leading dimension of matrix B.\n@param[out]\ninfo        pointer to rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the solution could not be computed because input matrix A is\nrank deficient; the i-th diagonal element of its triangular factor is zero."]
    pub fn rocsolver_sgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgels(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELS_BATCHED solves a batch of overdetermined (or underdetermined) linear systems\ndefined by a set of m-by-n matrices \\f$A_l\\f$, and corresponding matrices \\f$B_l\\f$, using the\nQR factorizations computed by \\ref rocsolver_sgeqrf_batched \"GEQRF_BATCHED\" (or the LQ factorizations computed by \\ref rocsolver_sgelqf_batched \"GELQF_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed, or}\\\\\nA_l' X_l^{} = B_l^{} & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_l is found by minimizing\n\n\\f[\n|| B_l - A_l  X_l || \\quad \\text{(or} \\: || B_l^{} - A_l' X_l^{} ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_l is chosen such that \\f$|| X_l ||\\f$ is minimal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of columns of all matrices B_l and X_l in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           array of pointer to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, the QR (or LQ) factorizations of A_l as returned by \\ref rocsolver_sgeqrf_batched \"GEQRF_BATCHED\"\n(or \\ref rocsolver_sgelqf_batched \"GELQF_BATCHED\").\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[inout]\nB           array of pointer to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the matrices B_l.\nOn exit, when info[l] = 0, B_l is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         rocblas_int. ldb >= max(m,n).\nSpecifies the leading dimension of matrices B_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for solution of A_l.\nIf info[l] = i > 0, the solution of A_l could not be computed because input\nmatrix A_l is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgels_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GELS_STRIDED_BATCHED solves a batch of overdetermined (or underdetermined) linear\nsystems defined by a set of m-by-n matrices \\f$A_l\\f$, and corresponding matrices \\f$B_l\\f$,\nusing the QR factorizations computed by \\ref rocsolver_sgeqrf_strided_batched \"GEQRF_STRIDED_BATCHED\"\n(or the LQ factorizations computed by \\ref rocsolver_sgelqf_strided_batched \"GELQF_STRIDED_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = B_l & \\: \\text{not transposed, or}\\\\\nA_l' X_l^{} = B_l^{} & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_l is found by minimizing\n\n\\f[\n|| B_l - A_l  X_l || \\quad \\text{(or} \\: || B_l^{} - A_l' X_l^{} ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_l is chosen such that \\f$|| X_l ||\\f$ is minimal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\ntrans       rocblas_operation.\nSpecifies the form of the system of equations.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of columns of all matrices B_l and X_l in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, the QR (or LQ) factorizations of A_l as returned by \\ref rocsolver_sgeqrf_strided_batched \"GEQRF_STRIDED_BATCHED\"\n(or \\ref rocsolver_sgelqf_strided_batched \"GELQF_STRIDED_BATCHED\").\n@param[in]\nlda         rocblas_int. lda >= m.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the matrices B_l.\nOn exit, when info[l] = 0, each B_l is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         rocblas_int. ldb >= max(m,n).\nSpecifies the leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for solution of A_l.\nIf info[l] = i > 0, the solution of A_l could not be computed because input\nmatrix A_l is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgels_strided_batched(
        handle: rocblas_handle,
        trans: rocblas_operation,
        m: rocblas_int,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTF2 computes the Cholesky factorization of a real symmetric (complex\nHermitian) positive definite matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form:\n\n\\f[\n\\begin{array}{cl}\nA = U'U & \\: \\text{if uplo is upper, or}\\\\\nA = LL' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nU is an upper triangular matrix and L is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A to be factored. On exit, the lower or upper triangular factor.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful factorization of matrix A.\nIf info = i > 0, the leading minor of order i of A is not positive definite.\nThe factorization stopped at this point."]
    pub fn rocsolver_spotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotf2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f32,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotf2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f64,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotf2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotf2_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTF2_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotf2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotf2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotf2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotf2_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTF2_STRIDED_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA    rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotf2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotf2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotf2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotf2_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRF computes the Cholesky factorization of a real symmetric (complex\nHermitian) positive definite matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form:\n\n\\f[\n\\begin{array}{cl}\nA = U'U & \\: \\text{if uplo is upper, or}\\\\\nA = LL' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nU is an upper triangular matrix and L is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A to be factored. On exit, the lower or upper triangular factor.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful factorization of matrix A.\nIf info = i > 0, the leading minor of order i of A is not positive definite.\nThe factorization stopped at this point."]
    pub fn rocsolver_spotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotrf_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f32,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrf_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f64,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrf_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrf_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRF_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotrf_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut f32,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrf_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut f64,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrf_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrf_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRF_STRIDED_BATCHED computes the Cholesky factorization of a\nbatch of real symmetric (complex Hermitian) positive definite matrices.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization of matrix \\f$A_l\\f$ in the batch has the form:\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\n\\f$U_l\\f$ is an upper triangular matrix and \\f$L_l\\f$ is lower triangular.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored. On exit, the upper or lower triangular factors.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful factorization of matrix A_l.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th factorization stopped at this point.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotrf_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrf_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrf_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrf_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        info: *mut i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRS solves a symmetric/hermitian system of n linear equations on n variables in its factorized form.\n\n\\details\nIt solves the system\n\n\\f[\nA X = B\n\\f]\n\nwhere A is a real symmetric (complex hermitian) positive definite matrix defined by its triangular factor\n\n\\f[\n\\begin{array}{cl}\nA = U'U & \\: \\text{if uplo is upper, or}\\\\\nA = LL' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nas returned by \\ref rocsolver_spotrf \"POTRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factor L or U of the Cholesky factorization of A returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B."]
    pub fn rocsolver_spotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrs(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotrs_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut f32,
        lda: i64,
        B: *mut f32,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrs_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut f64,
        lda: i64,
        B: *mut f64,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrs_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        B: *mut rocblas_float_complex,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrs_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        B: *mut rocblas_double_complex,
        ldb: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRS_BATCHED solves a batch of symmetric/hermitian systems of n linear equations on n\nvariables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix defined by its\ntriangular factor\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nas returned by \\ref rocsolver_spotrf \"POTRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factor L_l or U_l of the Cholesky factorization of A_l returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_spotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrs_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotrs_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *const *mut f32,
        lda: i64,
        B: *const *mut f32,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrs_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *const *mut f64,
        lda: i64,
        B: *const *mut f64,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrs_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *const *mut rocblas_float_complex,
        lda: i64,
        B: *const *mut rocblas_float_complex,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrs_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *const *mut rocblas_double_complex,
        lda: i64,
        B: *const *mut rocblas_double_complex,
        ldb: i64,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRS_STRIDED_BATCHED solves a batch of symmetric/hermitian systems of n linear equations\non n variables in its factorized forms.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix defined by its\ntriangular factor\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l'U_l^{} & \\: \\text{if uplo is upper, or}\\\\\nA_l^{} = L_l^{}L_l' & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nas returned by \\ref rocsolver_spotrf \"POTRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factor L_l or U_l of the Cholesky factorization of A_l returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_spotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrs_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_spotrs_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut f32,
        lda: i64,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotrs_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut f64,
        lda: i64,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotrs_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_float_complex,
        lda: i64,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotrs_strided_batched_64(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: i64,
        nrhs: i64,
        A: *mut rocblas_double_complex,
        lda: i64,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: i64,
        strideB: rocblas_stride,
        batch_count: i64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POSV solves a symmetric/hermitian system of n linear equations on n variables.\n\n\\details\nIt solves the system\n\n\\f[\nA X = B\n\\f]\n\nwhere A is a real symmetric (complex hermitian) positive definite matrix. Matrix A is first\nfactorized as \\f$A=LL'\\f$ or \\f$A=U'U\\f$, depending on the value of uplo, using \\ref rocsolver_spotrf \"POTRF\";\nthen, the solution is computed with \\ref rocsolver_spotrs \"POTRS\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric/hermitian matrix A.\nOn exit, if info = 0, the factor L or U of the Cholesky factorization of A returned by\n\\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the leading minor of order i of A is not positive definite.\nThe solution could not be computed."]
    pub fn rocsolver_sposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zposv(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POSV_BATCHED solves a batch of symmetric/hermitian systems of n linear equations on n\nvariables.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix. Matrix \\f$A_l\\f$ is first\nfactorized as \\f$A_l^{}=L_l^{}L_l'\\f$ or \\f$A_l^{}=U_l'U_l^{}\\f$, depending on the value of uplo, using \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\";\nthen, the solution is computed with \\ref rocsolver_spotrs_batched \"POTRS_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric/hermitian matrices A_l.\nOn exit, if info[l] = 0, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[inout]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th solution could not be computed.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zposv_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POSV_STRIDED_BATCHED solves a batch of symmetric/hermitian systems of n linear equations\non n variables.\n\n\\details\nFor each instance l in the batch, it solves the system\n\n\\f[\nA_l X_l = B_l\n\\f]\n\nwhere \\f$A_l\\f$ is a real symmetric (complex hermitian) positive definite matrix. Matrix \\f$A_l\\f$ is first\nfactorized as \\f$A_l^{}=L_l^{}L_l'\\f$ or \\f$A_l^{}=U_l'U_l^{}\\f$, depending on the value of uplo, using \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\";\nthen, the solution is computed with \\ref rocsolver_spotrs_strided_batched \"POTRS_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe order of the system, i.e. the number of columns and rows of all A_l matrices.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric/hermitian matrices A_l.\nOn exit, if info[l] = 0, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\nOn entry, the right hand side matrices B_l.\nOn exit, the solution matrix X_l of each system in the batch.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, the leading minor of order i of A_l is not positive definite.\nThe l-th solution could not be computed.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of instances (systems) in the batch."]
    pub fn rocsolver_sposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zposv_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRI inverts a symmetric/hermitian positive definite matrix A.\n\n\\details\nThe inverse of matrix \\f$A\\f$ is computed as\n\n\\f[\n\\begin{array}{cl}\nA^{-1} = U^{-1} {U^{-1}}' & \\: \\text{if uplo is upper, or}\\\\\nA^{-1} = {L^{-1}}' L^{-1} & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nwhere \\f$U\\f$ or \\f$L\\f$ is the triangular factor of the Cholesky factorization of \\f$A\\f$ returned by\n\\ref rocsolver_spotrf \"POTRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the factor L or U of the Cholesky factorization of A returned by\n\\ref rocsolver_spotrf \"POTRF\".\nOn exit, the inverse of A if info = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit for inversion of A.\nIf info = i > 0, A is singular. L[i,i] or U[i,i] is zero."]
    pub fn rocsolver_spotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRI_BATCHED inverts a batch of symmetric/hermitian positive definite matrices \\f$A_l\\f$.\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed as\n\n\\f[\n\\begin{array}{cl}\nA_l^{-1} = U_l^{-1} {U_l^{-1}}' & \\: \\text{if uplo is upper, or}\\\\\nA_l^{-1} = {L_l^{-1}}' L_l^{-1} & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is the triangular factor of the Cholesky factorization of \\f$A_l\\f$ returned by\n\\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. L_l[i,i] or U_l[i,i] is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief POTRI_STRIDED_BATCHED inverts a batch of symmetric/hermitian positive definite matrices \\f$A_l\\f$.\n\n\\details\nThe inverse of matrix \\f$A_l\\f$ in the batch is computed as\n\n\\f[\n\\begin{array}{cl}\nA_l^{-1} = U_l^{-1} {U_l^{-1}}' & \\: \\text{if uplo is upper, or}\\\\\nA_l^{-1} = {L_l^{-1}}' L_l^{-1} & \\: \\text{if uplo is lower.}\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is the triangular factor of the Cholesky factorization of \\f$A_l\\f$ returned by\n\\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the factorization is upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the factor L_l or U_l of the Cholesky factorization of A_l returned by\n\\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. L_l[i,i] or U_l[i,i] is zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_spotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dpotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cpotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zpotri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVD computes the singular values and optionally the singular\nvectors of a general m-by-n matrix A (Singular Value Decomposition).\n\n\\details\nThe SVD of matrix A is given by:\n\n\\f[\nA = U  S  V'\n\\f]\n\nwhere the m-by-n matrix S is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of A. U and V are orthogonal\n(unitary) matrices. The first min(m,n) columns of U and V are the left and\nright singular vectors of A, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of V'.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix U (or V') is computed,\n- rocblas_svect_singular: only the singular vectors (first min(m,n)\ncolumns of U or rows of V') are computed,\n- rocblas_svect_overwrite: the first\ncolumns (or rows) of A are overwritten with the singular vectors, or\n- rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.\nno singular vectors.\n\nleft_svect and right_svect cannot both be set to overwrite. When neither is\nset to overwrite, the contents of A are destroyed by the time the function\nreturns.\n\n\\note\nWhen m >> n (or n >> m) the algorithm could be sped up by compressing\nthe matrix A via a QR (or LQ) factorization, and working with the triangular\nfactor afterwards (thin-SVD). If the singular vectors are also requested, its\ncomputation could be sped up as well via executing some intermediate\noperations out-of-place, and relying more on matrix multiplications (GEMMs);\nthis will require, however, a larger memory workspace. The parameter fast_alg\ncontrols whether the fast algorithm is executed or not. For more details, see\nthe \"Tuning rocSOLVER performance\" and \"Memory model\" sections of the documentation.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, if left_svect (or right_svect) is equal to overwrite,\nthe first columns (or rows) contain the left (or right) singular vectors;\notherwise, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A.\n@param[out]\nS           pointer to real type. Array on the GPU of dimension min(m,n).\nThe singular values of A in decreasing order.\n@param[out]\nU           pointer to type. Array on the GPU of dimension ldu*min(m,n) if\nleft_svect is set to singular, or ldu*m when left_svect is equal to all.\nThe matrix of left singular vectors stored as columns. Not\nreferenced if left_svect is set to overwrite or none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.\nThe leading dimension of U.\n@param[out]\nV           pointer to type. Array on the GPU of dimension ldv*n.\nThe matrix of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to overwrite or none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension min(m,n)-1.\nThis array is used to work internally with the bidiagonal matrix\nB associated with A (using \\ref rocsolver_sbdsqr \"BDSQR\"). On exit, if info > 0, it contains the\nunconverged off-diagonal elements of B (or properly speaking, a bidiagonal\nmatrix orthogonally equivalent to B). The diagonal elements of this matrix\nare in S; those that converged correspond to a subset of the singular values\nof A (not necessarily ordered).\n@param[in]\nfast_alg    #rocblas_workmode.\nIf set to rocblas_outofplace, the function will execute the\nfast thin-SVD version of the algorithm when possible.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, \\ref rocsolver_sbdsqr \"BDSQR\" did not converge. i elements of E did not converge to zero."]
    pub fn rocsolver_sgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        S: *mut f32,
        U: *mut f32,
        ldu: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        E: *mut f32,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        S: *mut f64,
        U: *mut f64,
        ldu: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        E: *mut f64,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        S: *mut f32,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        E: *mut f32,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvd(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        S: *mut f64,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        E: *mut f64,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVD_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrices A_l (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l^{} = U_l^{}  S_l^{}  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: only the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed,\n- rocblas_svect_overwrite: the\nfirst columns (or rows) of \\f$A_l\\f$ are overwritten with the singular vectors, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nleft_svect and right_svect cannot both be set to overwrite. When neither is\nset to overwrite, the contents of \\f$A_l\\f$ are destroyed by the time the function\nreturns.\n\n\\note\nWhen m >> n (or n >> m) the algorithm could be sped up by compressing\nthe matrix \\f$A_l\\f$ via a QR (or LQ) factorization, and working with the\ntriangular factor afterwards (thin-SVD). If the singular vectors are also\nrequested, its computation could be sped up as well via executing some\nintermediate operations out-of-place, and relying more on matrix\nmultiplications (GEMMs); this will require, however, a larger memory\nworkspace. The parameter fast_alg controls whether the fast algorithm is\nexecuted or not. For more details, see the \"Tuning rocSOLVER performance\"\nand \"Memory model\" sections of the documentation.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on\nthe GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, if left_svect (or right_svect) is equal to overwrite,\nthe first columns (or rows) of A_l contain the left (or right)\ncorresponding singular vectors; otherwise, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to overwrite or none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to overwrite or none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if\nright_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the bidiagonal matrix B_l associated with A_l (using \\ref rocsolver_sbdsqr \"BDSQR\").\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of B_l (or properly speaking,\na bidiagonal matrix orthogonally equivalent to B_l). The diagonal elements of this matrix are in S_l;\nthose that converged correspond to a subset of the singular values of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= min(m,n)-1.\n@param[in]\nfast_alg    #rocblas_workmode.\nIf set to rocblas_outofplace, the function will execute the fast thin-SVD version\nof the algorithm when possible.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, \\ref rocsolver_sbdsqr \"BDSQR\" did not converge. i elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvd_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVD_STRIDED_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrices A_l (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l^{} = U_l^{}  S_l^{}  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: only the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed,\n- rocblas_svect_overwrite: the\nfirst columns (or rows) of \\f$A_l\\f$ are overwritten with the singular vectors, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nleft_svect and right_svect cannot both be set to overwrite. When neither is\nset to overwrite, the contents of \\f$A_l\\f$ are destroyed by the time the function\nreturns.\n\n\\note\nWhen m >> n (or n >> m) the algorithm could be sped up by compressing\nthe matrix \\f$A_l\\f$ via a QR (or LQ) factorization, and working with the\ntriangular factor afterwards (thin-SVD). If the singular vectors are also\nrequested, its computation could be sped up as well via executing some\nintermediate operations out-of-place, and relying more on matrix\nmultiplications (GEMMs); this will require, however, a larger memory\nworkspace. The parameter fast_alg controls whether the fast algorithm is\nexecuted or not. For more details, see the \"Tuning rocSOLVER performance\"\nand \"Memory model\" sections of the documentation.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, if left_svect (or right_svect) is equal to\noverwrite, the first columns (or rows) of A_l contain the left (or right)\ncorresponding singular vectors; otherwise, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA.\nNormal use case is strideA >= lda*n.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to overwrite or none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to overwrite or none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the bidiagonal matrix B_l associated with A_l (using \\ref rocsolver_sbdsqr \"BDSQR\").\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of B_l (or properly speaking,\na bidiagonal matrix orthogonally equivalent to B_l). The diagonal elements of this matrix are in S_l;\nthose that converged correspond to a subset of the singular values of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE.\nNormal use case is strideE >= min(m,n)-1.\n@param[in]\nfast_alg    #rocblas_workmode.\nIf set to rocblas_outofplace, the function will execute the fast thin-SVD version\nof the algorithm when possible.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, BDSQR did not converge. i elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvd_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        fast_alg: rocblas_workmode,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVDJ computes the singular values and optionally the singular\nvectors of a general m-by-n matrix A (Singular Value Decomposition).\n\n\\details\nThe SVD of matrix A is given by:\n\n\\f[\nA = U  S  V'\n\\f]\n\nwhere the m-by-n matrix S is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of A. U and V are orthogonal\n(unitary) matrices. The first min(m,n) columns of U and V are the left and\nright singular vectors of A, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of V'.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix U (or V') is computed,\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of U or rows of V') are computed, or\n- rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.\nno singular vectors.\n\nThe singular values are computed by applying QR factorization to AV if m >= n\n(resp. LQ factorization to U'A if m < n), where V (resp. U) is found as the\neigenvectors of A'A (resp. AA') using the Jacobi eigenvalue algorithm.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A'A)\nis <= norm(A'A) * abstol [resp. off(AA') <= norm(AA') * abstol]. If abstol <= 0,\nthen the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A'A (resp. AA') at the final\niteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nS           pointer to real type. Array on the GPU of dimension min(m,n).\nThe singular values of A in decreasing order.\n@param[out]\nU           pointer to type. Array on the GPU of dimension ldu*min(m,n) if\nleft_svect is set to singular, or ldu*m when left_svect is equal to all.\nThe matrix of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.\nThe leading dimension of U.\n@param[out]\nV           pointer to type. Array on the GPU of dimension ldv*n.\nThe matrix of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_sgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        U: *mut f32,
        ldu: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        U: *mut f64,
        ldu: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvdj(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVDJ_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrix A (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nThe singular values are computed by applying QR factorization to \\f$A_lV_l\\f$ if m >= n\n(resp. LQ factorization to \\f$U_l'A_l\\f$ if m < n), where \\f$V_l\\f$ (resp. \\f$U_l\\f$) is\nfound as the eigenvectors of \\f$A_l'A_l\\f$ (resp. \\f$A_lA_l'\\f$) using the Jacobi\neigenvalue algorithm.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on\nthe GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l'A_l)\nis <= norm(A_l'A_l) * abstol [resp. off(A_lA_l') <= norm(A_lA_l') * abstol]. If abstol <= 0,\nthen the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l'A_l (resp. A_lA_l') at the final\niteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S(l+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U(l+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V(l+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvdj_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVDJ_STRIDED_BATCHED computes the singular values and optionally the\nsingular vectors of a batch of general m-by-n matrix A (Singular Value\nDecomposition).\n\n\\details\nThe SVD of matrix A_l in the batch is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$ is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$. \\f$U_l\\f$ and \\f$V_l\\f$ are\northogonal (unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$ and \\f$V_l\\f$ are\nthe left and right singular vectors of \\f$A_l\\f$, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that can take the\nfollowing values:\n\n- rocblas_svect_all: the entire matrix \\f$U_l\\f$ (or \\f$V_l'\\f$) is computed,\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$ or rows of \\f$V_l'\\f$) are computed, or\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$ (or \\f$V_l'\\f$) are computed,\ni.e. no singular vectors.\n\nThe singular values are computed by applying QR factorization to \\f$A_lV_l\\f$ if m >= n\n(resp. LQ factorization to \\f$U_l'A_l\\f$ if m < n), where \\f$V_l\\f$ (resp. \\f$U_l\\f$) is\nfound as the eigenvectors of \\f$A_l'A_l\\f$ (resp. \\f$A_lA_l'\\f$) using the Jacobi\neigenvalue algorithm.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies how the left singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies how the right singular vectors are computed.\nrocblas_svect_overwrite is not supported.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of all matrices A_l in the batch.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA.\nNormal use case is strideA >= lda*n.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l'A_l)\nis <= norm(A_l'A_l) * abstol [resp. off(A_lA_l') <= norm(A_lA_l') * abstol]. If abstol <= 0,\nthen the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l'A_l (resp. A_lA_l') at the final\niteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe singular values of A_l in decreasing order.\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(j+1).\nThere is no restriction for the value of strideS.\nNormal use case is strideS >= min(m,n).\n@param[out]\nU           pointer to type. Array on the GPU (the side depends on the value of strideU).\nThe matrices U_l of left singular vectors stored as columns.\nNot referenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect is set to all or singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(j+1).\nThere is no restriction for the value of strideU.\nNormal use case is strideU >= ldu*min(m,n) if left_svect is set to singular,\nor strideU >= ldu*m when left_svect is equal to all.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrices V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= n if right_svect is set to all; ldv >= min(m,n) if right_svect is\nset to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(j+1).\nThere is no restriction for the value of strideV.\nNormal use case is strideV >= ldv*n.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvdj_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVDX computes a set of singular values and optionally the corresponding singular\nvectors of a general m-by-n matrix A (partial Singular Value Decomposition).\n\n\\details\nThis function computes all the singular values of A, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nThe full SVD of matrix A is given by:\n\n\\f[\nA = U  S  V'\n\\f]\n\nwhere the m-by-n matrix S is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of A. U and V are orthogonal\n(unitary) matrices. The first min(m,n) columns of U and V are the left and\nright singular vectors of A, respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of V'.\n\nleft_svect and right_svect are #rocblas_svect enums that, for this function, can take the\nfollowing values:\n\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of U or rows of V') corresponding to the computed singular values are computed,\n- rocblas_svect_none: no columns (or rows) of U (or V') are computed, i.e.\nno singular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies if the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies if the right singular vectors are computed.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A.\nOn exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to a rocblas_int on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv = min(m,n).\nIf srange is rocblas_srange_index, nsv = iu - il + 1. Otherwise, 0 <= nsv <= min(m,n).\n@param[out]\nS           pointer to real type. Array on the GPU of dimension nsv.\nThe first nsv elements contain the computed singular values in descending order.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that S is large enough to hold min(m,n) values.\n@param[out]\nU           pointer to type. Array on the GPU of dimension ldu*nsv.\nThe matrix of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that U is large enough to hold min(m,n) columns.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.\nThe leading dimension of U.\n@param[out]\nV           pointer to type. Array on the GPU of dimension ldv*n.\nThe matrix of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= nsv if right_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V.\nNote: If srange is rocblas_srange_value, then the value of nsv is not known in advance.\nIn this case, the user should ensure that V is large enough to hold min(m,n) rows.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension min(m,n).\nIf info = 0, the first nsv elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sbdsvdx \"BDSVDX\".\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, i eigenvectors did not converge in \\ref rocsolver_sbdsvdx \"BDSVDX\"; their\nindices are stored in ifail."]
    pub fn rocsolver_sgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        U: *mut f32,
        ldu: rocblas_int,
        V: *mut f32,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        U: *mut f64,
        ldu: rocblas_int,
        V: *mut f64,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvdx(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVDX_BATCHED computes a set of singular values and optionally the corresponding singular\nvectors of a batch of general m-by-n matrices \\f$A_l\\f$ (partial Singular Value Decomposition).\n\n\\details\nThis function computes all the singular values of \\f$A_l\\f$, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nThe full SVD of matrix \\f$A_l\\f$  is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$  is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$ . \\f$U_l\\f$  and \\f$V_l\\f$  are orthogonal\n(unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$  and \\f$V_l\\f$  are the left and\nright singular vectors of \\f$A_l\\f$ , respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that, for this function, can take the\nfollowing values:\n\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$  or rows of \\f$V_l'\\f$ ) corresponding to the computed singular values are computed,\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$  (or \\f$V_l'\\f$ ) are computed, i.e.\nno singular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies if the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies if the right singular vectors are computed.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A_l.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv[l] = min(m,n).\nIf srange is rocblas_srange_index, nsv[l] = iu - il + 1. Otherwise, 0 <= nsv[l] <= min(m,n).\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe first nsv_l elements contain the computed singular values in descending order.\n(The remaining elements may be used as workspace for internal computations).\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS. Normal use case is strideS >= nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that S_l is large enough to hold min(m,n) values.\n@param[out]\nU           pointer to type. Array on the GPU (the size depends on the value of strideU).\nThe matrix U_l of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU. Normal use case is strideU >= ldu*nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that U_l is large enough to hold min(m,n) columns.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrix V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= nsv_l if right_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that V_l is large enough to hold min(m,n) rows.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV. Normal use case is strideV >= ldv*n.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nsv[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sbdsvdx \"BDSVDX\".\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= min(m,n).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, i eigenvectors did not converge in \\ref rocsolver_sbdsvdx \"BDSVDX\"; their\nindices are stored in ifail_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvdx_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GESVDX_STRIDED_BATCHED computes a set of singular values and optionally the corresponding singular\nvectors of a batch of general m-by-n matrices \\f$A_l\\f$ (partial Singular Value Decomposition).\n\n\\details\nThis function computes all the singular values of \\f$A_l\\f$, all the singular values in the half-open interval\n\\f$[vl, vu)\\f$, or the il-th through iu-th singular values, depending on the value of srange.\n\nThe full SVD of matrix \\f$A_l\\f$  is given by:\n\n\\f[\nA_l = U_l  S_l  V_l'\n\\f]\n\nwhere the m-by-n matrix \\f$S_l\\f$  is zero except, possibly, for its min(m,n)\ndiagonal elements, which are the singular values of \\f$A_l\\f$ . \\f$U_l\\f$  and \\f$V_l\\f$  are orthogonal\n(unitary) matrices. The first min(m,n) columns of \\f$U_l\\f$  and \\f$V_l\\f$  are the left and\nright singular vectors of \\f$A_l\\f$ , respectively.\n\nThe computation of the singular vectors is optional and it is controlled by\nthe function arguments left_svect and right_svect as described below. When\ncomputed, this function returns the transpose (or transpose conjugate) of the\nright singular vectors, i.e. the rows of \\f$V_l'\\f$.\n\nleft_svect and right_svect are #rocblas_svect enums that, for this function, can take the\nfollowing values:\n\n- rocblas_svect_singular: the singular vectors (first min(m,n)\ncolumns of \\f$U_l\\f$  or rows of \\f$V_l'\\f$ ) corresponding to the computed singular values are computed,\n- rocblas_svect_none: no columns (or rows) of \\f$U_l\\f$  (or \\f$V_l'\\f$ ) are computed, i.e.\nno singular vectors.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nleft_svect  #rocblas_svect.\nSpecifies if the left singular vectors are computed.\n@param[in]\nright_svect #rocblas_svect.\nSpecifies if the right singular vectors are computed.\n@param[in]\nsrange      #rocblas_srange.\nSpecifies the type of range or interval of the singular values to be computed.\n@param[in]\nm           rocblas_int. m >= 0.\nThe number of rows of matrix A_l.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l.\nOn exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= m.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          real type. 0 <= vl < vu.\nThe lower bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nvu          real type. 0 <= vl < vu.\nThe upper bound of the search interval [vl, vu). Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the largest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest singular value to be computed. Ignored if srange indicates to look\nfor all the singular values of A_l or the singular values in a half-open interval.\n@param[out]\nnsv         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of singular values found. If srange is rocblas_srange_all, nsv[l] = min(m,n).\nIf srange is rocblas_srange_index, nsv[l] = iu - il + 1. Otherwise, 0 <= nsv[l] <= min(m,n).\n@param[out]\nS           pointer to real type. Array on the GPU (the size depends on the value of strideS).\nThe first nsv_l elements contain the computed singular values in descending order.\n(The remaining elements may be used as workspace for internal computations).\n@param[in]\nstrideS     rocblas_stride.\nStride from the start of one vector S_l to the next one S_(l+1).\nThere is no restriction for the value of strideS. Normal use case is strideS >= nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that S_l is large enough to hold min(m,n) values.\n@param[out]\nU           pointer to type. Array on the GPU (the size depends on the value of strideU).\nThe matrix U_l of left singular vectors stored as columns. Not\nreferenced if left_svect is set to none.\n@param[in]\nldu         rocblas_int. ldu >= m if left_svect singular; ldu >= 1 otherwise.\nThe leading dimension of U_l.\n@param[in]\nstrideU     rocblas_stride.\nStride from the start of one matrix U_l to the next one U_(l+1).\nThere is no restriction for the value of strideU. Normal use case is strideU >= ldu*nsv_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that U_l is large enough to hold min(m,n) columns.\n@param[out]\nV           pointer to type. Array on the GPU (the size depends on the value of strideV).\nThe matrix V_l of right singular vectors stored as rows (transposed / conjugate-transposed).\nNot referenced if right_svect is set to none.\n@param[in]\nldv         rocblas_int. ldv >= nsv_l if right_svect is set to singular; or ldv >= 1 otherwise.\nThe leading dimension of V_l.\nNote: If srange is rocblas_srange_value, then the value of nsv_l is not known in advance.\nIn this case, the user should ensure that V_l is large enough to hold min(m,n) rows.\n@param[in]\nstrideV     rocblas_stride.\nStride from the start of one matrix V_l to the next one V_(l+1).\nThere is no restriction for the value of strideV. Normal use case is strideV >= ldv*n.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nsv[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge, as returned by \\ref rocsolver_sbdsvdx \"BDSVDX\".\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= min(m,n).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info[l] = 0, successful exit.\nIf info[l] = i > 0, i eigenvectors did not converge in \\ref rocsolver_sbdsvdx \"BDSVDX\"; their\nindices are stored in ifail_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut f32,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f32,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut f64,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut f64,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f32,
        strideS: rocblas_stride,
        U: *mut rocblas_float_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_float_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgesvdx_strided_batched(
        handle: rocblas_handle,
        left_svect: rocblas_svect,
        right_svect: rocblas_svect,
        srange: rocblas_srange,
        m: rocblas_int,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nsv: *mut rocblas_int,
        S: *mut f64,
        strideS: rocblas_stride,
        U: *mut rocblas_double_complex,
        ldu: rocblas_int,
        strideU: rocblas_stride,
        V: *mut rocblas_double_complex,
        ldv: rocblas_int,
        strideV: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTD2 computes the tridiagonal form of a real symmetric matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is symmetric tridiagonal and Q is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_ssytd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HETD2 computes the tridiagonal form of a complex hermitian matrix A.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is hermitian tridiagonal and Q is an unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householders vector v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_chetd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhetd2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTD2_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l^{}[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HETD2_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch.\n"]
    pub fn rocsolver_chetd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhetd2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTD2_STRIDED_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HETD2_STRIDED_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chetd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhetd2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTRD computes the tridiagonal form of a real symmetric matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is symmetric tridiagonal and Q is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H_(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_ssytrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HETRD computes the tridiagonal form of a complex hermitian matrix A.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form is given by:\n\n\\f[\nT = Q'  A  Q\n\\f]\n\nwhere T is hermitian tridiagonal and Q is an unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ = H(1)H(2)\\cdots H(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ = H(n-1)H(n-2)\\cdots H(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H(i)\\f$ is given by\n\n\\f[\nH(i) = I - \\text{tau}[i] \\cdot v_i^{}  v_i'\n\\f]\n\nwhere tau[i] is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_i stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_i stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe diagonal elements of T.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n-1.\nThe off-diagonal elements of T.\n@param[out]\ntau         pointer to type. Array on the GPU of dimension n-1.\nThe Householder scalars."]
    pub fn rocsolver_chetrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        tau: *mut rocblas_float_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhetrd(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        tau: *mut rocblas_double_complex,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTRD_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HETRD_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE          pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chetrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhetrd_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTRD_STRIDED_BATCHED computes the tridiagonal form of a batch of real symmetric matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is symmetric tridiagonal and \\f$Q_l\\f$ is an orthogonal matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut f32,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut f64,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HETRD_STRIDED_BATCHED computes the tridiagonal form of a batch of complex hermitian matrices A_l.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe tridiagonal form of \\f$A_l\\f$ is given by:\n\n\\f[\nT_l^{} = Q_l'  A_l^{}  Q_l^{}\n\\f]\n\nwhere \\f$T_l\\f$ is Hermitian tridiagonal and \\f$Q_l\\f$ is a unitary matrix represented as the product\nof Householder matrices\n\n\\f[\n\\begin{array}{cl}\nQ_l = H_l(1)H_l(2)\\cdots H_l(n-1) & \\: \\text{if uplo indicates lower, or}\\\\\nQ_l = H_l(n-1)H_l(n-2)\\cdots H_l(1) & \\: \\text{if uplo indicates upper.}\n\\end{array}\n\\f]\n\nEach Householder matrix \\f$H_l(i)\\f$ is given by\n\n\\f[\nH_l^{}(i) = I - \\text{tau}_l[i] \\cdot v_{l_i}^{}  v_{l_i}'\n\\f]\n\nwhere \\f$\\text{tau}_l[i]\\f$ is the corresponding Householder scalar. When uplo indicates lower, the first i\nelements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i+1] = 1\\f$. If uplo indicates upper,\nthe last n-i elements of the Householder vector \\f$v_{l_i}\\f$ are zero, and \\f$v_{l_i}[i] = 1\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the hermitian matrix A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l to be factored.\nOn exit, if upper, then the elements on the diagonal and superdiagonal\ncontain the tridiagonal form T_l; the elements above the superdiagonal contain\nthe first i-1 elements of the Householder vectors v_(l_i) stored as columns.\nIf lower, then the elements on the diagonal and subdiagonal\ncontain the tridiagonal form T_l; the elements below the subdiagonal contain\nthe last n-i-1 elements of the Householder vectors v_(l_i) stored as columns.\n@param[in]\nlda         rocblas_int. lda >= n.\nThe leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe diagonal elements of T_l.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThe off-diagonal elements of T_l.\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n-1.\n@param[out]\ntau         pointer to type. Array on the GPU (the size depends on the value of strideP).\nContains the vectors tau_l of corresponding Householder scalars.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector tau_l to the next one tau_(l+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= n-1.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chetrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        tau: *mut rocblas_float_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhetrd_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        tau: *mut rocblas_double_complex,
        strideP: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGS2 reduces a real symmetric-definite generalized eigenproblem to standard\nform.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-T} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix B has been factorized as either \\f$U^T U\\f$ or\n\\f$L L^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^T, & \\: \\text{or}\\\\\nL^T A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_ssygs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGS2 reduces a hermitian-definite generalized eigenproblem to standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-H} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix B has been factorized as either \\f$U^H U\\f$ or\n\\f$L L^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^H, & \\: \\text{or}\\\\\nL^H A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_chegs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegs2(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGS2_BATCHED reduces a batch of real symmetric-definite generalized eigenproblems\nto standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGS2_BATCHED reduces a batch of hermitian-definite generalized eigenproblems to\nstandard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegs2_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGS2_STRIDED_BATCHED reduces a batch of real symmetric-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGS2_STRIDED_BATCHED reduces a batch of hermitian-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegs2_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGST reduces a real symmetric-definite generalized eigenproblem to standard\nform.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-T} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix B has been factorized as either \\f$U^T U\\f$ or\n\\f$L L^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^T, & \\: \\text{or}\\\\\nL^T A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_ssygst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGST reduces a hermitian-definite generalized eigenproblem to standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU^{-H} A U^{-1}, & \\: \\text{or}\\\\\nL^{-1} A L^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix B has been factorized as either \\f$U^H U\\f$ or\n\\f$L L^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU A U^H, & \\: \\text{or}\\\\\nL^H A L,\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored, and\nwhether the factorization applied to B was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and\nB are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the transformed matrix associated with\nthe equivalent standard eigenvalue problem.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nThe triangular factor of the matrix B, as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B."]
    pub fn rocsolver_chegst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegst(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGST_BATCHED reduces a batch of real symmetric-definite generalized eigenproblems\nto standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGST_BATCHED reduces a batch of hermitian-definite generalized eigenproblems to\nstandard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegst_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGST_STRIDED_BATCHED reduces a batch of real symmetric-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-T} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-T},\n\\end{array}\n\\f]\n\nwhere the symmetric-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^T U_l^{}\\f$ or\n\\f$L_l^{} L_l^T\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^T, & \\: \\text{or}\\\\\nL_l^T A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGST_STRIDED_BATCHED reduces a batch of hermitian-definite generalized\neigenproblems to standard form.\n\n\\details\n(This is the blocked version of the algorithm).\n\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype.\n\nIf the problem is of the 1st form, then \\f$A_l\\f$ is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{-H} A_l^{} U_l^{-1}, & \\: \\text{or}\\\\\nL_l^{-1} A_l^{} L_l^{-H},\n\\end{array}\n\\f]\n\nwhere the hermitian-definite matrix \\f$B_l\\f$ has been factorized as either \\f$U_l^H U_l^{}\\f$ or\n\\f$L_l^{} L_l^H\\f$ as returned by \\ref rocsolver_spotrf \"POTRF\", depending on the value of uplo.\n\nIf the problem is of the 2nd or 3rd form, then A is overwritten with\n\n\\f[\n\\begin{array}{cl}\nU_l^{} A_l^{} U_l^H, & \\: \\text{or}\\\\\nL_l^H A_l^{} L_l^{},\n\\end{array}\n\\f]\n\nalso depending on the value of uplo.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored, and\nwhether the factorization applied to B_l was upper or lower triangular.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and\nB_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the transformed matrices associated with\nthe equivalent standard eigenvalue problems.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nThe triangular factors of the matrices B_l, as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*n.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegst_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEV computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = i > 0, the algorithm did not converge.\ni elements of E did not converge to zero."]
    pub fn rocsolver_ssyev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEV computes the eigenvalues and optionally the eigenvectors of a Hermitian matrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = i > 0, the algorithm did not converge.\ni elements of E did not converge to zero."]
    pub fn rocsolver_cheev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheev(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEV_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEV_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheev_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEV_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEV_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed depending\non the value of evect. The computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = i > 0, the algorithm did not converge.\ni elements of E_l did not converge to zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheev_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVD computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E did not converge to zero.\nIf info = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)]."]
    pub fn rocsolver_ssyevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVD computes the eigenvalues and optionally the eigenvectors of a Hermitian matrix A.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with A.\nOn exit, if info > 0, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues of A (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E did not converge to zero.\nIf info = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)]."]
    pub fn rocsolver_cheevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevd(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVD_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVD_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevd_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVD_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVD_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nHermitian matrices A_l.\n\n\\details\nThe eigenvalues are returned in ascending order. The eigenvectors are computed using a\ndivide-and-conquer algorithm, depending on the value of evect. The computed eigenvectors\nare orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with A_l.\nOn exit, if info[l] > 0, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues of A_l (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use case is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0 and evect is rocblas_evect_none, the algorithm did not converge.\ni elements of E_l did not converge to zero.\nIf info[l] = i > 0 and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevd_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVDJ computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\\n\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_ssyevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVDJ computes the eigenvalues and optionally the eigenvectors of a complex Hermitian\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\\n\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_cheevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevdj(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVDJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of real symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVDJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of complex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevdj_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVDJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of real symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVDJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a\nbatch of complex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in ascending order.\nThe eigenvectors are computed using a divide-and-conquer approach depending on the value of evect.\nThe computed eigenvectors are orthonormal.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use case is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit for A_l. If info[l] = 1, the algorithm did not converge for A_l.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevdj_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVDJ computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A and B are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and B\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the normalized matrix Z of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*n.\\n\nOn entry, the symmetric positive definite matrix B. On exit,\nthe triangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrix B.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\\n\nThe eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not positive definite."]
    pub fn rocsolver_ssygvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVDJ computes the eigenvalues and (optionally) eigenvectors of\na complex generalized Hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A and B are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A and B\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A. On exit, the normalized matrix Z of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*n.\\n\nOn entry, the Hermitian positive definite matrix B. On exit,\nthe triangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrix B.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\\n\nThe eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\\n\nIf info = 0, successful exit. If info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not positive definite."]
    pub fn rocsolver_chegvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvdj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVDJ_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[inout]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\\n\nOn entry, the symmetric positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_ssygvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVDJ_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of complex generalized Hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[inout]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\\n\nOn entry, the Hermitian positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_chegvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvdj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVDJ_STRIDED_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\\n\nOn entry, the symmetric positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\\n\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_ssygvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVDJ_STRIDED_BATCHED computes the eigenvalues and (optionally) eigenvectors of\nbatch of complex generalized Hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative Jacobi algorithm,\nand are returned in ascending order. The eigenvectors are computed using a divide-and-conquer algorithm,\ndepending on the value of evect.\n\nWhen computed, the matrix Z_l of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H_l B_l Z_l=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H_l B^{-1}_l Z_l=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\\n\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\\n\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\\n\nSpecifies whether the upper or lower parts of the matrices A_l and B_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower) parts of A_l and B_l\nare not used.\n@param[in]\nn           rocblas_int. n >= 0.\\n\nNumber of rows and columns of matrix A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_l. On exit, the normalized matrices Z_l of eigenvectors if they were computed\nand the algorithm converged; otherwise the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\\n\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\\n\nOn entry, the Hermitian positive definite matrices B_l. On exit,\nthe triangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\\n\nSpecifies the leading dimension of matrices B_l.\n@param[in]\nstrideB     rocblas_stride.\\n\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\\n\nThe eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\\n\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\\n\nIf info[l] = 0, successful exit. If info[l] = 1, the algorithm did not converge for matrix A_l.\nIf info[l] = n + i, the leading minor of order i of B_l is not positive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\\n\nNumber of eigenproblems in the batch."]
    pub fn rocsolver_chegvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvdj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVJ computes the eigenvalues and optionally the eigenvectors of a real symmetric\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A\\f$ is transformed by a product of Jacobi rotations \\f$V\\f$ as\n\n\\f[\nA^{(k)} = V' A^{(k-1)} V\n\\f]\n\nsuch that \\f$off(A^{(k)}) < off(A^{(k-1)})\\f$, where \\f$A^{(0)} = A\\f$ and \\f$off(A^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A^{(k)}\\f$. As \\f$off(A^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A\\f$.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A (i.e. off(A)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_ssyevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVJ computes the eigenvalues and optionally the eigenvectors of a complex Hermitian\nmatrix A.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A\\f$ is transformed by a product of Jacobi rotations \\f$V\\f$ as\n\n\\f[\nA^{(k)} = V' A^{(k-1)} V\n\\f]\n\nsuch that \\f$off(A^{(k)}) < off(A^{(k-1)})\\f$, where \\f$A^{(0)} = A\\f$ and \\f$off(A^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A^{(k)}\\f$. As \\f$off(A^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A\\f$.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the eigenvectors of A if they were computed and\nthe algorithm converged; otherwise the contents of A are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements of A (i.e. off(A)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe eigenvalues of A in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit. If info = 1, the algorithm did not converge."]
    pub fn rocsolver_cheevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevj(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVJ_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\ncomplex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevj_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\nreal symmetric matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVJ_STRIDED_BATCHED computes the eigenvalues and optionally the eigenvectors of a batch of\ncomplex Hermitian matrices A_l.\n\n\\details\nThe eigenvalues are found using the iterative Jacobi algorithm and are returned in an order\ndepending on the value of esort.\nThe eigenvectors are computed depending on the value of evect. The computed eigenvectors are orthonormal.\n\nAt the \\f$k\\f$-th iteration (or \"sweep\"), \\f$A_l\\f$ is transformed by a product of Jacobi rotations \\f$V_l\\f$ as\n\n\\f[\nA_l^{(k)} = V_l' A_l^{(k-1)} V_l^{}\n\\f]\n\nsuch that \\f$off(A_l^{(k)}) < off(A_l^{(k-1)})\\f$, where \\f$A_l^{(0)} = A_l\\f$ and \\f$off(A_l^{(k)})\\f$ is the\nFrobenius norm of the off-diagonal elements of \\f$A_l^{(k)}\\f$. As \\f$off(A_l^{(k)}) \\rightarrow 0\\f$, the\ndiagonal elements of \\f$A_l^{(k)}\\f$ increasingly resemble the eigenvalues of \\f$A_l\\f$.\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nesort       #rocblas_esort.\nSpecifies the order of the returned eigenvalues. If esort is\nrocblas_esort_ascending, then the eigenvalues are sorted and returned in ascending order.\nIf esort is rocblas_esort_none, then the order of the returned eigenvalues is unspecified.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the Hermitian matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the eigenvectors of A_l if they were computed and\nthe algorithm converged; otherwise the contents of A_l are unchanged.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once off(A_l)\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements of A_l (i.e. off(A_l)) at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe eigenvalues of A_l in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l. If info[l] = 1, the algorithm did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevj_strided_batched(
        handle: rocblas_handle,
        esort: rocblas_esort,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a\nreal symmetric matrix A.\n\n\\details\nThis function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the algorithm did not converge. i columns of Z did not converge."]
    pub fn rocsolver_ssyevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a\nHermitian matrix A.\n\n\\details\nThis function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the algorithm did not converge. i columns of Z did not converge."]
    pub fn rocsolver_cheevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of real symmetric matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of Hermitian matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of real symmetric matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut f32,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut f64,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of Hermitian matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nOtherwise, contains the indices of those eigenvectors that failed\nto converge. Not referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGV computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGV computes the eigenvalues and (optionally) eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the hermitian matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegv(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGV_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, E_l contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGV_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegv_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGV_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch j.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGV_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i off-diagonal elements of an intermediate\ntridiagonal form did not converge to zero.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegv_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVD computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVD computes the eigenvalues and (optionally) eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the hermitian matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[out]\nD           pointer to real type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\nE           pointer to real type. Array on the GPU of dimension n.\nThis array is used to work internally with the tridiagonal matrix T associated with\nthe reduced eigenvalue problem.\nOn exit, if 0 < info <= n, it contains the unconverged off-diagonal elements of T\n(or properly speaking, a tridiagonal matrix equivalent to T). The diagonal elements\nof this matrix are in D; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        E: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvd(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        E: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVD_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVD_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvd_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVD_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVD_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed using a divide-and-conquer algorithm, depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[out]\nD           pointer to real type. Array on the GPU (the size depends on the value of strideD).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideD     rocblas_stride.\nStride from the start of one vector D_l to the next one D_(l+1).\nThere is no restriction for the value of strideD. Normal use is strideD >= n.\n@param[out]\nE           pointer to real type. Array on the GPU (the size depends on the value of strideE).\nThis array is used to work internally with the tridiagonal matrix T_l associated with\nthe l-th reduced eigenvalue problem.\nOn exit, if 0 < info[l] <= n, it contains the unconverged off-diagonal elements of T_l\n(or properly speaking, a tridiagonal matrix equivalent to T_l). The diagonal elements\nof this matrix are in D_l; those that converged correspond to a subset of the\neigenvalues (not necessarily ordered).\n@param[in]\nstrideE     rocblas_stride.\nStride from the start of one vector E_l to the next one E_(l+1).\nThere is no restriction for the value of strideE. Normal use is strideE >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n and evect is rocblas_evect_none, i off-diagonal elements of an\nintermediate tridiagonal form did not converge to zero.\nIf info[l] = i <= n and evect is rocblas_evect_original, the algorithm failed to\ncompute an eigenvalue in the submatrix from [i/(n+1), i/(n+1)] to [i%(n+1), i%(n+1)].\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f32,
        strideD: rocblas_stride,
        E: *mut f32,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvd_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        D: *mut f64,
        strideD: rocblas_stride,
        E: *mut f64,
        strideE: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVJ computes the eigenvalues and (optionally) eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVJ computes the eigenvalues and (optionally) eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n\\note\nIn order to carry out calculations, this method may synchronize the stream contained within the\nrocblas_handle.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the hermitian matrix A. On exit, if evect is original,\nthe normalized matrix Z of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrix A (including the diagonal) is destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to a rocblas_int on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nOn exit, the eigenvalues in increasing order.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = 1, the algorithm did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvj(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVJ_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVJ_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[out]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvj_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVJ_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nabstol      type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVJ_STRIDED_BATCHED computes the eigenvalues and (optionally)\neigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvalues are found using the iterative\nJacobi algorithm, and are returned in ascending order. The eigenvectors are computed\ndepending on the value of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the hermitian matrices A_l. On exit, if evect is original,\nthe normalized matrix Z_l of eigenvectors. If evect is none, then the upper or lower triangular\npart of the matrices A_l (including the diagonal) are destroyed,\ndepending on the value of uplo.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nabstol      real type.\nThe absolute tolerance. The algorithm is considered to have converged once the residual\nis <= abstol. If abstol <= 0, then the tolerance will be set to machine precision.\n@param[out]\nresidual    pointer to real type. Array of batch_count scalars on the GPU.\nThe Frobenius norm of the off-diagonal elements at the final iteration for each batch instance.\n@param[in]\nmax_sweeps  rocblas_int. max_sweeps > 0.\nMaximum number of sweeps (iterations) to be used by the algorithm.\n@param[out]\nn_sweeps    pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe actual number of sweeps (iterations) used by the algorithm for each batch instance.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nOn exit, the eigenvalues in increasing order.\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use is strideW >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = 1, the algorithm did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f32,
        residual: *mut f32,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvj_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        abstol: f64,
        residual: *mut f64,
        max_sweeps: rocblas_int,
        n_sweeps: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nIf info = i <= n, ifail contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i columns of Z did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVX computes a set of the eigenvalues and optionally the corresponding eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU of dimension n.\nIf info = 0, the first nev elements of ifail are zero.\nIf info = i <= n, ifail contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i columns of Z did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVX_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut f32,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut f64,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVX_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_float_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_double_complex,
        ldz: rocblas_int,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut f32,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut f64,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVX_STRIDED_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\nabstol      real type.\nThe absolute tolerance. An eigenvalue is considered to be located if it lies\nin an interval whose width is <= abstol. If abstol is negative, then machine-epsilon times\nthe 1-norm of the tridiagonal form of A_l will be used as tolerance. If abstol=0, then the tolerance will be set\nto twice the underflow threshold; this is the tolerance that could get the most accurate results.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\nifail       pointer to rocblas_int. Array on the GPU (the size depends on the value of strideF).\nIf info[l] = 0, the first nev[l] elements of ifail_l are zero.\nIf info[l] = i <= n, ifail_l contains the indices of the i eigenvectors that failed\nto converge.\nNot referenced if evect is rocblas_evect_none.\n@param[in]\nstrideF     rocblas_stride.\nStride from the start of one vector ifail_l to the next one ifail_(l+1).\nThere is no restriction for the value of strideF. Normal use case is strideF >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f32,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        abstol: f64,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        ifail: *mut rocblas_int,
        strideF: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_OUTOFPLACE computes the inverse \\f$C = A^{-1}\\f$ of a general n-by-n matrix A.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nAC = I\n\\f]\n\nwhere I is the identity matrix, and A is factorized as \\f$A = PLU\\f$ as given by \\ref rocsolver_sgetrf \"GETRF\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factors L and U of the factorization A = P*L*U returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe pivot indices returned by \\ref rocsolver_sgetrf \"GETRF\".\n@param[out]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nIf info = 0, the inverse of A. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_OUTOFPLACE_BATCHED computes the inverse \\f$C_l = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = P_l  L_l  U_l\\f$ as given by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_batched \"GETRF_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_OUTOFPLACE_STRIDED_BATCHED computes the inverse \\f$C_l = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = P_l L_l U_l\\f$ as given by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factors L_l and U_l of the factorization A_l = P_l*L_l*U_l returned by\n\\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[in]\nipiv        pointer to rocblas_int. Array on the GPU (the size depends on the value of strideP).\nThe pivot indices returned by \\ref rocsolver_sgetrf_strided_batched \"GETRF_STRIDED_BATCHED\".\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one matrix C_l to the next one C_(l+1).\nThere is no restriction for the value of strideC. Normal use case is strideC >= ldc*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_NPVT_OUTOFPLACE computes the inverse \\f$C = A^{-1}\\f$ of a general n-by-n matrix A without partial pivoting.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nAC = I\n\\f]\n\nwhere I is the identity matrix, and A is factorized as \\f$A = LU\\f$ as given by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\nThe factors L and U of the factorization A = L*U returned by \\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nC           pointer to type. Array on the GPU of dimension ldc*n.\nIf info = 0, the inverse of A. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, U is singular. U[i,i] is the first zero pivot."]
    pub fn rocsolver_sgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_npvt_outofplace(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_NPVT_OUTOFPLACE_BATCHED computes the inverse \\f$C_l^{} = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$\nwithout partial pivoting.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = L_l  U_l\\f$ as given by \\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nThe factors L_l and U_l of the factorization A_l = L_l*U_l returned by \\ref rocsolver_sgetrf_npvt_batched \"GETRF_NPVT_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_npvt_outofplace_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GETRI_NPVT_OUTOFPLACE_STRIDED_BATCHED computes the inverse \\f$C_l^{} = A_l^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_l\\f$\nwithout partial pivoting.\n\n\\details\nThe inverse is computed by solving the linear system\n\n\\f[\nA_l C_l = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_l\\f$ is factorized as \\f$A_l = L_l  U_l\\f$ as given by \\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nThe factors L_l and U_l of the factorization A_l = L_l*U_l returned by\n\\ref rocsolver_sgetrf_npvt_strided_batched \"GETRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nIf info[l] = 0, the inverse of matrices A_l. Otherwise, undefined.\n@param[in]\nldc         rocblas_int. ldc >= n.\nSpecifies the leading dimension of C_l.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one matrix C_l to the next one C_(l+1).\nThere is no restriction for the value of strideC. Normal use case is strideC >= ldc*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, U_l is singular. U_l[i,i] is the first zero pivot.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgetri_npvt_outofplace_strided_batched(
        handle: rocblas_handle,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief TRTRI inverts a triangular n-by-n matrix A.\n\n\\details\nA can be upper or lower triangular, depending on the value of uplo, and unit or non-unit\ntriangular, depending on the value of diag.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\ndiag        rocblas_diagonal.\nIf diag indicates unit, then the diagonal elements of A are not referenced and\nassumed to be one.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the triangular matrix.\nOn exit, the inverse of A if info = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, A is singular. A[i,i] is the first zero element in the diagonal."]
    pub fn rocsolver_strtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dtrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_ctrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_ztrtri(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief TRTRI_BATCHED inverts a batch of triangular n-by-n matrices \\f$A_l\\f$.\n\n\\details\n\\f$A_l\\f$ can be upper or lower triangular, depending on the value of uplo, and unit or non-unit\ntriangular, depending on the value of diag.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\ndiag        rocblas_diagonal.\nIf diag indicates unit, then the diagonal elements of matrices A_l are not referenced and\nassumed to be one.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the triangular matrices A_l.\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. A_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_strtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dtrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_ctrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_ztrtri_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief TRTRI_STRIDED_BATCHED inverts a batch of triangular n-by-n matrices \\f$A_l\\f$.\n\n\\details\n\\f$A_l\\f$ can be upper or lower triangular, depending on the value of uplo, and unit or non-unit\ntriangular, depending on the value of diag.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\ndiag        rocblas_diagonal.\nIf diag indicates unit, then the diagonal elements of matrices A_l are not referenced and\nassumed to be one.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the triangular matrices A_l.\nOn exit, the inverses of A_l if info[l] = 0.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for inversion of A_l.\nIf info[l] = i > 0, A_l is singular. A_l[i,i] is the first zero element in the diagonal.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_strtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dtrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_ctrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_ztrtri_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        diag: rocblas_diagonal,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTF2 computes the factorization of a symmetric indefinite matrix \\f$A\\f$\nusing Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA = U D U^T & \\: \\text{or}\\\\\nA = L D L^T &\n\\end{array}\n\\f]\n\nwhere \\f$U\\f$ or \\f$L\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_k\\f$.\n\nSpecifically, \\f$U\\f$ and \\f$L\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU = P(n) U(n) \\cdots P(k) U(k) \\cdots & \\: \\text{and}\\\\\nL = P(1) L(1) \\cdots P(k) L(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_k\\f$, and \\f$P(k)\\f$ is a permutation matrix defined by\n\\f$ipiv[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_k\\f$, then \\f$U(k)\\f$\nand \\f$L(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_k\\f$ is stored in \\f$A[k-1,k-1]\\f$, \\f$A[k-1,k]\\f$,\nand \\f$A[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$, \\f$A[k+1,k]\\f$,\nand \\f$A[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A to be factored.\nOn exit, the block diagonal matrix D and the multipliers needed to\ncompute U or L.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv[k] > 0 then rows and columns k and ipiv[k]\nwere interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k-1] < 0 and uplo is upper (or ipiv[k]\n= ipiv[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv[k] (or rows and columns k+1 and -ipiv[k]) were interchanged\nand D[k-1,k-1] to D[k,k] (or D[k,k] to D[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, D is singular. D[i,i] is the first diagonal zero."]
    pub fn rocsolver_ssytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsytf2(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTF2_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsytf2_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTF2_STRIDED_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the unblocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsytf2_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTRF computes the factorization of a symmetric indefinite matrix \\f$A\\f$\nusing Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA = U D U^T & \\: \\text{or}\\\\\nA = L D L^T &\n\\end{array}\n\\f]\n\nwhere \\f$U\\f$ or \\f$L\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_k\\f$.\n\nSpecifically, \\f$U\\f$ and \\f$L\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU = P(n) U(n) \\cdots P(k) U(k) \\cdots & \\: \\text{and}\\\\\nL = P(1) L(1) \\cdots P(k) L(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_k\\f$, and \\f$P(k)\\f$ is a permutation matrix defined by\n\\f$ipiv[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_k\\f$, then \\f$U(k)\\f$\nand \\f$L(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_k\\f$ is stored in \\f$A[k-1,k-1]\\f$, \\f$A[k-1,k]\\f$,\nand \\f$A[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_k\\f$ is stored in \\f$A[k,k]\\f$, \\f$A[k+1,k]\\f$,\nand \\f$A[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of the matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the symmetric matrix A to be factored.\nOn exit, the block diagonal matrix D and the multipliers needed to\ncompute U or L.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of A.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv[k] > 0 then rows and columns k and ipiv[k]\nwere interchanged and D[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv[k] = ipiv[k-1] < 0 and uplo is upper (or ipiv[k]\n= ipiv[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv[k] (or rows and columns k+1 and -ipiv[k]) were interchanged\nand D[k-1,k-1] to D[k,k] (or D[k,k] to D[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, D is singular. D[i,i] is the first diagonal zero."]
    pub fn rocsolver_ssytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsytrf(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTRF_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsytrf_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYTRF_STRIDED_BATCHED computes the factorization of a batch of symmetric indefinite\nmatrices using Bunch-Kaufman diagonal pivoting.\n\n\\details\n(This is the blocked version of the algorithm).\n\nThe factorization has the form\n\n\\f[\n\\begin{array}{cl}\nA_l^{} = U_l^{} D_l^{} U_l^T & \\: \\text{or}\\\\\nA_l^{} = L_l^{} D_l^{} L_l^T &\n\\end{array}\n\\f]\n\nwhere \\f$U_l\\f$ or \\f$L_l\\f$ is a product of permutation and unit upper/lower\ntriangular matrices (depending on the value of uplo), and \\f$D_l\\f$ is a symmetric\nblock diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks \\f$D_{kl}\\f$.\n\nSpecifically, \\f$U_l\\f$ and \\f$L_l\\f$ are computed as\n\n\\f[\n\\begin{array}{cl}\nU_l = P_l(n) U_l(n) \\cdots P_l(k) U_l(k) \\cdots & \\: \\text{and}\\\\\nL_l = P_l(1) L_l(1) \\cdots P_l(k) L_l(k) \\cdots &\n\\end{array}\n\\f]\n\nwhere \\f$k\\f$ decreases from \\f$n\\f$ to 1 (increases from 1 to \\f$n\\f$) in steps of 1 or 2,\ndepending on the order of block \\f$D_{kl}\\f$, and \\f$P_l(k)\\f$ is a permutation matrix defined by\n\\f$ipiv_l[k]\\f$. If we let \\f$s\\f$ denote the order of block \\f$D_{kl}\\f$, then \\f$U_l(k)\\f$\nand \\f$L_l(k)\\f$ are unit upper/lower triangular matrices defined as\n\n\\f[\nU_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-s} & v & 0 \\\\\n0 & I_s & 0 \\\\\n0 & 0 & I_{n-k}\n\\end{array} \\right]\n\\f]\n\nand\n\n\\f[\nL_l(k) = \\left[ \\begin{array}{ccc}\nI_{k-1} & 0 & 0 \\\\\n0 & I_s & 0 \\\\\n0 & v & I_{n-k-s+1}\n\\end{array} \\right].\n\\f]\n\nIf \\f$s = 1\\f$, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k,k]\\f$ and \\f$v\\f$ is stored in the upper/lower\npart of column \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is upper, then \\f$D_{kl}\\f$ is stored in \\f$A_l[k-1,k-1]\\f$, \\f$A_l[k-1,k]\\f$,\nand \\f$A_l[k,k]\\f$, and \\f$v\\f$ is stored in the upper parts of columns \\f$k-1\\f$ and \\f$k\\f$ of \\f$A_l\\f$.\nIf \\f$s = 2\\f$ and uplo is lower, then \\f$D_l(k)\\f$ is stored in \\f$A_l[k,k]\\f$, \\f$A_l[k+1,k]\\f$,\nand \\f$A_l[k+1,k+1]\\f$, and \\f$v\\f$ is stored in the lower parts of columns \\f$k\\f$ and \\f$k+1\\f$ of \\f$A_l\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the matrices A_l are stored.\nIf uplo indicates lower (or upper), then the upper (or lower)\npart of A_l is not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows and columns of all matrices A_l in the batch.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the symmetric matrices A_l to be factored.\nOn exit, the block diagonal matrices D_l and the multipliers needed to\ncompute U_l or L_l.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv        pointer to rocblas_int. Array on the GPU of dimension n.\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= k <= n, if ipiv_l[k] > 0 then rows and columns k and ipiv_l[k]\nwere interchanged and D_l[k,k] is a 1-by-1 diagonal block.\nIf, instead, ipiv_l[k] = ipiv_l[k-1] < 0 and uplo is upper (or ipiv_l[k]\n= ipiv_l[k+1] < 0 and uplo is lower), then rows and columns k-1 and\n-ipiv_l[k] (or rows and columns k+1 and -ipiv_l[k]) were interchanged\nand D_l[k-1,k-1] to D_l[k,k] (or D_l[k,k] to D_l[k+1,k+1]) is a 2-by-2\ndiagonal block.\n@param[in]\nstrideP     rocblas_stride.\nStride from the start of one vector ipiv_l to the next one ipiv_(l+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of A_l.\nIf info[l] = i > 0, D_l is singular. D_l[i,i] is the first diagonal zero.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_csytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zsytrf_strided_batched(
        handle: rocblas_handle,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        ipiv: *mut rocblas_int,
        strideP: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = "! @}\n*! @{\n\\brief GEBLTTRF_NPVT computes the LU factorization of a block tridiagonal matrix without partial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix\n\n\\f[\nM = \\left[\\begin{array}{ccccc}\nB_1 & C_1\\\\\nA_1 & B_2 & C_2\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{n-2} & B_{n-1} & C_{n-1}\\\\\n&  &  & A_{n-1} & B_n\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM = \\left[\\begin{array}{cccc}\nL_1 \\\\\nA_1 & L_2\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{n-1} & L_n\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_1 \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{n-1}\\\\\n&  &  & I\n\\end{array}\\right] = LU\n\\f]\n\nwhere the blocks \\f$L_i\\f$ and \\f$U_i\\f$ are also general blocks of size nb.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of the matrix.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*nb*(nblocks-1).\nContains the blocks A_i arranged one after the other.\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_i.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nb*nblocks.\nOn entry, contains the blocks B_i arranged one after the other.\nOn exit it is overwritten by blocks L_i in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_i.\n@param[inout]\nC           pointer to type. Array on the GPU of dimension ldc*nb*(nblocks-1).\nOn entry, contains the blocks C_i arranged one after the other.\nOn exit it is overwritten by blocks U_i.\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_i.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the matrix is singular.\n********************************************************************/"]
    pub fn rocsolver_sgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrf_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRF_NPVT_BATCHED computes the LU factorization of a batch of block tridiagonal matrices without\npartial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix \\f$M_l\\f$ in the batch\n\n\\f[\nM_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(l-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM_l = \\left[\\begin{array}{cccc}\nL_{l1} \\\\\nA_{l1} & L_{l2}\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{l(n-1)} & L_{ln}\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_{l1} \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{l(n-1)}\\\\\n&  &  & I\n\\end{array}\\right] = L_lU_l\n\\f]\n\nwhere the blocks \\f$L_{li}\\f$ and \\f$U_{li}\\f$ are also general blocks of size nb.\n\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension\nlda*nb*(nblocks-1).\nContains the blocks A_{li} arranged one after the other.\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[inout]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldb*nb*nblocks.\nOn entry, contains the blocks B_{li} arranged one after the other.\nOn exit it is overwritten by blocks L_{li} in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_{li}.\n@param[inout]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldc*nb*(nblocks-1).\nOn entry, contains the blocks C_{li} arranged one after the other.\nOn exit it is overwritten by blocks U_{li}.\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_{li}.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of l-th batch instance.\nIf info[l] = i > 0, the l-th batch instance is singular.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrf_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRF_NPVT_STRIDED_BATCHED computes the LU factorization of a batch of block tridiagonal\nmatrices without partial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix \\f$M_l\\f$ in the batch\n\n\\f[\nM_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM_l = \\left[\\begin{array}{cccc}\nL_{l1} \\\\\nA_{l1} & L_{l2}\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{l(n-1)} & L_{ln}\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_{l1} \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{l(n-1)}\\\\\n&  &  & I\n\\end{array}\\right] = L_lU_l\n\\f]\n\nwhere the blocks \\f$L_{li}\\f$ and \\f$U_{li}\\f$ are also general blocks of size nb.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} arranged one after the other.\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use case is strideA >=\nlda*nb*nblocks.\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, contains the blocks B_{li} arranged one after the other.\nOn exit it is overwritten by blocks L_{li} in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of matrix blocks B_{li}.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use case is strideB >=\nldb*nb*nblocks.\n@param[inout]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nOn entry, contains the blocks C_{li} arranged one after the other.\nOn exit it is overwritten by blocks U_{li}.\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of matrix blocks C_{li}.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use case is strideC >=\nldc*nb*nblocks.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of l-th batch instance.\nIf info[l] = i > 0, the l-th batch instance is singular.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrf_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRF_NPVT_INTERLEAVED_BATCHED computes the LU factorization of a batch of block tridiagonal\nmatrices without partial pivoting.\n\n\\details The LU factorization of a block tridiagonal matrix \\f$M_l\\f$ in the batch\n\n\\f[\nM_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\n\\f]\n\nwith \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, can be represented as\n\n\\f[\nM_l = \\left[\\begin{array}{cccc}\nL_{l1} \\\\\nA_{l1} & L_{l2}\\\\\n& \\ddots & \\ddots \\\\\n&  & A_{l(n-1)} & L_{ln}\n\\end{array}\\right] \\left[\\begin{array}{cccc}\nI & U_{l1} \\\\\n& \\ddots & \\ddots \\\\\n&  & I & U_{l(n-1)}\\\\\n&  &  & I\n\\end{array}\\right] = L_lU_l\n\\f]\n\nwhere the blocks \\f$L_{li}\\f$ and \\f$U_{li}\\f$ are also general blocks of size nb.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} arranged one after the other.\n@param[in]\ninca        rocblas_int. inca > 0.\nStride from the start of one row of A_{li} to the next. Normal use cases are\ninca = 1 (strided batched case) or inca = batch_count (interleaved batched case).\n@param[in]\nlda         rocblas_int. lda >= inca * nb.\nSpecifies the leading dimension of blocks A_{li}, i.e. the stride from the start\nof one column of A_{li} to the next.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use cases are strideA >=\nlda*nb*nblocks (strided batched case) or strideA = 1 (interleaved batched case).\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, contains the blocks B_{li} arranged one after the other.\nOn exit it is overwritten by blocks L_{li} in factorized form as returned by\n\\ref rocsolver_sgetrf_npvt \"GETRF_NPVT\"\n@param[in]\nincb        rocblas_int. incb > 0.\nStride from the start of one row of B_{li} to the next. Normal use cases are\nincb = 1 (strided batched case) or incb = batch_count (interleaved batched case).\n@param[in]\nldb         rocblas_int. ldb >= incb * nb.\nSpecifies the leading dimension of blocks B_{li}, i.e. the stride from the start\nof one column of B_{li} to the next.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use cases are strideB >=\nldb*nb*nblocks (strided batched case) or strideB = 1 (interleaved batched case).\n@param[inout]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nOn entry, contains the blocks C_{li} arranged one after the other.\nOn exit it is overwritten by blocks U_{li}.\n@param[in]\nincc        rocblas_int. incc > 0.\nStride from the start of one row of C_{li} to the next. Normal use cases are\nincc = 1 (strided batched case) or incc = batch_count (interleaved batched case).\n@param[in]\nldc         rocblas_int. ldc >= incc * nb.\nSpecifies the leading dimension of blocks C_{li}, i.e. the stride from the start\nof one column of C_{li} to the next.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use cases are strideC >=\nldc*nb*nblocks (strided batched case) or strideC = 1 (interleaved batched case).\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for factorization of l-th batch instance.\nIf info[l] = i > 0, the l-th batch instance is singular.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f32,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut f64,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_float_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrf_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        A: *mut rocblas_double_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRS_NPVT solves a system of linear equations given by a block tridiagonal matrix\nin its factorized form (without partial pivoting).\n\n\\details The linear system has the form\n\n\\f[\nMX = \\left[\\begin{array}{ccccc}\nB_1 & C_1\\\\\nA_1 & B_2 & C_2\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{n-2} & B_{n-1} & C_{n-1}\\\\\n&  &  & A_{n-1} & B_n\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_1\\\\\nX_2\\\\\nX_3\\\\\n\\vdots\\\\\nX_n\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_1\\\\\nR_2\\\\\nR_3\\\\\n\\vdots\\\\\nR_n\n\\end{array}\\right]=R\n\\f]\n\nwhere matrix M has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_i\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix M should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of the matrix.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_i.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*nb*(nblocks-1).\nContains the blocks A_i as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_i.\n@param[in]\nB           pointer to type. Array on the GPU of dimension ldb*nb*nblocks.\nContains the blocks B_i as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_i.\n@param[in]\nC           pointer to type. Array on the GPU of dimension ldc*nb*(nblocks-1).\nContains the blocks C_i as returned by \\ref rocsolver_sgeblttrf_npvt \"GEBLTTRF_NPVT\".\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_i.\n@param[inout]\nX           pointer to type. Array on the GPU of dimension ldx*nblocks*nrhs.\nOn entry, X contains the right-hand-side blocks R_i. It is overwritten by solution\nvectors X_i on exit.\n@param[in]\nldx         rocblas_int. ldx >= nb.\nSpecifies the leading dimension of blocks X_i."]
    pub fn rocsolver_sgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        C: *mut f32,
        ldc: rocblas_int,
        X: *mut f32,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        C: *mut f64,
        ldc: rocblas_int,
        X: *mut f64,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        X: *mut rocblas_float_complex,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrs_npvt(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        X: *mut rocblas_double_complex,
        ldx: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRS_NPVT_BATCHED solves a batch of system of linear equations given by block tridiagonal\nmatrices in its factorized form (without partial pivoting).\n\n\\details Each linear system has the form\n\n\\f[\nM_lX_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_{l1}\\\\\nX_{l2}\\\\\nX_{l3}\\\\\n\\vdots\\\\\nX_{ln}\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_{l1}\\\\\nR_{l2}\\\\\nR_{l3}\\\\\n\\vdots\\\\\nR_{ln}\n\\end{array}\\right]=R_l\n\\f]\n\nwhere matrix \\f$M_l\\f$ has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_{li}\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \\f$M_l\\f$ should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_{li}.\n@param[in]\nA           array of pointers to type. Each pointer points to an array on the GPU of dimension\nlda*nb*(nblocks-1).\nContains the blocks A_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[in]\nB           array of pointers to type. Each pointer points to an array on the GPU of dimension\nlda*nb*nblocks.\nContains the blocks B_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_{li}.\n@param[in]\nC           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldc*nb*(nblocks-1).\nContains the blocks C_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_batched \"GEBLTTRF_NPVT_BATCHED\".\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_{li}.\n@param[inout]\nX           array of pointers to type. Each pointer points to an array on the GPU of dimension\nldx*nblocks*nrhs.\nOn entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution\nvectors X_{li} on exit.\n@param[in]\nldx         rocblas_int. ldx >= nb.\nSpecifies the leading dimension of blocks X_{li}.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        C: *const *mut f32,
        ldc: rocblas_int,
        X: *const *mut f32,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        C: *const *mut f64,
        ldc: rocblas_int,
        X: *const *mut f64,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_float_complex,
        ldc: rocblas_int,
        X: *const *mut rocblas_float_complex,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrs_npvt_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        C: *const *mut rocblas_double_complex,
        ldc: rocblas_int,
        X: *const *mut rocblas_double_complex,
        ldx: rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRS_NPVT_STRIDED_BATCHED solves a batch of system of linear equations given by block\ntridiagonal matrices in its factorized form (without partial pivoting).\n\n\\details Each linear system has the form\n\n\\f[\nM_lX_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{l1}\\\\\nA_{l1} & B_{l2} & C_{l2}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_{l1}\\\\\nX_{l2}\\\\\nX_{l3}\\\\\n\\vdots\\\\\nX_{ln}\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_{l1}\\\\\nR_{l2}\\\\\nR_{l3}\\\\\n\\vdots\\\\\nR_{ln}\n\\end{array}\\right]=R_l\n\\f]\n\nwhere matrix \\f$M_l\\f$ has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_{li}\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \\f$M_l\\f$ should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_{li}.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nlda         rocblas_int. lda >= nb.\nSpecifies the leading dimension of blocks A_{li}.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use case is strideA >=\nlda*nb*nblocks\n@param[in]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nContains the blocks B_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= nb.\nSpecifies the leading dimension of blocks B_{li}.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use case is strideB >=\nldb*nb*nblocks\n@param[in]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nContains the blocks C_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_strided_batched \"GEBLTTRF_NPVT_STRIDED_BATCHED\".\n@param[in]\nldc         rocblas_int. ldc >= nb.\nSpecifies the leading dimension of blocks C_{li}.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block C_{li} to the same block in the next batch\ninstance C_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use case is strideC >=\nldc*nb*nblocks\n@param[inout]\nX           pointer to type. Array on the GPU (the size depends on the value of strideX).\nOn entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution\nvectors X_{li} on exit.\n@param[in]\nldx         rocblas_int. ldx >= nb.\nSpecifies the leading dimension of blocks X_{li}.\n@param[in]\nstrideX     rocblas_stride.\nStride from the start of one block X_{li} to the same block in the next batch\ninstance X_{(l+1)i}.\nThere is no restriction for the value of strideX. Normal use case is strideX >=\nldx*nblocks*nrhs\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f32,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f64,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_float_complex,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrs_npvt_strided_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_double_complex,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief GEBLTTRS_NPVT_INTERLEAVED_BATCHED solves a batch of system of linear equations given by block\ntridiagonal matrices in its factorized form (without partial pivoting).\n\n\\details Each linear system has the form\n\n\\f[\nM_lX_l = \\left[\\begin{array}{ccccc}\nB_{l1} & C_{ll}\\\\\nA_{l1} & B_{ll} & C_{ll}\\\\\n& \\ddots & \\ddots & \\ddots \\\\\n&  & A_{l(n-2)} & B_{l(n-1)} & C_{l(n-1)}\\\\\n&  &  & A_{l(n-1)} & B_{ln}\n\\end{array}\\right]\\left[\\begin{array}{c}\nX_{l1}\\\\\nX_{l2}\\\\\nX_{l3}\\\\\n\\vdots\\\\\nX_{ln}\n\\end{array}\\right]=\\left[\\begin{array}{c}\nR_{l1}\\\\\nR_{l2}\\\\\nR_{l3}\\\\\n\\vdots\\\\\nR_{ln}\n\\end{array}\\right]=R_l\n\\f]\n\nwhere matrix \\f$M_l\\f$ has \\f$n = \\mathrm{nblocks}\\f$ diagonal blocks of size nb, and the right-hand-side\nblocks \\f$R_{li}\\f$ are general blocks of size nb-by-nrhs. The blocks of matrix \\f$M_l\\f$ should be in\nthe factorized form as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nnb          rocblas_int. nb >= 0.\nThe number of rows and columns of each block.\n@param[in]\nnblocks     rocblas_int. nblocks >= 0.\nThe number of blocks along the diagonal of each matrix in the batch.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e., the number of columns of blocks R_{li}.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nContains the blocks A_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n@param[in]\ninca        rocblas_int. inca > 0.\nStride from the start of one row of A_{li} to the next. Normal use cases are\ninca = 1 (strided batched case) or inca = batch_count (interleaved batched case).\n@param[in]\nlda         rocblas_int. lda >= inca * nb.\nSpecifies the leading dimension of blocks A_{li}, i.e. the stride from the start\nof one column of A_{li} to the next.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one block A_{li} to the same block in the next batch\ninstance A_{(l+1)i}.\nThere is no restriction for the value of strideA. Normal use cases are strideA >=\nlda*nb*nblocks (strided batched case) or strideA = 1 (interleaved batched case).\n@param[in]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nContains the blocks B_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n@param[in]\nincb        rocblas_int. incb > 0.\nStride from the start of one row of B_{li} to the next. Normal use cases are\nincb = 1 (strided batched case) or incb = batch_count (interleaved batched case).\n@param[in]\nldb         rocblas_int. ldb >= incb * nb.\nSpecifies the leading dimension of blocks B_{li}, i.e. the stride from the start\nof one column of B_{li} to the next.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one block B_{li} to the same block in the next batch\ninstance B_{(l+1)i}.\nThere is no restriction for the value of strideB. Normal use cases are strideB >=\nldb*nb*nblocks (strided batched case) or strideB = 1 (interleaved batched case).\n@param[in]\nC           pointer to type. Array on the GPU (the size depends on the value of strideC).\nContains the blocks C_{li} as returned by \\ref rocsolver_sgeblttrf_npvt_interleaved_batched \"GEBLTTRF_NPVT_INTERLEAVED_BATCHED\".\n@param[in]\nincc        rocblas_int. incc > 0.\nStride from the start of one row of C_{li} to the next. Normal use cases are\nincc = 1 (strided batched case) or incc = batch_count (interleaved batched case).\n@param[in]\nldc         rocblas_int. ldc >= incc * nb.\nSpecifies the leading dimension of blocks C_{li}, i.e. the stride from the start\nof one column of C_{li} to the next.\n@param[in]\nstrideC     rocblas_stride.\nStride from the start of one block C_{li} to the same block in the next batch\ninstance C_{(l+1)i}.\nThere is no restriction for the value of strideC. Normal use cases are strideC >=\nldc*nb*nblocks (strided batched case) or strideC = 1 (interleaved batched case).\n@param[inout]\nX           pointer to type. Array on the GPU (the size depends on the value of strideX).\nOn entry, X contains the right-hand-side blocks R_{li}. It is overwritten by solution\nvectors X_{li} on exit.\n@param[in]\nincx        rocblas_int. incx > 0.\nStride from the start of one row of X_{li} to the next. Normal use cases are\nincx = 1 (strided batched case) or incx = batch_count (interleaved batched case).\n@param[in]\nldx         rocblas_int. ldx >= incx * nb.\nSpecifies the leading dimension of blocks X_{li}, i.e. the stride from the start\nof one column of X_{li} to the next.\n@param[in]\nstrideX     rocblas_stride.\nStride from the start of one block X_{li} to the same block in the next batch\ninstance X_{(l+1)i}.\nThere is no restriction for the value of strideX. Normal use cases are strideX >=\nldx*nrhs*nblocks (strided batched case) or strideX = 1 (interleaved batched case).\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_sgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f32,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f32,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f32,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut f64,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut f64,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut f64,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_cgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_float_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_float_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_float_complex,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zgeblttrs_npvt_interleaved_batched(
        handle: rocblas_handle,
        nb: rocblas_int,
        nblocks: rocblas_int,
        nrhs: rocblas_int,
        A: *mut rocblas_double_complex,
        inca: rocblas_int,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        incb: rocblas_int,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        C: *mut rocblas_double_complex,
        incc: rocblas_int,
        ldc: rocblas_int,
        strideC: rocblas_stride,
        X: *mut rocblas_double_complex,
        incx: rocblas_int,
        ldx: rocblas_int,
        strideX: rocblas_stride,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief CREATE_RFINFO initializes the structure rfinfo that contains the meta data and descriptors of the involved matrices\nrequired by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[out]\nrfinfo      #rocsolver_rfinfo.\nThe pointer to the rfinfo struct to be initialized.\n@param[in]\nhandle      rocblas_handle."]
    pub fn rocsolver_create_rfinfo(
        rfinfo: *mut rocsolver_rfinfo,
        handle: rocblas_handle,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief DESTROY_RFINFO destroys the structure rfinfo used by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nThe rfinfo struct to be destroyed."]
    pub fn rocsolver_destroy_rfinfo(rfinfo: rocsolver_rfinfo) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief SET_RFINFO_MODE sets the mode of the structure rfinfo required by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nThe rfinfo struct to be set up.\n@param[in]\nmode        #rocsolver_rfinfo_mode.\nUse rocsolver_rfinfo_mode_cholesky when the Cholesky factorization is required."]
    pub fn rocsolver_set_rfinfo_mode(
        rfinfo: rocsolver_rfinfo,
        mode: rocsolver_rfinfo_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " \\brief GET_RFINFO_MODE gets the mode of the structure rfinfo required by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nThe referenced rfinfo struct.\n@param[out]\nmode        #rocsolver_rfinfo_mode.\nThe queried mode."]
    pub fn rocsolver_get_rfinfo_mode(
        rfinfo: rocsolver_rfinfo,
        mode: *mut rocsolver_rfinfo_mode,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief CSRRF_SUMLU bundles the factors \\f$L\\f$ and \\f$U\\f$, associated with the LU factorization\nof a sparse matrix \\f$A\\f$, into a single sparse matrix \\f$T=(L-I)+U\\f$.\n\n\\details Factor \\f$L\\f$ is a sparse lower triangular matrix with unit diagonal elements, and\n\\f$U\\f$ is a sparse upper triangular matrix. The resulting sparse matrix \\f$T\\f$ combines both\nsparse factors without storing the unit diagonal; in other words, the number of non-zero\nelements of T, nnzT, is given by nnzT = nnzL - n + nnzU.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzL        rocblas_int. nnzL >= n.\nThe number of non-zero elements in L.\n@param[in]\nptrL        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indL and valL.\nThe last element of ptrL is equal to nnzL.\n@param[in]\nindL        pointer to rocblas_int. Array on the GPU of dimension nnzL.\nIt contains the column indices of the non-zero elements of L. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalL        pointer to type. Array on the GPU of dimension nnzL.\nThe values of the non-zero elements of L.\n@param[in]\nnnzU        rocblas_int. nnzU >= 0.\nThe number of non-zero elements in U.\n@param[in]\nptrU        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indU and valU.\nThe last element of ptrU is equal to nnzU.\n@param[in]\nindU        pointer to rocblas_int. Array on the GPU of dimension nnzU.\nIt contains the column indices of the non-zero elements of U. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalU        pointer to type. Array on the GPU of dimension nnzU.\nThe values of the non-zero elements of U.\n@param[out]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[out]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[out]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T."]
    pub fn rocsolver_scsrrf_sumlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzL: rocblas_int,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f32,
        nnzU: rocblas_int,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f32,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dcsrrf_sumlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzL: rocblas_int,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f64,
        nnzU: rocblas_int,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f64,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief CSRRF_SPLITLU splits the factors \\f$L\\f$ and \\f$U\\f$, associated with the LU factorization\nof a sparse matrix \\f$A\\f$, from a bundled matrix \\f$T=(L-I)+U\\f$.\n\n\\details Factor \\f$L\\f$ is a sparse lower triangular matrix with unit diagonal elements, and\n\\f$U\\f$ is a sparse upper triangular matrix. Conceptually, on input, U is stored on the diagonal\nand upper part of \\f$T\\f$, while the non diagonal elements of \\f$L\\f$ are stored on the strictly\nlower part of \\f$T\\f$.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T.\n@param[out]\nptrL        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indL and valL.\nThe last element of ptrL is equal to nnzL.\n@param[out]\nindL        pointer to rocblas_int. Array on the GPU of dimension nnzL.\nIt contains the column indices of the non-zero elements of L. Indices are\nsorted by row and by column within each row. (If nnzL is not known in advance,\nthe size of this array could be set to nnzT + n as an upper bound).\n@param[out]\nvalL        pointer to type. Array on the GPU of dimension nnzL.\nThe values of the non-zero elements of L. (If nnzL is not known in advance,\nthe size of this array could be set to nnzT + n as an upper bound).\n@param[out]\nptrU        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indU and valU.\nThe last element of ptrU is equal to nnzU.\n@param[out]\nindU        pointer to rocblas_int. Array on the GPU of dimension nnzU.\nIt contains the column indices of the non-zero elements of U. Indices are\nsorted by row and by column within each row. (If nnzU is not known in advance,\nthe size of this array could be set to nnzT as an upper bound).\n@param[out]\nvalU        pointer to type. Array on the GPU of dimension nnzU.\nThe values of the non-zero elements of U. (If nnzU is not known in advance,\nthe size of this array could be set to nnzT as an upper bound)."]
    pub fn rocsolver_scsrrf_splitlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f32,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f32,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dcsrrf_splitlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        ptrL: *mut rocblas_int,
        indL: *mut rocblas_int,
        valL: *mut f64,
        ptrU: *mut rocblas_int,
        indU: *mut rocblas_int,
        valU: *mut f64,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief CSRRF_ANALYSIS performs the analysis phase required by the re-factorization functions\n\\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" and \\ref rocsolver_scsrrf_refactchol \"CSRRF_REFACTCHOL\", and\nby the direct solver \\ref rocsolver_scsrrf_solve \"CSRRF_SOLVE\".\n\n\\details Consider a sparse matrix \\f$M\\f$ previously factorized as\n\n\\f[\nQ^TMQ = L_ML_M^T\n\\f]\n\n(Cholesky factorization for the symmetric positive definite case), or\n\n\\f[\nPMQ = L_MU_M\n\\f]\n\n(LU factorization for the general case)\n\nwhere \\f$L_M\\f$ is lower triangular (with unit diagonal in the general case), \\f$U_M\\f$ is upper triangular, and \\f$P\\f$\nand \\f$Q\\f$ are permutation matrices associated with pivoting and re-ordering (to minimize\nfill-in), respectively. The meta data generated by this routine is collected in the output parameter\nrfinfo. This information will allow the fast re-factorization of another sparse matrix \\f$A\\f$ as\n\n\\f[\nQ^TAQ = L_AL_A^T, \\quad \\text{or}\n\\f]\n\n\\f[\nPAQ = L_AU_A,\n\\f]\n\nand, eventually, the computation of the solution vector \\f$X\\f$ of any linear system of the form\n\n\\f[\nAX = B\n\\f]\n\nas long as \\f$A\\f$ has the same sparsity pattern as the previous matrix \\f$M\\f$.\n\nThis function supposes that the rfinfo struct has been initialized by \\ref rocsolver_create_rfinfo \"RFINFO_CREATE\".\nBy default, rfinfo is set up to work with the LU factorization (general matrices). If the matrix is symmetric positive definite,\nand the Cholesky factorization is\ndesired, then the corresponding mode must be manually set up by \\ref rocsolver_set_rfinfo_mode \"SET_RFINFO_MODE\". This function\ndoes not automatically detect symmetry.\n\nFor the LU factorization mode, the LU factors \\f$L_M\\f$ and \\f$U_M\\f$ must be passed in a bundle\nmatrix \\f$T=(L_M-I)+U_M\\f$ as returned by \\ref rocsolver_scsrrf_sumlu \"CSRRF_SUMLU\". For the Cholesky mode,\nthe lower triangular part of \\f$T\\f$ must contain the Cholesky factor \\f$L_M\\f$; the strictly upper triangular\npart of \\f$T\\f$ will be ignored. Similarly, the strictly upper triangular part of \\f$M\\f$ is ignored when working\nin Cholesky mode.\n\n\\note\nIf only a re-factorization will be executed (i.e. no solver phase), then nrhs can be set to zero\nand B can be null.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix M.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right-hand-sides (columns of matrix B). Set nrhs to zero when only the\nre-factorization is needed.\n@param[in]\nnnzM        rocblas_int. nnzM >= 0.\nThe number of non-zero elements in M.\n@param[in]\nptrM        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indM and valM.\nThe last element of ptrM is equal to nnzM.\n@param[in]\nindM        pointer to rocblas_int. Array on the GPU of dimension nnzM.\nIt contains the column indices of the non-zero elements of M. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalM        pointer to type. Array on the GPU of dimension nnzM.\nThe values of the non-zero elements of M. The strictly upper triangular entries are\nnot referenced when working in Cholesky mode.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T. The strictly upper triangular entries are\nnot referenced when working in Cholesky mode.\n@param[in]\npivP        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix P, i.e. the\norder in which the rows of matrix M were re-arranged. When working in Cholesky mode,\nthis array is not referenced and can be null.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix M were re-arranged.\n@param[in]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nThe right hand side matrix B. It can be null if only the re-factorization is needed.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[out]\nrfinfo      rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_analysis(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzM: rocblas_int,
        ptrM: *mut rocblas_int,
        indM: *mut rocblas_int,
        valM: *mut f32,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dcsrrf_analysis(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzM: rocblas_int,
        ptrM: *mut rocblas_int,
        indM: *mut rocblas_int,
        valM: *mut f64,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief CSRRF_REFACTLU performs a fast LU factorization of a sparse matrix \\f$A\\f$ based on the\ninformation from the factorization of a previous matrix \\f$M\\f$ with the same sparsity pattern\n(re-factorization).\n\n\\details Consider a sparse matrix \\f$M\\f$ previously factorized as\n\n\\f[\nPMQ = L_MU_M\n\\f]\n\nwhere \\f$L_M\\f$ is lower triangular with unit diagonal, \\f$U_M\\f$ is upper triangular, and \\f$P\\f$\nand \\f$Q\\f$ are permutation matrices associated with pivoting and re-ordering (to minimize\nfill-in), respectively. If \\f$A\\f$ has the same sparsity pattern as \\f$M\\f$, then the re-factorization\n\n\\f[\nPAQ = L_AU_A\n\\f]\n\ncan be computed numerically without a symbolic analysis phase.\n\nThis function supposes that rfinfo has been updated, by function \\ref rocsolver_scsrrf_analysis \"CSRRF_ANALYSIS\",\nafter the analysis phase of the previous matrix M and its initial factorization. Both functions, CSRRF_ANALYSIS and\nCSRRF_REFACTLU must be run with the same rfinfo mode (LU factorization, the default mode), otherwise the workflow will\nresult in an error.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzA        rocblas_int. nnzA >= 0.\nThe number of non-zero elements in A.\n@param[in]\nptrA        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indA and valA.\nThe last element of ptrM is equal to nnzA.\n@param[in]\nindA        pointer to rocblas_int. Array on the GPU of dimension nnzA.\nIt contains the column indices of the non-zero elements of M. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalA        pointer to type. Array on the GPU of dimension nnzA.\nThe values of the non-zero elements of A.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[out]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of the new bundle matrix (L_A - I) + U_A.\n@param[in]\npivP        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix P, i.e. the\norder in which the rows of matrix M were re-arranged.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix M were re-arranged.\n@param[in]\nrfinfo      rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_refactlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f32,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dcsrrf_refactlu(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f64,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief CSRRF_REFACTCHOL performs a fast Cholesky factorization of a sparse symmetric positive definite matrix \\f$A\\f$\nbased on the information from the factorization of a previous matrix \\f$M\\f$ with the same sparsity pattern\n(re-factorization).\n\n\\details Consider a sparse matrix \\f$M\\f$ previously factorized as\n\n\\f[\nQ^TMQ = L_ML_M^T\n\\f]\n\nwhere \\f$L_M\\f$ is lower triangular, and \\f$Q\\f$ is a permutation matrices associated with re-ordering to minimize\nfill-in. If \\f$A\\f$ has the same sparsity pattern as \\f$M\\f$, then the re-factorization\n\n\\f[\nQ^TAQ = L_AL_A^T\n\\f]\n\ncan be computed numerically without a symbolic analysis phase.\n\nThis function supposes that rfinfo has been updated by function \\ref rocsolver_scsrrf_analysis \"CSRRF_ANALYSIS\",\nafter the analysis phase of the previous matrix M and its initial factorization. Both functions, CSRRF_ANALYSIS and\nCSRRF_REFACTCHOL must be run with the same rfinfo mode (Cholesky factorization), otherwise the workflow will\nresult in an error.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnnzA        rocblas_int. nnzA >= 0.\nThe number of non-zero elements in A.\n@param[in]\nptrA        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indA and valA.\nThe last element of ptrM is equal to nnzA.\n@param[in]\nindA        pointer to rocblas_int. Array on the GPU of dimension nnzA.\nIt contains the column indices of the non-zero elements of M. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalA        pointer to type. Array on the GPU of dimension nnzA.\nThe values of the non-zero elements of A. The strictly upper triangular entries are\nnot referenced.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[out]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of the new Cholesky factor L_A.\nThe strictly upper triangular entries of this array are not referenced.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix M were re-arranged.\n@param[in]\nrfinfo      #rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_refactchol(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f32,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dcsrrf_refactchol(
        handle: rocblas_handle,
        n: rocblas_int,
        nnzA: rocblas_int,
        ptrA: *mut rocblas_int,
        indA: *mut rocblas_int,
        valA: *mut f64,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivQ: *mut rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief CSRRF_SOLVE solves a linear system with sparse coefficient matrix \\f$A\\f$ in its\nfactorized form.\n\n\\details The linear system is of the form\n\n\\f[\nAX = B\n\\f]\n\nwhere the sparse matrix \\f$A\\f$ is factorized as\n\n\\f[\nQ^TAQ = L_AL_A^T\n\\f]\n\n(Cholesky factorization for the symmetric positive definite case), or\n\n\\f[\nPAQ = L_AU_A\n\\f]\n\n(LU factorization for the general case),\n\nand \\f$B\\f$ is a dense matrix of right hand sides.\n\nThis function supposes that rfinfo has been updated by function \\ref rocsolver_scsrrf_analysis \"CSRRF_ANALYSIS\",\nafter the analysis phase. Both functions, CSRRF_ANALYSIS and\nCSRRF_SOLVE must be run with the same rfinfo mode (LU or Cholesky factorization), otherwise the workflow will\nresult in an error.\n\nFor the LU factorization mode, the LU factors \\f$L_A\\f$ and \\f$U_A\\f$ must be passed in a bundle matrix \\f$T=(L_A-I)+U_A\\f$\nas returned by \\ref rocsolver_scsrrf_refactlu \"CSRRF_REFACTLU\" or \\ref rocsolver_scsrrf_sumlu \"CSRRF_SUMLU\". For the Cholesky mode,\nthe lower triangular part of \\f$T\\f$ must contain the Cholesky factor \\f$L_A\\f$; the strictly upper triangular\npart of \\f$T\\f$ will be ignored.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nn           rocblas_int. n >= 0.\nThe number of rows (and columns) of matrix A.\n@param[in]\nnrhs        rocblas_int. nrhs >= 0.\nThe number of right hand sides, i.e. the number of columns of matrix B.\n@param[in]\nnnzT        rocblas_int. nnzT >= 0.\nThe number of non-zero elements in T.\n@param[in]\nptrT        pointer to rocblas_int. Array on the GPU of dimension n+1.\nIt contains the positions of the beginning of each row in indT and valT.\nThe last element of ptrT is equal to nnzT.\n@param[in]\nindT        pointer to rocblas_int. Array on the GPU of dimension nnzT.\nIt contains the column indices of the non-zero elements of T. Indices are\nsorted by row and by column within each row.\n@param[in]\nvalT        pointer to type. Array on the GPU of dimension nnzT.\nThe values of the non-zero elements of T. The strictly upper triangular entries are\nnot referenced when working in Cholesky mode.\n@param[in]\npivP        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix P, i.e. the\norder in which the rows of matrix A were re-arranged. When working in Cholesky mode,\nthis array is not referenced and can be null.\n@param[in]\npivQ        pointer to rocblas_int. Array on the GPU of dimension n.\nContains the pivot indices representing the permutation matrix Q, i.e. the\norder in which the columns of matrix A were re-arranged.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\nOn entry the right hand side matrix B. On exit, the solution matrix X.\n@param[in]\nldb         rocblas_int. ldb >= n.\nThe leading dimension of B.\n@param[in]\nrfinfo      rocsolver_rfinfo.\nStructure that holds the meta data generated in the analysis phase."]
    pub fn rocsolver_scsrrf_solve(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f32,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dcsrrf_solve(
        handle: rocblas_handle,
        n: rocblas_int,
        nrhs: rocblas_int,
        nnzT: rocblas_int,
        ptrT: *mut rocblas_int,
        indT: *mut rocblas_int,
        valT: *mut f64,
        pivP: *mut rocblas_int,
        pivQ: *mut rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        rfinfo: rocsolver_rfinfo,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVDX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a\nreal symmetric matrix A.\n\n\\details\nThis function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the algorithm did not converge. i columns of Z did not converge."]
    pub fn rocsolver_ssyevdx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevdx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVDX computes a set of the eigenvalues and optionally the corresponding eigenvectors of a\nHermitian matrix A.\n\n\\details\nThis function computes all the eigenvalues of A, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrix A is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrix A.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i > 0, the algorithm did not converge. i columns of Z did not converge."]
    pub fn rocsolver_cheevdx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevdx(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVDX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of real symmetric matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevdx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut f32,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevdx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut f64,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVDX_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of Hermitian matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevdx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_float_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevdx_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_double_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYEVDX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of real symmetric matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssyevdx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut f32,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsyevdx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut f64,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEEVDX_STRIDED_BATCHED computes a set of the eigenvalues and optionally the corresponding eigenvectors\nof a batch of Hermitian matrices A_l.\n\n\\details\nThis function computes all the eigenvalues of A_l, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower part of the symmetric matrices A_l is stored.\nIf uplo indicates lower (or upper), then the upper (or lower) part of A_l\nis not used.\n@param[in]\nn           rocblas_int. n >= 0.\nNumber of rows and columns of matrices A_l.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit for matrix A_l.\nIf info[l] = i > 0, the algorithm did not converge. i columns of Z_l did not converge.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_cheevdx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zheevdx_strided_batched(
        handle: rocblas_handle,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVDX computes a set of the eigenvalues and optionally the corresponding eigenvectors of\na real generalized symmetric-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^T B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^T B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i columns of Z did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_ssygvdx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        B: *mut f32,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut f32,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvdx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        B: *mut f64,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut f64,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVDX computes a set of the eigenvalues and optionally the corresponding eigenvectors of\na complex generalized hermitian-definite eigenproblem.\n\n\\details\nThe problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = \\lambda B X & \\: \\text{1st form,}\\\\\nA B X = \\lambda X & \\: \\text{2nd form, or}\\\\\nB A X = \\lambda X & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix Z of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ^H B Z=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ^H B^{-1} Z=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblem.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA and B are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A and B are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\nOn entry, the matrix A. On exit, the contents of A are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrix A.\n@param[out]\nB           pointer to type. Array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrix B. On exit, the\ntriangular factor of B as returned by \\ref rocsolver_spotrf \"POTRF\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to a rocblas_int on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev = n.\nIf erange is rocblas_erange_index, nev = iu - il + 1. Otherwise, 0 <= nev <= n.\n@param[out]\nW           pointer to real type. Array on the GPU of dimension n.\nThe first nev elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[out]\nZ           pointer to type. Array on the GPU of dimension ldz*nev.\nOn exit, if evect is not rocblas_evect_none and info = 0, the first nev columns contain\nthe eigenvectors of A corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev are not known in advance.\nThe user should ensure that Z is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrix Z.\n@param[out]\ninfo        pointer to a rocblas_int on the GPU.\nIf info = 0, successful exit.\nIf info = i <= n, i columns of Z did not converge.\nIf info = n + i, the leading minor of order i of B is not\npositive definite."]
    pub fn rocsolver_chegvdx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvdx(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVDX_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvdx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f32,
        lda: rocblas_int,
        B: *const *mut f32,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut f32,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvdx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut f64,
        lda: rocblas_int,
        B: *const *mut f64,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut f64,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVDX_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*n.\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_batched \"POTRF_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldz*nev[l].\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch instance l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvdx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_float_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_float_complex,
        ldb: rocblas_int,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_float_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvdx_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *const *mut rocblas_double_complex,
        lda: rocblas_int,
        B: *const *mut rocblas_double_complex,
        ldb: rocblas_int,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *const *mut rocblas_double_complex,
        ldz: rocblas_int,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief SYGVDX_STRIDED_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of real generalized symmetric-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^T B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^T B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the symmetric positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nvl          type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_ssygvdx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f32,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f32,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut f32,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_dsygvdx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut f64,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut f64,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut f64,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    #[doc = " @{\n\\brief HEGVDX_STRIDED_BATCHED computes a set of the eigenvalues and optionally\nthe corresponding eigenvectors of a batch of complex generalized hermitian-definite eigenproblems.\n\n\\details\nFor each instance in the batch, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_l X_l = \\lambda B_l X_l & \\: \\text{1st form,}\\\\\nA_l B_l X_l = \\lambda X_l & \\: \\text{2nd form, or}\\\\\nB_l A_l X_l = \\lambda X_l & \\: \\text{3rd form,}\n\\end{array}\n\\f]\n\ndepending on the value of itype. The eigenvectors are computed depending on the\nvalue of evect.\n\nWhen computed, the matrix \\f$Z_l\\f$ of eigenvectors is normalized as follows:\n\n\\f[\n\\begin{array}{cl}\nZ_l^H B_l^{} Z_l^{}=I & \\: \\text{if 1st or 2nd form, or}\\\\\nZ_l^H B_l^{-1} Z_l^{}=I & \\: \\text{if 3rd form.}\n\\end{array}\n\\f]\n\nThis function computes all the eigenvalues, all the eigenvalues in the half-open interval \\f$(vl, vu]\\f$,\nor the il-th through iu-th eigenvalues, depending on the value of erange. If evect is rocblas_evect_original,\nthe eigenvectors for these eigenvalues will be computed as well. The eigenvectors are computed using a\ndivide-and-conquer approach.\n\n@param[in]\nhandle      rocblas_handle.\n@param[in]\nitype       #rocblas_eform.\nSpecifies the form of the generalized eigenproblems.\n@param[in]\nevect       #rocblas_evect.\nSpecifies whether the eigenvectors are to be computed.\nIf evect is rocblas_evect_original, then the eigenvectors are computed.\nrocblas_evect_tridiagonal is not supported.\n@param[in]\nerange      #rocblas_erange.\nSpecifies the type of range or interval of the eigenvalues to be computed.\n@param[in]\nuplo        rocblas_fill.\nSpecifies whether the upper or lower parts of the matrices\nA_l and B_l are stored. If uplo indicates lower (or upper),\nthen the upper (or lower) parts of A_l and B_l are not used.\n@param[in]\nn           rocblas_int. n >= 0.\nThe matrix dimensions.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\nOn entry, the matrices A_l. On exit, the contents of A_l are destroyed.\n@param[in]\nlda         rocblas_int. lda >= n.\nSpecifies the leading dimension of matrices A_l.\n@param[in]\nstrideA     rocblas_stride.\nStride from the start of one matrix A_l to the next one A_(l+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\nOn entry, the hermitian positive definite matrices B_l. On exit, the\ntriangular factor of B_l as returned by \\ref rocsolver_spotrf_strided_batched \"POTRF_STRIDED_BATCHED\".\n@param[in]\nldb         rocblas_int. ldb >= n.\nSpecifies the leading dimension of B_l.\n@param[in]\nstrideB     rocblas_stride.\nStride from the start of one matrix B_l to the next one B_(l+1).\nThere is no restriction for the value of strideB. Normal use is strideB >= ldb*n.\n@param[in]\nvl          real type. vl < vu.\nThe lower bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nvu          real type. vl < vu.\nThe upper bound of the search interval (vl, vu]. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues within a set of indices.\n@param[in]\nil          rocblas_int. il = 1 if n = 0; 1 <= il <= iu otherwise.\nThe index of the smallest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[in]\niu          rocblas_int. iu = 0 if n = 0; 1 <= il <= iu otherwise..\nThe index of the largest eigenvalue to be computed. Ignored if range indicates to look\nfor all the eigenvalues of A_l or the eigenvalues in a half-open interval.\n@param[out]\nnev         pointer to rocblas_int. Array of batch_count integers on the GPU.\nThe total number of eigenvalues found. If erange is rocblas_erange_all, nev[l] = n.\nIf erange is rocblas_erange_index, nev[l] = iu - il + 1. Otherwise, 0 <= nev[l] <= n.\n@param[out]\nW           pointer to real type. Array on the GPU (the size depends on the value of strideW).\nThe first nev[l] elements contain the computed eigenvalues. (The remaining elements\ncan be used as workspace for internal computations).\n@param[in]\nstrideW     rocblas_stride.\nStride from the start of one vector W_l to the next one W_(l+1).\nThere is no restriction for the value of strideW. Normal use case is strideW >= n.\n@param[out]\nZ           pointer to type. Array on the GPU (the size depends on the value of strideZ).\nOn exit, if evect is not rocblas_evect_none and info[l] = 0, the first nev[l] columns contain\nthe eigenvectors of A_l corresponding to the output eigenvalues. Not referenced if\nevect is rocblas_evect_none.\n@param[in]\nldz         rocblas_int. ldz >= n.\nSpecifies the leading dimension of matrices Z_l.\n@param[in]\nstrideZ     rocblas_stride.\nStride from the start of one matrix Z_l to the next one Z_(l+1).\nThere is no restriction for the value of strideZ. Normal use case is strideZ >= ldz*nev[l].\nNote: If erange is rocblas_range_value, then the values of nev[l] are not known in advance.\nThe user should ensure that Z_l is large enough to hold n columns, as all n columns\ncan be used as workspace for internal computations.\n@param[out]\ninfo        pointer to rocblas_int. Array of batch_count integers on the GPU.\nIf info[l] = 0, successful exit of batch l.\nIf info[l] = i <= n, i columns of Z_l did not converge.\nIf info[l] = n + i, the leading minor of order i of B_l is not\npositive definite.\n@param[in]\nbatch_count rocblas_int. batch_count >= 0.\nNumber of matrices in the batch."]
    pub fn rocsolver_chegvdx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_float_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_float_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f32,
        vu: f32,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f32,
        strideW: rocblas_stride,
        Z: *mut rocblas_float_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
unsafe extern "C" {
    pub fn rocsolver_zhegvdx_strided_batched(
        handle: rocblas_handle,
        itype: rocblas_eform,
        evect: rocblas_evect,
        erange: rocblas_erange,
        uplo: rocblas_fill,
        n: rocblas_int,
        A: *mut rocblas_double_complex,
        lda: rocblas_int,
        strideA: rocblas_stride,
        B: *mut rocblas_double_complex,
        ldb: rocblas_int,
        strideB: rocblas_stride,
        vl: f64,
        vu: f64,
        il: rocblas_int,
        iu: rocblas_int,
        nev: *mut rocblas_int,
        W: *mut f64,
        strideW: rocblas_stride,
        Z: *mut rocblas_double_complex,
        ldz: rocblas_int,
        strideZ: rocblas_stride,
        info: *mut rocblas_int,
        batch_count: rocblas_int,
    ) -> rocblas_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_39 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_40 {
    pub _address: u8,
}
