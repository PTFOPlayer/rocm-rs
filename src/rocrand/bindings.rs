/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const __HIP_ARCH_HAS_GLOBAL_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_FLOAT_ATOMIC_ADD__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_DOUBLES__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_VOTE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_BALLOT__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_SHUFFLE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_FUNNEL_SHIFT__: u32 = 0;
pub const __HIP_ARCH_HAS_THREAD_FENCE_SYSTEM__: u32 = 0;
pub const __HIP_ARCH_HAS_SYNC_THREAD_EXT__: u32 = 0;
pub const __HIP_ARCH_HAS_SURFACE_FUNCS__: u32 = 0;
pub const __HIP_ARCH_HAS_3DGRID__: u32 = 0;
pub const __HIP_ARCH_HAS_DYNAMIC_PARALLEL__: u32 = 0;
pub const __HIP_CLANG_ONLY__: u32 = 0;
pub const GENERIC_GRID_LAUNCH: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __GNU_LIBRARY__: u32 = 6;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _STL_ALGOBASE_H: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _PSTL_VERSION: u32 = 12000;
pub const _PSTL_VERSION_MAJOR: u32 = 12;
pub const _PSTL_VERSION_MINOR: u32 = 0;
pub const _PSTL_VERSION_PATCH: u32 = 0;
pub const _PSTL_USAGE_WARNINGS: u32 = 0;
pub const _PSTL_UDR_PRESENT: u32 = 0;
pub const _PSTL_PRAGMA_LOCATION: &[u8; 26] = b" [Parallel STL message]: \0";
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _FUNCTEXCEPT_H: u32 = 1;
pub const _EXCEPTION_DEFINES_H: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _EXT_NUMERIC_TRAITS: u32 = 1;
pub const _STL_PAIR_H: u32 = 1;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const _MOVE_H: u32 = 1;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
pub const _CONCEPT_CHECK_H: u32 = 1;
pub const _STL_ITERATOR_H: u32 = 1;
pub const _PTR_TRAITS_H: u32 = 1;
pub const __cpp_lib_array_constexpr: u32 = 201803;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const _STL_ALGO_H: u32 = 1;
pub const _STL_HEAP_H: u32 = 1;
pub const _STL_TEMPBUF_H: u32 = 1;
pub const __EXCEPTION_H: u32 = 1;
pub const __cpp_lib_launder: u32 = 201606;
pub const _STL_CONSTRUCT_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const __cpp_lib_clamp: u32 = 201603;
pub const __cpp_lib_sample: u32 = 201603;
pub const _PSTL_ALGORITHM_FORWARD_DECLARED: u32 = 1;
pub const __cpp_lib_parallel_algorithm: u32 = 201603;
pub const _STL_RELOPS_H: u32 = 1;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_as_const: u32 = 201510;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _PRINTF_NAN_LEN_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _REQUIRES_FREESTANDING_H: u32 = 1;
pub const _STRINGFWD_H: u32 = 1;
pub const _MEMORYFWD_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const _USES_ALLOCATOR_H: u32 = 1;
pub const __cpp_lib_apply: u32 = 201603;
pub const __cpp_lib_make_from_tuple: u32 = 201606;
pub const _FUNCTIONAL_HASH_H: u32 = 1;
pub const _HASH_BYTES_H: u32 = 1;
pub const _STL_FUNCTION_H: u32 = 1;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const _BACKWARD_BINDERS_H: u32 = 1;
pub const _UNIQUE_PTR_H: u32 = 1;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __GTHREADS: u32 = 1;
pub const __GTHREADS_CXX0X: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_NEWTIME: u32 = 128;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const __SC_THREAD_STACK_MIN_VALUE: u32 = 75;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const __GTHREAD_HAS_COND: u32 = 1;
pub const __GTHREAD_ONCE_INIT: u32 = 0;
pub const __cpp_lib_chrono: u32 = 201611;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const HIP_VERSION_MAJOR: u32 = 6;
pub const HIP_VERSION_MINOR: u32 = 3;
pub const HIP_VERSION_PATCH: u32 = 42134;
pub const HIP_VERSION_GITHASH: &[u8; 10] = b"a9a80e791\0";
pub const HIP_VERSION_BUILD_ID: u32 = 0;
pub const HIP_VERSION_BUILD_NAME: &[u8; 1] = b"\0";
pub const HIP_VERSION: u32 = 60342134;
pub const __HIP_HAS_GET_PCH: u32 = 1;
pub const __cpp_lib_byte: u32 = 201603;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __FP_LONG_MAX: u64 = 9223372036854775807;
pub const FP_LLOGB0: i64 = -9223372036854775808;
pub const FP_LLOGBNAN: i64 = -9223372036854775808;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_Ef: f64 = 2.718281828459045;
pub const M_LOG2Ef: f64 = 1.4426950408889634;
pub const M_LOG10Ef: f64 = 0.4342944819032518;
pub const M_LN2f: f64 = 0.6931471805599453;
pub const M_LN10f: f64 = 2.302585092994046;
pub const M_PIf: f64 = 3.141592653589793;
pub const M_PI_2f: f64 = 1.5707963267948966;
pub const M_PI_4f: f64 = 0.7853981633974483;
pub const M_1_PIf: f64 = 0.3183098861837907;
pub const M_2_PIf: f64 = 0.6366197723675814;
pub const M_2_SQRTPIf: f64 = 1.1283791670955126;
pub const M_SQRT2f: f64 = 1.4142135623730951;
pub const M_SQRT1_2f: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const __cpp_lib_hypot: u32 = 201603;
pub const __STDCPP_MATH_SPEC_FUNCS__: u32 = 201003;
pub const __cpp_lib_math_special_functions: u32 = 201603;
pub const HIP_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const HIP_TRSF_READ_AS_INTEGER: u32 = 1;
pub const HIP_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const HIP_TRSF_SRGB: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const BOOL_MAX: u32 = 1;
pub const BOOL_WIDTH: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const __HIP_USE_NATIVE_VECTOR__: u32 = 1;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const hipTextureType1D: u32 = 1;
pub const hipTextureType2D: u32 = 2;
pub const hipTextureType3D: u32 = 3;
pub const hipTextureTypeCubemap: u32 = 12;
pub const hipTextureType1DLayered: u32 = 241;
pub const hipTextureType2DLayered: u32 = 242;
pub const hipTextureTypeCubemapLayered: u32 = 252;
pub const HIP_IMAGE_OBJECT_SIZE_DWORD: u32 = 12;
pub const HIP_SAMPLER_OBJECT_SIZE_DWORD: u32 = 8;
pub const HIP_SAMPLER_OBJECT_OFFSET_DWORD: u32 = 12;
pub const HIP_TEXTURE_OBJECT_SIZE_DWORD: u32 = 20;
pub const HIP_DEPRECATED_MSG : & [u8 ; 189] = b"This API is marked as deprecated and might not be supported in future releases. For more details please refer https://github.com/ROCm/HIP/blob/develop/docs/reference/deprecated_api_list.md\0" ;
pub const hipIpcMemLazyEnablePeerAccess: u32 = 1;
pub const HIP_IPC_HANDLE_SIZE: u32 = 64;
pub const hipStreamDefault: u32 = 0;
pub const hipStreamNonBlocking: u32 = 1;
pub const hipEventDefault: u32 = 0;
pub const hipEventBlockingSync: u32 = 1;
pub const hipEventDisableTiming: u32 = 2;
pub const hipEventInterprocess: u32 = 4;
pub const hipEventDisableSystemFence: u32 = 536870912;
pub const hipEventReleaseToDevice: u32 = 1073741824;
pub const hipEventReleaseToSystem: u32 = 2147483648;
pub const hipHostMallocDefault: u32 = 0;
pub const hipHostAllocDefault: u32 = 0;
pub const hipHostMallocPortable: u32 = 1;
pub const hipHostAllocPortable: u32 = 1;
pub const hipHostMallocMapped: u32 = 2;
pub const hipHostAllocMapped: u32 = 2;
pub const hipHostMallocWriteCombined: u32 = 4;
pub const hipHostAllocWriteCombined: u32 = 4;
pub const hipHostMallocNumaUser: u32 = 536870912;
pub const hipHostMallocCoherent: u32 = 1073741824;
pub const hipHostMallocNonCoherent: u32 = 2147483648;
pub const hipMemAttachGlobal: u32 = 1;
pub const hipMemAttachHost: u32 = 2;
pub const hipMemAttachSingle: u32 = 4;
pub const hipDeviceMallocDefault: u32 = 0;
pub const hipDeviceMallocFinegrained: u32 = 1;
pub const hipMallocSignalMemory: u32 = 2;
pub const hipDeviceMallocUncached: u32 = 3;
pub const hipDeviceMallocContiguous: u32 = 4;
pub const hipHostRegisterDefault: u32 = 0;
pub const hipHostRegisterPortable: u32 = 1;
pub const hipHostRegisterMapped: u32 = 2;
pub const hipHostRegisterIoMemory: u32 = 4;
pub const hipHostRegisterReadOnly: u32 = 8;
pub const hipExtHostRegisterCoarseGrained: u32 = 8;
pub const hipDeviceScheduleAuto: u32 = 0;
pub const hipDeviceScheduleSpin: u32 = 1;
pub const hipDeviceScheduleYield: u32 = 2;
pub const hipDeviceScheduleBlockingSync: u32 = 4;
pub const hipDeviceScheduleMask: u32 = 7;
pub const hipDeviceMapHost: u32 = 8;
pub const hipDeviceLmemResizeToMax: u32 = 16;
pub const hipArrayDefault: u32 = 0;
pub const hipArrayLayered: u32 = 1;
pub const hipArraySurfaceLoadStore: u32 = 2;
pub const hipArrayCubemap: u32 = 4;
pub const hipArrayTextureGather: u32 = 8;
pub const hipOccupancyDefault: u32 = 0;
pub const hipOccupancyDisableCachingOverride: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const hipExtAnyOrderLaunch: u32 = 1;
pub const hipStreamWaitValueGte: u32 = 0;
pub const hipStreamWaitValueEq: u32 = 1;
pub const hipStreamWaitValueAnd: u32 = 2;
pub const hipStreamWaitValueNor: u32 = 3;
pub const hipExternalMemoryDedicated: u32 = 1;
pub const hipGraphKernelNodePortDefault: u32 = 0;
pub const hipGraphKernelNodePortLaunchCompletion: u32 = 2;
pub const hipGraphKernelNodePortProgrammatic: u32 = 1;
pub const USE_PEER_NON_UNIFIED: u32 = 1;
pub const ROCRAND_VERSION: u32 = 300200;
pub const ROCRAND_DEFAULT_MAX_BLOCK_SIZE: u32 = 256;
#[doc = " \\brief Represents a discrete probability distribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocrand_discrete_distribution_st {
    #[doc = " Number of entries in the probability table"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " The distribution can be offset"]
    pub offset: ::std::os::raw::c_uint,
    #[doc = " Alias table"]
    pub alias: *mut ::std::os::raw::c_uint,
    #[doc = "Probability data for the alias table"]
    pub probability: *mut f64,
    #[doc = " Cumulative distribution function"]
    pub cdf: *mut f64,
}
pub type rocrand_discrete_distribution = *mut rocrand_discrete_distribution_st;
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_stringstream {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt28__throw_bad_array_new_lengthv"]
    pub fn std___throw_bad_array_new_length() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___true_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___false_type {
    pub _address: u8,
}
pub type std___truth_type___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___traitor {
    pub _address: u8,
}
pub const std___traitor___value: std___traitor__bindgen_ty_1 = 0;
pub type std___traitor__bindgen_ty_1 = i32;
pub type std___traitor___type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___are_same {
    pub _address: u8,
}
pub const std___are_same___value: std___are_same__bindgen_ty_1 = 0;
pub type std___are_same__bindgen_ty_1 = i32;
pub type std___are_same___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void {
    pub _address: u8,
}
pub const std___is_void___value: std___is_void__bindgen_ty_1 = 0;
pub type std___is_void__bindgen_ty_1 = i32;
pub type std___is_void___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integer {
    pub _address: u8,
}
pub const std___is_integer___value: std___is_integer__bindgen_ty_1 = 0;
pub type std___is_integer__bindgen_ty_1 = i32;
pub type std___is_integer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating {
    pub _address: u8,
}
pub const std___is_floating___value: std___is_floating__bindgen_ty_1 = 0;
pub type std___is_floating__bindgen_ty_1 = i32;
pub type std___is_floating___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer {
    pub _address: u8,
}
pub const std___is_pointer___value: std___is_pointer__bindgen_ty_1 = 0;
pub type std___is_pointer__bindgen_ty_1 = i32;
pub type std___is_pointer___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_char {
    pub _address: u8,
}
pub const std___is_char___value: std___is_char__bindgen_ty_1 = 0;
pub type std___is_char__bindgen_ty_1 = i32;
pub type std___is_char___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_byte {
    pub _address: u8,
}
pub const std___is_byte___value: std___is_byte__bindgen_ty_1 = 0;
pub type std___is_byte__bindgen_ty_1 = i32;
pub type std___is_byte___type = std___false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nonvolatile_trivially_copyable {
    pub _address: u8,
}
pub const std___is_nonvolatile_trivially_copyable___value:
    std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = 0;
pub type std___is_nonvolatile_trivially_copyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcpyable {
    pub _address: u8,
}
pub const std___memcpyable___value: std___memcpyable__bindgen_ty_1 = 0;
pub type std___memcpyable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___memcmpable {
    pub _address: u8,
}
pub const std___memcmpable___value: std___memcmpable__bindgen_ty_1 = 0;
pub type std___memcmpable__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_move_iterator {
    pub _address: u8,
}
pub const std___is_move_iterator___value: std___is_move_iterator__bindgen_ty_1 = 0;
pub type std___is_move_iterator__bindgen_ty_1 = i32;
pub type std___is_move_iterator___type = std___false_type;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
pub type std_bool_constant = u8;
pub type std___enable_if_t = u8;
pub type std___conditional_type<_Tp> = _Tp;
pub type std___conditional_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
pub type std___type_identity_t = std___type_identity;
pub type std___detail___first_t<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___disjunction_impl {
    pub _address: u8,
}
pub type std___detail___disjunction_impl_type<_B1> = _B1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___conjunction_impl {
    pub _address: u8,
}
pub type std___detail___conjunction_impl_type<_B1> = _B1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__MakeUniq {
    pub _address: u8,
}
pub type std___detail__MakeUniq___single_object = std_unique_ptr;
pub type std___detail___unique_ptr_t = std___detail__MakeUniq;
pub type std___detail___unique_ptr_array_t = std___detail__MakeUniq;
pub type std___detail___invalid_make_unique_t = std___detail__MakeUniq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___variant__Never_valueless_alt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___floating_point_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail___numeric_constants {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_conjunction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_disjunction {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negation {
    pub _address: u8,
}
pub type std___remove_cv_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _base: std_is_null_pointer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
pub type std___is_one_of = std___or_;
pub type std___is_signed_integer = std___is_one_of;
pub type std___is_unsigned_integer = std___is_one_of;
pub type std___is_standard_integer = std___or_;
pub type std___void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
pub type std___is_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_lvalue_reference_helper {
    pub _address: u8,
}
pub type std___add_lvalue_reference_helper_type<_Tp> = _Tp;
pub type std___add_lval_ref_t = std___add_lvalue_reference_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_rvalue_reference_helper {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type<_Tp> = _Tp;
pub type std___add_rval_ref_t = std___add_rvalue_reference_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
pub type std___is_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
pub type std___is_nothrow_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
pub type std___is_trivially_constructible_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
pub type std___is_trivially_assignable_impl = std___bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___is_array_convertible = std_is_convertible;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Tp> = _Tp;
pub type std_remove_const_t = std_remove_const;
pub type std_remove_volatile_t = std_remove_volatile;
pub type std_remove_cv_t = std_remove_cv;
pub type std_add_const_t = std_add_const;
pub type std_add_volatile_t = std_add_volatile;
pub type std_add_cv_t = std_add_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = std___add_lval_ref_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = std___add_rval_ref_t;
pub type std_remove_reference_t = std_remove_reference;
pub type std_add_lvalue_reference_t = std_add_lvalue_reference;
pub type std_add_rvalue_reference_t = std_add_rvalue_reference;
pub type std___match_cv_qualifiers___match = u8;
pub type std___match_cv_qualifiers___type = std___match_cv_qualifiers___match;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base__List {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
pub type std_make_unsigned_t = std_make_unsigned;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std_remove_extent_t = std_remove_extent;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___add_pointer_helper {
    pub _address: u8,
}
pub type std___add_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_t = std_remove_pointer;
pub type std_add_pointer_t = std_add_pointer;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std___aligned_storage_msa___type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union___strictest = std___strictest_alignment;
pub type std_aligned_union_type = u8;
unsafe extern "C" {
    #[link_name = "\u{1}alignment_value"]
    pub static std_alignment_value: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___decay_selector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay_type = std___decay_selector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
pub type std___decay_t = std_decay;
pub type std___decay_and_strip = std___strip_reference_wrapper;
pub type std__Require = std___enable_if_t;
pub type std___remove_cvref_t = std_remove_cv;
pub type std_conditional_type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
pub type std___do_common_type_impl___cond_t<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_pack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_fold {
    pub _address: u8,
}
pub type std___underlying_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type<_Tag> = _Tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type<_Tp> = _Tp;
pub type std___result_of_impl_type = std___failure_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_t = u8;
pub type std_decay_t = std_decay;
pub type std_enable_if_t = u8;
pub type std_conditional_t = u8;
pub type std_common_type_t = std_common_type;
pub type std_underlying_type_t = std_underlying_type;
pub type std_result_of_t = std_result_of;
pub type std_void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_type<_Default> = _Default;
pub type std___detector___is_detected = std_false_type;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_swappable_with_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_nothrow_swappable_with_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable_with {
    pub _address: u8,
}
pub type std___is_invocable_impl___nothrow_conv = std_false_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = std___call_is_nothrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuchbase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_invoke_result {
    pub _address: u8,
}
pub type std_invoke_result_t = std_invoke_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable {
    pub _address: u8,
}
pub type std___is_nt_invocable_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_invocable_r {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_unique_object_representations {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_aggregate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size<_Tp> = _Tp;
pub type std___tuple_element_t = u8;
pub type std_tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
pub type std_integer_sequence_value_type<_Tp> = _Tp;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = std_make_integer_sequence;
pub type std_index_sequence_for = std_make_index_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_t {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt8in_place"]
    pub static std_in_place: std_in_place_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_type_t {
    pub _address: u8,
}
pub type std___is_in_place_type = std_bool_constant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
    pub first: _T1,
    pub second: _T2,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std___iter_category_t = std_iterator_traits;
pub type std__RequireInputIter = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_random_access_iter {
    pub _address: u8,
}
pub type std___is_random_access_iter__Base = std_is_base_of;
pub const std___is_random_access_iter___value: std___is_random_access_iter__bindgen_ty_1 = 0;
pub type std___is_random_access_iter__bindgen_ty_1 = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__List_const_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_elem {
    pub _address: u8,
}
pub type std___ptr_traits_elem_t = std___ptr_traits_elem;
pub type std___ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_ptr_to_element_type<_Elt> = _Elt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_impl {
    pub _address: u8,
}
pub type std___ptr_traits_impl___diff_t = __BindgenOpaqueArray<u8, 0usize>;
pub type std___ptr_traits_impl___rebind = std___type_identity;
pub type std___ptr_traits_impl_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_impl_element_type<_Elt> = _Elt;
pub type std___ptr_traits_impl_difference_type = std___detected_or_t;
pub type std___ptr_traits_impl_rebind = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std___ptr_rebind = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub current: _Iterator,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_back_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
}
pub type std_back_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_front_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
}
pub type std_front_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
pub struct std_insert_iterator<_Container> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Container>>,
    pub container: *mut _Container,
    pub iter: std_insert_iterator__Iter,
}
pub type std_insert_iterator__Iter = __BindgenOpaqueArray<u8, 0usize>;
pub type std_insert_iterator_container_type<_Container> = _Container;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iterator> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
    pub _M_current: _Iterator,
}
pub type std_move_iterator___traits_type = std_iterator_traits;
pub type std_move_iterator___base_ref = std_move_iterator___traits_type;
pub type std_move_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_move_iterator_iterator_category = std_move_iterator___traits_type;
pub type std_move_iterator_value_type = std_move_iterator___traits_type;
pub type std_move_iterator_difference_type = std_move_iterator___traits_type;
pub type std_move_iterator_pointer<_Iterator> = _Iterator;
pub type std_move_iterator_reference = std___conditional_t;
pub type std___iter_key_t = std_remove_const_t;
pub type std___iter_val_t = std_iterator_traits;
pub type std___iter_to_alloc_t = std_pair<std___iter_key_t, std___iter_val_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Deque_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Bit_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_istreambuf_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ostreambuf_iterator {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt9__fill_a1St13_Bit_iteratorS_RKb"]
    pub fn std___fill_a1(arg1: std__Bit_iterator, arg2: std__Bit_iterator, arg3: *const bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___lc_rai {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = usize;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution<_IntType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
    pub _M_param: std_uniform_int_distribution_param_type<_IntType>,
}
pub type std_uniform_int_distribution_result_type<_IntType> = _IntType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uniform_int_distribution_param_type<_IntType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_IntType>>,
    pub _M_a: _IntType,
    pub _M_b: _IntType,
}
pub type std_uniform_int_distribution_param_type_distribution_type<_IntType> =
    std_uniform_int_distribution<_IntType>;
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_align_val_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt7nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_buffer<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_original_len: std__Temporary_buffer_size_type,
    pub _M_len: std__Temporary_buffer_size_type,
    pub _M_buffer: std__Temporary_buffer_pointer<_Tp>,
}
pub type std__Temporary_buffer_value_type<_Tp> = _Tp;
pub type std__Temporary_buffer_pointer<_Tp> = *mut std__Temporary_buffer_value_type<_Tp>;
pub type std__Temporary_buffer_iterator<_Tp> = std__Temporary_buffer_pointer<_Tp>;
pub type std__Temporary_buffer_size_type = isize;
pub const _S_threshold: std__bindgen_ty_1 = 16;
pub type std__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _S_chunk_size: std__bindgen_ty_2 = 7;
pub type std__bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_string = std_basic_string;
pub type std_wstring = std_basic_string;
pub type std_u16string = std_basic_string;
pub type std_u32string = std_basic_string;
pub type std_streamoff = ::std::os::raw::c_long;
pub type std_streamsize = isize;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
}
pub type std_streampos = std_fpos<__mbstate_t>;
pub type std_wstreampos = std_fpos<__mbstate_t>;
pub type std_u16streampos = std_fpos<__mbstate_t>;
pub type std_u32streampos = std_fpos<__mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ios {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_streambuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_iostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios;
pub type std_streambuf = std_basic_streambuf;
pub type std_istream = std_basic_istream;
pub type std_ostream = std_basic_ostream;
pub type std_iostream = std_basic_iostream;
pub type std_stringbuf = std_basic_stringbuf;
pub type std_istringstream = std_basic_istringstream;
pub type std_ostringstream = std_basic_ostringstream;
pub type std_stringstream = std_basic_stringstream;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wios = std_basic_ios;
pub type std_wstreambuf = std_basic_streambuf;
pub type std_wistream = std_basic_istream;
pub type std_wostream = std_basic_ostream;
pub type std_wiostream = std_basic_iostream;
pub type std_wstringbuf = std_basic_stringbuf;
pub type std_wistringstream = std_basic_istringstream;
pub type std_wostringstream = std_basic_ostringstream;
pub type std_wstringstream = std_basic_stringstream;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___erased_type {
    pub _address: u8,
}
pub type std___is_erased_or_convertible = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt13allocator_arg"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_allocator_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0 {
    pub _M_a: std___uses_alloc0__Sink,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc0__Sink {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc1<_Alloc> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
    pub _M_a: *const _Alloc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uses_alloc2<_Alloc> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
    pub _M_a: *const _Alloc,
}
pub type std___uses_alloc_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_predicate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_uses_allocator_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_empty_non_tuple {
    pub _address: u8,
}
pub type std___empty_not_final = std___conditional_t;
pub type std__TupleConstraints___constructible = std___and_;
pub type std__TupleConstraints___convertible = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
pub type std_tuple__TCC = u8;
pub type std_tuple__ImplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ExplicitDefaultCtor = std___enable_if_t;
pub type std_tuple__ImplicitCtor = std___enable_if_t;
pub type std_tuple__ExplicitCtor = std___enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__UseOtherCtor {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___combine_tuples {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_cat_result {
    pub _address: u8,
}
pub type std___tuple_cat_result___type = std___combine_tuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_1st_indices {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___tuple_concater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Swallow_assign {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt6ignore"]
    pub static std_ignore: std__Swallow_assign;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt11_Hash_bytesPKvmm"]
    pub fn std__Hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvmm"]
    pub fn std__Fnv_hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___hash_base {
    pub _address: u8,
}
pub type std___hash_base_result_type<_Result> = _Result;
pub type std___hash_base_argument_type<_Arg> = _Arg;
#[repr(C)]
#[derive(Debug)]
pub struct std___poison_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hash_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Fnv_hash_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_fast_hash {
    pub _base: std_true_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_function {
    pub _address: u8,
}
pub type std_unary_function_argument_type<_Arg> = _Arg;
pub type std_unary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_transparent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_divides {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_modulus {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_negate {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_logical_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_and {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_or {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_xor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bit_not {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unary_negate<_Predicate> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_negate<_Predicate> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
    pub _M_pred: _Predicate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_unary_function<_Arg, _Result> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Result>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_to_binary_function<_Arg1, _Arg2, _Result> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg2>>,
    pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Result>>,
    pub _M_ptr: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg1, arg2: _Arg2) -> _Result>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select1st {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Select2nd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun_ref_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun_ref_t<_Ret> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn() -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_mem_fun1_ref_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_const_mem_fun1_ref_t<_Ret, _Arg> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ret>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Arg>>,
    pub _M_f: ::std::option::Option<unsafe extern "C" fn(arg1: _Arg) -> _Ret>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___has_is_transparent {
    pub _address: u8,
}
pub type std___has_is_transparent_t = std___has_is_transparent;
#[repr(C)]
pub struct std_binder1st<_Operation> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
    pub op: _Operation,
    pub value: __BindgenOpaqueArray<u8, 0usize>,
}
#[repr(C)]
pub struct std_binder2nd<_Operation> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Operation>>,
    pub op: _Operation,
    pub value: __BindgenOpaqueArray<u8, 0usize>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_unary_or_binary_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Mem_fn_traits_base {
    pub _address: u8,
}
pub type std__Mem_fn_traits_base___result_type<_Res> = _Res;
pub type std__Mem_fn_traits_base___maybe_type = std__Maybe_unary_or_binary_function;
pub type std__Mem_fn_traits_base___arity = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Maybe_get_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Refwrap_base_arg2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Reference_wrapper_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Tp> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
    pub _M_data: *mut _Tp,
}
pub type std_reference_wrapper___not_same = u8;
pub type std_reference_wrapper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _M_t: std_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = std___uniq_ptr_impl__Ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub _M_t: u8,
}
pub type std_unique_ptr__DeleterConstraint = std___uniq_ptr_impl;
pub type std_unique_ptr_pointer = std___uniq_ptr_impl;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr___safe_conversion_up = std___and_;
#[repr(C)]
#[derive(Debug)]
pub struct std_thread {
    pub _M_id: std_thread_id,
}
pub type std_thread_native_handle_type = __gthread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread_id {
    pub _M_thread: std_thread_native_handle_type,
}
pub type std_thread___not_same = std___not_;
#[repr(C)]
pub struct std_thread__State__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_thread__State {
    pub vtable_: *const std_thread__State__bindgen_vtable,
}
pub type std_thread__State_ptr = std_unique_ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_thread__State_impl<_Callable> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Callable>>,
    pub _base: std_thread__State,
    pub _M_func: _Callable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__Invoker<_Tuple> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tuple>>,
    pub _M_t: _Tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__Invoker___result {
    pub _address: u8,
}
pub type std_thread__Call_wrapper = std_thread__Invoker<std_tuple>;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6thread4joinEv"]
    pub fn std_thread_join(this: *mut std_thread);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6thread6detachEv"]
    pub fn std_thread_detach(this: *mut std_thread);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6thread20hardware_concurrencyEv"]
    pub fn std_thread_hardware_concurrency() -> ::std::os::raw::c_uint;
}
impl std_thread {
    #[inline]
    pub unsafe fn join(&mut self) {
        std_thread_join(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) {
        std_thread_detach(self)
    }
    #[inline]
    pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
        std_thread_hardware_concurrency()
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6thread6_StateD1Ev"]
    pub fn std_thread__State__State_destructor(this: *mut std_thread__State);
}
pub const std___safe_multiply___c: ::std::os::raw::c_ulong = 4294967296;
unsafe extern "C" {
    #[link_name = "\u{1}__a0"]
    pub static std___safe_multiply___a0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__a1"]
    pub static std___safe_multiply___a1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__b0"]
    pub static std___safe_multiply___b0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__b1"]
    pub static std___safe_multiply___b1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}value"]
    pub static std___safe_multiply_value: ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_add___lo: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_add___hi: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_sub___lo: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_sub___hi: ::std::os::raw::c_ulong;
}
pub const std___big_mul___c: ::std::os::raw::c_ulong = 4294967296;
unsafe extern "C" {
    #[link_name = "\u{1}__x0"]
    pub static std___big_mul___x0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x1"]
    pub static std___big_mul___x1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__y0"]
    pub static std___big_mul___y0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__y1"]
    pub static std___big_mul___y1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x0y0"]
    pub static std___big_mul___x0y0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x0y1"]
    pub static std___big_mul___x0y1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x1y0"]
    pub static std___big_mul___x1y0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__x1y1"]
    pub static std___big_mul___x1y1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__mix"]
    pub static std___big_mul___mix: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__mix_lo"]
    pub static std___big_mul___mix_lo: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__mix_hi"]
    pub static std___big_mul___mix_hi: ::std::os::raw::c_ulong;
}
pub type std___big_mul__Res = u8;
unsafe extern "C" {
    #[link_name = "\u{1}__hi"]
    pub static std___big_mul___hi: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__lo"]
    pub static std___big_mul___lo: ::std::os::raw::c_ulong;
}
pub const std___big_div_impl___c: ::std::os::raw::c_ulong = 4294967296;
unsafe extern "C" {
    #[link_name = "\u{1}__d1"]
    pub static std___big_div_impl___d1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__d0"]
    pub static std___big_div_impl___d0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q1x"]
    pub static std___big_div_impl___q1x: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1x"]
    pub static std___big_div_impl___r1x: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__m"]
    pub static std___big_div_impl___m: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1y"]
    pub static std___big_div_impl___r1y: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1z"]
    pub static std___big_div_impl___r1z: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r1"]
    pub static std___big_div_impl___r1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q1"]
    pub static std___big_div_impl___q1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q0x"]
    pub static std___big_div_impl___q0x: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0x"]
    pub static std___big_div_impl___r0x: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__n"]
    pub static std___big_div_impl___n: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0y"]
    pub static std___big_div_impl___r0y: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0z"]
    pub static std___big_div_impl___r0z: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__r0"]
    pub static std___big_div_impl___r0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__q0"]
    pub static std___big_div_impl___q0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__quot"]
    pub static std___big_div_impl___quot: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div_impl___rem: ::std::os::raw::c_ulong;
}
pub type std___big_div_impl__Prod = u8;
pub type std___big_div_impl__Sum = u8;
unsafe extern "C" {
    #[link_name = "\u{1}__shift"]
    pub static std___big_div___shift: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__coshift_"]
    pub static std___big_div___coshift_: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__coshift"]
    pub static std___big_div___coshift: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__c1"]
    pub static std___big_div___c1: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__c2"]
    pub static std___big_div___c2: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__new_d"]
    pub static std___big_div___new_d: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__new_n0"]
    pub static std___big_div___new_n0: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__n1_shifted"]
    pub static std___big_div___n1_shifted: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__n0_top"]
    pub static std___big_div___n0_top: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__new_n1"]
    pub static std___big_div___new_n1: ::std::os::raw::c_ulong;
}
pub type std___big_div__Res = u8;
unsafe extern "C" {
    #[link_name = "\u{1}__quot_hi"]
    pub static std___big_div___quot_hi: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__quot_lo"]
    pub static std___big_div___quot_lo: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__rem"]
    pub static std___big_div___rem: ::std::os::raw::c_ulong;
}
pub type std___big_div__P0 = u8;
pub type std___big_div__P1 = u8;
pub type std___big_div__Sum = u8;
unsafe extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_ratio {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_multiply {
    pub _address: u8,
}
pub type std___ratio_multiply_type = u8;
pub type std_ratio_multiply = std___ratio_multiply;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_divide {
    pub _address: u8,
}
pub type std___ratio_divide_type = std___ratio_multiply;
pub type std_ratio_divide = std___ratio_divide;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_less_impl_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
pub type std___ratio_add_impl___t = u8;
pub type std___ratio_add_impl_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_add {
    pub _address: u8,
}
pub type std___ratio_add_type = u8;
pub type std_ratio_add = std___ratio_add;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ratio_subtract {
    pub _address: u8,
}
pub type std___ratio_subtract_type = std___ratio_add;
pub type std_ratio_subtract = std___ratio_subtract;
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
pub const std_float_round_style_round_indeterminate: std_float_round_style = -1;
pub const std_float_round_style_round_toward_zero: std_float_round_style = 0;
pub const std_float_round_style_round_to_nearest: std_float_round_style = 1;
pub const std_float_round_style_round_toward_infinity: std_float_round_style = 2;
pub const std_float_round_style_round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
pub const std_float_denorm_style_denorm_indeterminate: std_float_denorm_style = -1;
pub const std_float_denorm_style_denorm_absent: std_float_denorm_style = 0;
pub const std_float_denorm_style_denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___numeric_limits_base {
    pub _address: u8,
}
pub const std___numeric_limits_base_is_specialized: bool = false;
pub const std___numeric_limits_base_digits: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_is_signed: bool = false;
pub const std___numeric_limits_base_is_integer: bool = false;
pub const std___numeric_limits_base_is_exact: bool = false;
pub const std___numeric_limits_base_radix: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std___numeric_limits_base_has_infinity: bool = false;
pub const std___numeric_limits_base_has_quiet_NaN: bool = false;
pub const std___numeric_limits_base_has_signaling_NaN: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
    pub static std___numeric_limits_base_has_denorm: std_float_denorm_style;
}
pub const std___numeric_limits_base_has_denorm_loss: bool = false;
pub const std___numeric_limits_base_is_iec559: bool = false;
pub const std___numeric_limits_base_is_bounded: bool = false;
pub const std___numeric_limits_base_is_modulo: bool = false;
pub const std___numeric_limits_base_traps: bool = false;
pub const std___numeric_limits_base_tinyness_before: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
    pub static std___numeric_limits_base_round_style: std_float_round_style;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
pub type std___parse_int__Digit_impl___valid = std_true_type;
pub type std___parse_int___ull_constant = u8;
pub type std___parse_int__Power_help___next = u8;
pub type std___parse_int__Power_help___valid_digit = u8;
pub type std___parse_int__Power_help_type = std___parse_int___ull_constant;
pub type std___parse_int__Number_help___digit = u8;
pub type std___parse_int__Number_help___valid_digit = std___parse_int__Number_help___digit;
pub type std___parse_int__Number_help_type = std___parse_int___ull_constant;
pub type std___select_int__Select_int = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_filesystem___file_clock {
    pub _address: u8,
}
pub type std_filesystem___file_clock_duration = std_chrono_nanoseconds;
pub type std_filesystem___file_clock_rep = rep;
pub type std_filesystem___file_clock_period = u8;
pub type std_filesystem___file_clock_time_point =
    std_chrono_time_point<std_chrono_duration<::std::os::raw::c_long>>;
pub type std_filesystem___file_clock___sys_clock = std_chrono_system_clock;
pub const std_filesystem___file_clock_is_steady: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt10filesystem12__file_clock13_S_epoch_diffE"]
    pub static std_filesystem___file_clock__S_epoch_diff: std_chrono_seconds;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono___is_duration {
    pub _base: std_false_type,
}
pub type std_chrono___enable_if_is_duration = u8;
pub type std_chrono___disable_if_is_duration = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_chrono_duration<_Rep> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
    pub __r: std_chrono_duration_rep<_Rep>,
}
pub type std_chrono_duration___is_float = std_chrono_treat_as_floating_point;
pub type std_chrono_duration___divide = u8;
pub type std_chrono_duration___is_harmonic = std___bool_constant;
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = __BindgenOpaqueArray<u8, 0usize>;
pub type std_chrono___common_rep_t = u8;
pub type std_chrono_nanoseconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_microseconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_milliseconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_seconds = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_minutes = std_chrono_duration<::std::os::raw::c_long>;
pub type std_chrono_hours = std_chrono_duration<::std::os::raw::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point<_Dur> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Dur>>,
    pub __d: std_chrono_time_point_duration<_Dur>,
}
pub type std_chrono_time_point_clock<_Clock> = _Clock;
pub type std_chrono_time_point_duration<_Dur> = _Dur;
pub type std_chrono_time_point_rep = __BindgenOpaqueArray<u8, 0usize>;
pub type std_chrono_time_point_period = __BindgenOpaqueArray<u8, 0usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_system_clock {
    pub _address: u8,
}
pub type std_chrono_system_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_system_clock_rep = rep;
pub type std_chrono_system_clock_period = u8;
pub type std_chrono_system_clock_time_point =
    std_chrono_time_point<std_chrono_system_clock_duration>;
pub const std_chrono_system_clock_is_steady: bool = false;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock3nowEv"]
    pub fn std_chrono_system_clock_now() -> std_chrono_system_clock_time_point;
}
impl std_chrono_system_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_system_clock_time_point {
        std_chrono_system_clock_now()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_steady_clock {
    pub _address: u8,
}
pub type std_chrono_steady_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_steady_clock_rep = rep;
pub type std_chrono_steady_clock_period = u8;
pub type std_chrono_steady_clock_time_point =
    std_chrono_time_point<std_chrono_steady_clock_duration>;
pub const std_chrono_steady_clock_is_steady: bool = true;
unsafe extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212steady_clock3nowEv"]
    pub fn std_chrono_steady_clock_now() -> std_chrono_steady_clock_time_point;
}
impl std_chrono_steady_clock {
    #[inline]
    pub unsafe fn now() -> std_chrono_steady_clock_time_point {
        std_chrono_steady_clock_now()
    }
}
pub type std_chrono_high_resolution_clock = std_chrono_system_clock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___duration_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___timepoint_common_type {
    pub _address: u8,
}
pub type std_byte = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___byte_operand {
    pub _address: u8,
}
pub type std___byte_op_t = std___byte_operand;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_valarray {
    pub _address: u8,
}
pub type std___array_traits__Type<_Tp> = *mut _Tp;
pub type std___array_traits__Is_swappable = std___is_swappable;
pub type std___array_traits__Is_nothrow_swappable = std___is_nothrow_swappable;
pub type std_array_value_type<_Tp> = _Tp;
pub type std_array_pointer<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_pointer<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_reference<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_reference<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_iterator<_Tp> = *mut std_array_value_type<_Tp>;
pub type std_array_const_iterator<_Tp> = *const std_array_value_type<_Tp>;
pub type std_array_size_type = usize;
pub type std_array_difference_type = isize;
pub type std_array_reverse_iterator<_Tp> = std_reverse_iterator<std_array_iterator<_Tp>>;
pub type std_array_const_reverse_iterator<_Tp> =
    std_reverse_iterator<std_array_const_iterator<_Tp>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_debug__Safe_iterator {
    pub _address: u8,
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtol"]
    pub fn strtol1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoul"]
    pub fn strtoul1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoll"]
    pub fn strtoq1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoull"]
    pub fn strtouq1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtol_l"]
    pub fn strtol_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoul_l"]
    pub fn strtoul_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoll_l"]
    pub fn strtoll_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_strtoull_l"]
    pub fn strtoull_l1(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut u32, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_sequenced_policy {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_parallel_policy {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_parallel_unsequenced_policy {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_unsequenced_policy {
    pub _address: u8,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v13seqE"]
    pub static __pstl_execution_seq: __pstl_execution_sequenced_policy;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v13parE"]
    pub static __pstl_execution_par: __pstl_execution_parallel_policy;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v19par_unseqE"]
    pub static __pstl_execution_par_unseq: __pstl_execution_parallel_unsequenced_policy;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN6__pstl9execution2v15unseqE"]
    pub static __pstl_execution_unseq: __pstl_execution_unsequenced_policy;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pstl_execution_is_execution_policy {
    pub _base: std_false_type,
}
pub type __pstl___internal___enable_if_execution_policy = u8;
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn rawmemchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memrchr(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *mut ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *mut ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *mut ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerrordesc_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerrorname_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn sigabbrev_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn sigdescr_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn basename(__filename: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __half_raw {
    pub x: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __half2_raw {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug)]
pub struct __half {
    pub __x: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug)]
pub struct __half2 {
    pub x: __half,
    pub y: __half,
}
#[doc = " \\cond ROCRAND_DOCS_TYPEDEFS\n rocRAND half type (derived from HIP)"]
pub type half = __half;
pub type half2 = __half2;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
unsafe extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wint_t = ::std::os::raw::c_uint;
pub type mbstate_t = __mbstate_t;
unsafe extern "C" {
    pub fn wcscpy(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsncpy(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcslcpy(__dest: *mut u32, __src: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcslcat(__dest: *mut u32, __src: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscat(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsncat(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcscmp(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const u32,
        __s2: *const u32,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const u32,
        __s2: *const u32,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcscoll(__s1: *const u32, __s2: *const u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm(__s1: *mut u32, __s2: *const u32, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcscoll_l(__s1: *const u32, __s2: *const u32, __loc: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsxfrm_l(__s1: *mut u32, __s2: *const u32, __n: usize, __loc: locale_t) -> usize;
}
unsafe extern "C" {
    pub fn wcsdup(__s: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcschr(__wcs: *const u32, __wc: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsrchr(__wcs: *const u32, __wc: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcschrnul(__s: *const u32, __wc: u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcscspn(__wcs: *const u32, __reject: *const u32) -> usize;
}
unsafe extern "C" {
    pub fn wcsspn(__wcs: *const u32, __accept: *const u32) -> usize;
}
unsafe extern "C" {
    pub fn wcspbrk(__wcs: *const u32, __accept: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsstr(__haystack: *const u32, __needle: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcstok(__s: *mut u32, __delim: *const u32, __ptr: *mut *mut u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcslen(__s: *const u32) -> usize;
}
unsafe extern "C" {
    pub fn wcswcs(__haystack: *const u32, __needle: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcsnlen(__s: *const u32, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn wmemchr(__s: *const u32, __c: u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmemcmp(__s1: *const u32, __s2: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wmemcpy(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmemmove(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmemset(__s: *mut u32, __c: u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn wmempcpy(__s1: *mut u32, __s2: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
unsafe extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbrtowc(
        __pwc: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: u32, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
unsafe extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut u32,
        __src: *mut *const ::std::os::raw::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const u32,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut u32,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const u32,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcwidth(__c: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcswidth(__s: *const u32, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcstod(__nptr: *const u32, __endptr: *mut *mut u32) -> f64;
}
unsafe extern "C" {
    pub fn wcstof(__nptr: *const u32, __endptr: *mut *mut u32) -> f32;
}
unsafe extern "C" {
    pub fn wcstold(__nptr: *const u32, __endptr: *mut *mut u32) -> u128;
}
unsafe extern "C" {
    pub fn wcstof32(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float32;
}
unsafe extern "C" {
    pub fn wcstof64(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float64;
}
unsafe extern "C" {
    pub fn wcstof32x(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float32x;
}
unsafe extern "C" {
    pub fn wcstof64x(__nptr: *const u32, __endptr: *mut *mut u32) -> _Float64x;
}
unsafe extern "C" {
    pub fn wcstol(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn wcstoul(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcstoq(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstouq(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstol"]
    pub fn wcstol1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstoul"]
    pub fn wcstoul1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstoll"]
    pub fn wcstoll1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstoull"]
    pub fn wcstoull1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcstol_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn wcstoul_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn wcstoll_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn wcstoull_l(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstol_l"]
    pub fn wcstol_l1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstoul_l"]
    pub fn wcstoul_l1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstoll_l"]
    pub fn wcstoll_l1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wcstoull_l"]
    pub fn wcstoull_l1(
        __nptr: *const u32,
        __endptr: *mut *mut u32,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn wcstod_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> f64;
}
unsafe extern "C" {
    pub fn wcstof_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> f32;
}
unsafe extern "C" {
    pub fn wcstold_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> u128;
}
unsafe extern "C" {
    pub fn wcstof32_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float32;
}
unsafe extern "C" {
    pub fn wcstof64_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float64;
}
unsafe extern "C" {
    pub fn wcstof32x_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float32x;
}
unsafe extern "C" {
    pub fn wcstof64x_l(__nptr: *const u32, __endptr: *mut *mut u32, __loc: locale_t) -> _Float64x;
}
unsafe extern "C" {
    pub fn wcpcpy(__dest: *mut u32, __src: *const u32) -> *mut u32;
}
unsafe extern "C" {
    pub fn wcpncpy(__dest: *mut u32, __src: *const u32, __n: usize) -> *mut u32;
}
unsafe extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut u32, __sizeloc: *mut usize) -> *mut __FILE;
}
unsafe extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wprintf(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swprintf(__s: *mut u32, __n: usize, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vwprintf(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vswprintf(
        __s: *mut u32,
        __n: usize,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wscanf(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swscanf(__s: *const u32, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_wscanf"]
    pub fn wscanf1(__format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_swscanf"]
    pub fn swscanf1(__s: *const u32, __format: *const u32, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vwscanf(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vswscanf(
        __s: *const u32,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_vwscanf"]
    pub fn vwscanf1(__format: *const u32, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc23_vswscanf"]
    pub fn vswscanf1(
        __s: *const u32,
        __format: *const u32,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar() -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar(__wc: u32) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws(__ws: *mut u32, __n: ::std::os::raw::c_int, __stream: *mut __FILE) -> *mut u32;
}
unsafe extern "C" {
    pub fn fputws(__ws: *const u32, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwc_unlocked(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn getwchar_unlocked() -> wint_t;
}
unsafe extern "C" {
    pub fn fgetwc_unlocked(__stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn fputwc_unlocked(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwc_unlocked(__wc: u32, __stream: *mut __FILE) -> wint_t;
}
unsafe extern "C" {
    pub fn putwchar_unlocked(__wc: u32) -> wint_t;
}
unsafe extern "C" {
    pub fn fgetws_unlocked(
        __ws: *mut u32,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut u32;
}
unsafe extern "C" {
    pub fn fputws_unlocked(__ws: *const u32, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcsftime(
        __s: *mut u32,
        __maxsize: usize,
        __format: *const u32,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcsftime_l(
        __s: *mut u32,
        __maxsize: usize,
        __format: *const u32,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn clone(
        __fn: ::std::option::Option<
            unsafe extern "C" fn(__arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        __child_stack: *mut ::std::os::raw::c_void,
        __flags: ::std::os::raw::c_int,
        __arg: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unshare(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcpu(
        arg1: *mut ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setns(
        __fd: ::std::os::raw::c_int,
        __nstype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
unsafe extern "C" {
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_getres(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut tm;
}
unsafe extern "C" {
    pub fn getdate_r(
        __string: *const ::std::os::raw::c_char,
        __resbufp: *mut tm,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
unsafe extern "C" {
    pub fn __sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_40 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_40 = 1;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_41 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_41 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_41 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_41 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_41 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_41 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_41 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_41 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_41 = 0;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_42 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_42 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_42 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_42 = 1;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_43 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_43 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_43 = 2;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_44 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_44 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_44 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_44 = 0;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_45 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_45 = 1;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_46 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_46 = 1;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_47 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_47 = 1;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_48 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_48 = 1;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_49 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_49 = 1;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setsigmask_np(
        __attr: *mut pthread_attr_t,
        sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getsigmask_np(
        __attr: *const pthread_attr_t,
        sigmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getattr_np(
        __th: pthread_t,
        __attr: *mut pthread_attr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setconcurrency(__level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_cleanup_class {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
unsafe extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type __gthread_t = pthread_t;
pub type __gthread_key_t = pthread_key_t;
pub type __gthread_once_t = pthread_once_t;
pub type __gthread_mutex_t = pthread_mutex_t;
pub type __gthread_recursive_mutex_t = pthread_mutex_t;
pub type __gthread_cond_t = pthread_cond_t;
pub type __gthread_time_t = timespec;
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
pub type error_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
unsafe extern "C" {
    #[doc = " @brief Query the installed library build name.\n\n This function can be used even when the library is not initialized.\n\n @returns Returns a string describing the build version of the library.  The\n string is owned by the library."]
    pub fn amd_dbgapi_get_build_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Query the installed library git hash.\n\n This function can be used even when the library is not initialized.\n\n @returns Returns git hash of the library."]
    pub fn amd_dbgapi_get_git_hash() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Query the installed library build ID.\n\n This function can be used even when the library is not initialized.\n\n @returns Returns build ID of the library."]
    pub fn amd_dbgapi_get_build_id() -> usize;
}
pub type float_t = f32;
pub type double_t = f64;
pub const FP_INT_UPWARD: _bindgen_ty_55 = 0;
pub const FP_INT_DOWNWARD: _bindgen_ty_55 = 1;
pub const FP_INT_TOWARDZERO: _bindgen_ty_55 = 2;
pub const FP_INT_TONEARESTFROMZERO: _bindgen_ty_55 = 3;
pub const FP_INT_TONEAREST: _bindgen_ty_55 = 4;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
unsafe extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn nextdown(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextdown(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextup(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextup(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogb(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogb(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundeven(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __roundeven(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfp(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpx(
        __x: f64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalize(__cx: *mut f64, __x: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaxmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminmag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum_mag(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaximum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminimum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fminimum_mag_num(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn totalorder(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermag(__x: *const f64, __y: *const f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayload(__x: *const f64) -> f64;
}
unsafe extern "C" {
    pub fn __getpayload(__x: *const f64) -> f64;
}
unsafe extern "C" {
    pub fn setpayload(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsig(__x: *mut f64, __payload: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
unsafe extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn nextdownf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextdownf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextupf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextupf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundevenf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundevenf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf(
        __x: f32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef(__cx: *mut f32, __x: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminmagf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimumf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimum_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimum_magf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn totalorderf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf(__x: *const f32, __y: *const f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf(__x: *const f32) -> f32;
}
unsafe extern "C" {
    pub fn __getpayloadf(__x: *const f32) -> f32;
}
unsafe extern "C" {
    pub fn setpayloadf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf(__x: *mut f32, __payload: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
unsafe extern "C" {
    pub fn __sincosl(__x: u128, __sinx: *mut u128, __cosx: *mut u128);
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn exp10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextdownl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextdownl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextupl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextupl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundevenl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundevenl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxl(
        __x: u128,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizel(__cx: *mut u128, __x: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminmagl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimuml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimum_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimum_magl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminimum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn totalorderl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagl(__x: *const u128, __y: *const u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadl(__x: *const u128) -> u128;
}
unsafe extern "C" {
    pub fn __getpayloadl(__x: *const u128) -> u128;
}
unsafe extern "C" {
    pub fn setpayloadl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigl(__x: *mut u128, __payload: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn acosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __acosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn asinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __asinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atan2f32(__y: _Float32, __x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn cosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __cosf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sinf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tanf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn coshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __coshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
unsafe extern "C" {
    pub fn __sincosf32(__x: _Float32, __sinx: *mut _Float32, __cosx: *mut _Float32);
}
unsafe extern "C" {
    pub fn acoshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __acoshf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn asinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __asinhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn atanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __atanhf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn expf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __expf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __frexpf32(__x: _Float32, __exponent: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __ldexpf32(__x: _Float32, __exponent: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn logf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __logf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __modff32(__x: _Float32, __iptr: *mut _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn exp10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __exp10f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn expm1f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __expm1f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log1pf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log1pf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn logbf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __logbf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn exp2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __exp2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn log2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __log2f32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __powf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn sqrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __sqrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __hypotf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn cbrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __cbrtf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn ceilf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __ceilf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fabsf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fabsf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn floorf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __floorf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmodf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __copysignf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
unsafe extern "C" {
    pub fn __nanf32(__tagb: *const ::std::os::raw::c_char) -> _Float32;
}
unsafe extern "C" {
    pub fn j0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __j0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn j1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __j1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __jnf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn y0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __y0f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn y1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __y1f32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __ynf32(arg1: ::std::os::raw::c_int, arg2: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn erff32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __erff32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn erfcf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __erfcf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn lgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __lgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn tgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __tgammaf32(arg1: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __lgammaf32_r(arg1: _Float32, __signgamp: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn rintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __rintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextafterf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextdownf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextdownf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn nextupf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nextupf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __remainderf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __scalbnf32(__x: _Float32, __n: ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf32(__x: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
unsafe extern "C" {
    pub fn __scalblnf32(__x: _Float32, __n: ::std::os::raw::c_long) -> _Float32;
}
unsafe extern "C" {
    pub fn nearbyintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __nearbyintf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn roundf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __roundf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn truncf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __truncf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int) -> _Float32;
}
unsafe extern "C" {
    pub fn __remquof32(__x: _Float32, __y: _Float32, __quo: *mut ::std::os::raw::c_int)
        -> _Float32;
}
unsafe extern "C" {
    pub fn lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf32(__x: _Float32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf32(__x: _Float32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fdimf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaxf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaf32(__x: _Float32, __y: _Float32, __z: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn roundevenf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __roundevenf32(__x: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf32(
        __x: _Float32,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef32(__cx: *mut _Float32, __x: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaxmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminmagf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimumf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimum_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimum_magf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf32(__x: _Float32, __y: _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn totalorderf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf32(__x: *const _Float32, __y: *const _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf32(__x: *const _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn __getpayloadf32(__x: *const _Float32) -> _Float32;
}
unsafe extern "C" {
    pub fn setpayloadf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf32(__x: *mut _Float32, __payload: _Float32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __acosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn asinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __asinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atan2f64(__y: _Float64, __x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn cosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __cosf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sinf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tanf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn coshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __coshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
unsafe extern "C" {
    pub fn __sincosf64(__x: _Float64, __sinx: *mut _Float64, __cosx: *mut _Float64);
}
unsafe extern "C" {
    pub fn acoshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __acoshf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn asinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __asinhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn atanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __atanhf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn expf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __expf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __frexpf64(__x: _Float64, __exponent: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __ldexpf64(__x: _Float64, __exponent: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn logf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __logf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __modff64(__x: _Float64, __iptr: *mut _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn exp10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __exp10f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn expm1f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __expm1f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log1pf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log1pf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn logbf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __logbf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn exp2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __exp2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn log2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __log2f64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __powf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn sqrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __sqrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __hypotf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn cbrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __cbrtf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn ceilf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __ceilf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fabsf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fabsf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn floorf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __floorf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmodf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __copysignf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
unsafe extern "C" {
    pub fn __nanf64(__tagb: *const ::std::os::raw::c_char) -> _Float64;
}
unsafe extern "C" {
    pub fn j0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __j0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn j1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __j1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __jnf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn y0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __y0f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn y1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __y1f64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __ynf64(arg1: ::std::os::raw::c_int, arg2: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn erff64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __erff64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn erfcf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __erfcf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn lgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __lgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn tgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __tgammaf64(arg1: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __lgammaf64_r(arg1: _Float64, __signgamp: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn rintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __rintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextafterf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextdownf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextdownf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn nextupf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nextupf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __remainderf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __scalbnf64(__x: _Float64, __n: ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf64(__x: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
unsafe extern "C" {
    pub fn __scalblnf64(__x: _Float64, __n: ::std::os::raw::c_long) -> _Float64;
}
unsafe extern "C" {
    pub fn nearbyintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __nearbyintf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn roundf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __roundf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn truncf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __truncf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int) -> _Float64;
}
unsafe extern "C" {
    pub fn __remquof64(__x: _Float64, __y: _Float64, __quo: *mut ::std::os::raw::c_int)
        -> _Float64;
}
unsafe extern "C" {
    pub fn lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf64(__x: _Float64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf64(__x: _Float64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fdimf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaxf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn roundevenf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __roundevenf64(__x: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf64(
        __x: _Float64,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef64(__cx: *mut _Float64, __x: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaxmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminmagf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimumf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimum_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimum_magf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf64(__x: _Float64, __y: _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn totalorderf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf64(__x: *const _Float64, __y: *const _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf64(__x: *const _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn __getpayloadf64(__x: *const _Float64) -> _Float64;
}
unsafe extern "C" {
    pub fn setpayloadf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf64(__x: *mut _Float64, __payload: _Float64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __acosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn asinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __asinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atan2f32x(__y: _Float32x, __x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn cosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __cosf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sinf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tanf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn coshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __coshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
unsafe extern "C" {
    pub fn __sincosf32x(__x: _Float32x, __sinx: *mut _Float32x, __cosx: *mut _Float32x);
}
unsafe extern "C" {
    pub fn acoshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __acoshf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn asinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __asinhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn atanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __atanhf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn expf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __expf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __frexpf32x(__x: _Float32x, __exponent: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ldexpf32x(__x: _Float32x, __exponent: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn logf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __logf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __modff32x(__x: _Float32x, __iptr: *mut _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn exp10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __exp10f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn expm1f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __expm1f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log1pf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log1pf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn logbf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __logbf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn exp2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __exp2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn log2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __log2f32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __powf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn sqrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __sqrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __hypotf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn cbrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __cbrtf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn ceilf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ceilf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fabsf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fabsf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn floorf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __floorf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmodf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __copysignf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nanf32x(__tagb: *const ::std::os::raw::c_char) -> _Float32x;
}
unsafe extern "C" {
    pub fn j0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __j0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn j1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __j1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __jnf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn y0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __y0f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn y1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __y1f32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __ynf32x(arg1: ::std::os::raw::c_int, arg2: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn erff32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __erff32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn erfcf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __erfcf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn lgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __lgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn tgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __tgammaf32x(arg1: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __lgammaf32x_r(arg1: _Float32x, __signgamp: *mut ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn rintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __rintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextafterf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextdownf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextdownf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn nextupf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nextupf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __remainderf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn __scalbnf32x(__x: _Float32x, __n: ::std::os::raw::c_int) -> _Float32x;
}
unsafe extern "C" {
    pub fn ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf32x(__x: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
unsafe extern "C" {
    pub fn __scalblnf32x(__x: _Float32x, __n: ::std::os::raw::c_long) -> _Float32x;
}
unsafe extern "C" {
    pub fn nearbyintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __nearbyintf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn roundf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __roundf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn truncf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __truncf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn __remquof32x(
        __x: _Float32x,
        __y: _Float32x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf32x(__x: _Float32x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf32x(__x: _Float32x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fdimf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaxf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn roundevenf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __roundevenf32x(__x: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf32x(
        __x: _Float32x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef32x(__cx: *mut _Float32x, __x: *const _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaxmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminmagf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimumf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimum_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimum_magf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf32x(__x: _Float32x, __y: _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn totalorderf32x(__x: *const _Float32x, __y: *const _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf32x(__x: *const _Float32x, __y: *const _Float32x)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn __getpayloadf32x(__x: *const _Float32x) -> _Float32x;
}
unsafe extern "C" {
    pub fn setpayloadf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf32x(__x: *mut _Float32x, __payload: _Float32x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __acosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn asinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __asinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atan2f64x(__y: _Float64x, __x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn cosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __cosf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sinf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tanf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn coshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __coshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
unsafe extern "C" {
    pub fn __sincosf64x(__x: _Float64x, __sinx: *mut _Float64x, __cosx: *mut _Float64x);
}
unsafe extern "C" {
    pub fn acoshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __acoshf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn asinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __asinhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn atanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __atanhf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn expf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __expf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __frexpf64x(__x: _Float64x, __exponent: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ldexpf64x(__x: _Float64x, __exponent: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn logf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __logf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __modff64x(__x: _Float64x, __iptr: *mut _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn exp10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __exp10f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn expm1f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __expm1f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log1pf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log1pf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn logbf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __logbf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn exp2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __exp2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn log2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __log2f64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __powf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn sqrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __sqrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __hypotf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn cbrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __cbrtf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn ceilf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ceilf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fabsf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fabsf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn floorf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __floorf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmodf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __copysignf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nanf64x(__tagb: *const ::std::os::raw::c_char) -> _Float64x;
}
unsafe extern "C" {
    pub fn j0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __j0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn j1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __j1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __jnf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn y0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __y0f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn y1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __y1f64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __ynf64x(arg1: ::std::os::raw::c_int, arg2: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn erff64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __erff64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn erfcf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __erfcf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn lgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __lgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn tgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __tgammaf64x(arg1: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __lgammaf64x_r(arg1: _Float64x, __signgamp: *mut ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn rintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __rintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextafterf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextdownf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextdownf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn nextupf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nextupf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __remainderf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn __scalbnf64x(__x: _Float64x, __n: ::std::os::raw::c_int) -> _Float64x;
}
unsafe extern "C" {
    pub fn ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf64x(__x: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __llogbf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
unsafe extern "C" {
    pub fn __scalblnf64x(__x: _Float64x, __n: ::std::os::raw::c_long) -> _Float64x;
}
unsafe extern "C" {
    pub fn nearbyintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __nearbyintf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn roundf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __roundf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn truncf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __truncf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn __remquof64x(
        __x: _Float64x,
        __y: _Float64x,
        __quo: *mut ::std::os::raw::c_int,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf64x(__x: _Float64x) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf64x(__x: _Float64x) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fdimf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaxf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn roundevenf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __roundevenf64x(__x: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn __fromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __intmax_t;
}
unsafe extern "C" {
    pub fn ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn __ufromfpxf64x(
        __x: _Float64x,
        __round: ::std::os::raw::c_int,
        __width: ::std::os::raw::c_uint,
    ) -> __uintmax_t;
}
unsafe extern "C" {
    pub fn canonicalizef64x(__cx: *mut _Float64x, __x: *const _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaxmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminmagf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimumf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimum_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimum_magf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fmaximum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fmaximum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn fminimum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __fminimum_mag_numf64x(__x: _Float64x, __y: _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn totalorderf64x(__x: *const _Float64x, __y: *const _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn totalordermagf64x(__x: *const _Float64x, __y: *const _Float64x)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn __getpayloadf64x(__x: *const _Float64x) -> _Float64x;
}
unsafe extern "C" {
    pub fn setpayloadf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpayloadsigf64x(__x: *mut _Float64x, __payload: _Float64x) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fadd(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fdiv(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn ffma(__x: f64, __y: f64, __z: f64) -> f32;
}
unsafe extern "C" {
    pub fn fmul(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn fsqrt(__x: f64) -> f32;
}
unsafe extern "C" {
    pub fn fsub(__x: f64, __y: f64) -> f32;
}
unsafe extern "C" {
    pub fn faddl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fdivl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn ffmal(__x: u128, __y: u128, __z: u128) -> f32;
}
unsafe extern "C" {
    pub fn fmull(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn fsqrtl(__x: u128) -> f32;
}
unsafe extern "C" {
    pub fn fsubl(__x: u128, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn daddl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn ddivl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn dfmal(__x: u128, __y: u128, __z: u128) -> f64;
}
unsafe extern "C" {
    pub fn dmull(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn dsqrtl(__x: u128) -> f64;
}
unsafe extern "C" {
    pub fn dsubl(__x: u128, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn f32addf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32fmaf32x(__x: _Float32x, __y: _Float32x, __z: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32sqrtf32x(__x: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf32x(__x: _Float32x, __y: _Float32x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32addf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32fmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32sqrtf64(__x: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf64(__x: _Float64, __y: _Float64) -> _Float32;
}
unsafe extern "C" {
    pub fn f32addf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32divf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32mulf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32sqrtf64x(__x: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32subf64x(__x: _Float64x, __y: _Float64x) -> _Float32;
}
unsafe extern "C" {
    pub fn f32xaddf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xdivf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xfmaf64(__x: _Float64, __y: _Float64, __z: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xmulf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsqrtf64(__x: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsubf64(__x: _Float64, __y: _Float64) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xaddf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xdivf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xfmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xmulf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsqrtf64x(__x: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f32xsubf64x(__x: _Float64x, __y: _Float64x) -> _Float32x;
}
unsafe extern "C" {
    pub fn f64addf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64divf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64fmaf64x(__x: _Float64x, __y: _Float64x, __z: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64mulf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64sqrtf64x(__x: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub fn f64subf64x(__x: _Float64x, __y: _Float64x) -> _Float64;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_56 = 0;
pub const FP_INFINITE: _bindgen_ty_56 = 1;
pub const FP_ZERO: _bindgen_ty_56 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_56 = 3;
pub const FP_NORMAL: _bindgen_ty_56 = 4;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __iscanonicall(__x: u128) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __iseqsig_type {
    pub _address: u8,
}
pub const HIP_SUCCESS: _bindgen_ty_57 = 0;
pub const HIP_ERROR_INVALID_VALUE: _bindgen_ty_57 = 1;
pub const HIP_ERROR_NOT_INITIALIZED: _bindgen_ty_57 = 2;
pub const HIP_ERROR_LAUNCH_OUT_OF_RESOURCES: _bindgen_ty_57 = 3;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
#[doc = " @defgroup GlobalDefs Global enum and defines\n @{\n\n/\n/**\n hipDeviceArch_t\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceArch_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasGlobalInt32Atomics_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasGlobalInt32Atomics_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasGlobalFloatAtomicExch_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasGlobalFloatAtomicExch_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasSharedInt32Atomics_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasSharedInt32Atomics_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasSharedFloatAtomicExch_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasSharedFloatAtomicExch_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasFloatAtomicAdd_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasFloatAtomicAdd_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasGlobalInt64Atomics_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasGlobalInt64Atomics_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasSharedInt64Atomics_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasSharedInt64Atomics_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasDoubles_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasDoubles_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasWarpVote_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasWarpVote_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasWarpBallot_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasWarpBallot_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasWarpShuffle_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasWarpShuffle_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasFunnelShift_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasFunnelShift_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasThreadFenceSystem_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasThreadFenceSystem_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasSyncThreadsExt_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasSyncThreadsExt_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasSurfaceFuncs_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasSurfaceFuncs_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has3dGrid_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has3dGrid_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hasDynamicParallelism_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hasDynamicParallelism_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::std::os::raw::c_uint,
        hasGlobalFloatAtomicExch: ::std::os::raw::c_uint,
        hasSharedInt32Atomics: ::std::os::raw::c_uint,
        hasSharedFloatAtomicExch: ::std::os::raw::c_uint,
        hasFloatAtomicAdd: ::std::os::raw::c_uint,
        hasGlobalInt64Atomics: ::std::os::raw::c_uint,
        hasSharedInt64Atomics: ::std::os::raw::c_uint,
        hasDoubles: ::std::os::raw::c_uint,
        hasWarpVote: ::std::os::raw::c_uint,
        hasWarpBallot: ::std::os::raw::c_uint,
        hasWarpShuffle: ::std::os::raw::c_uint,
        hasFunnelShift: ::std::os::raw::c_uint,
        hasThreadFenceSystem: ::std::os::raw::c_uint,
        hasSyncThreadsExt: ::std::os::raw::c_uint,
        hasSurfaceFuncs: ::std::os::raw::c_uint,
        has3dGrid: ::std::os::raw::c_uint,
        hasDynamicParallelism: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUUID_t {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
pub type hipUUID = hipUUID_t;
#[doc = " hipDeviceProp\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceProp_tR0600 {
    #[doc = "< Device name."]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< UUID of a device"]
    pub uuid: hipUUID,
    #[doc = "< 8-byte unique identifier. Only valid on windows"]
    pub luid: [::std::os::raw::c_char; 8usize],
    #[doc = "< LUID node mask"]
    pub luidDeviceNodeMask: ::std::os::raw::c_uint,
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory per block (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::std::os::raw::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies\n< pitched memory"]
    pub memPitch: usize,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Size of shared constant memory region on the device\n< (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "< Pitch alignment requirement for texture references bound to"]
    pub texturePitchAlignment: usize,
    #[doc = "< Deprecated. Use asyncEngineCount instead"]
    pub deviceOverlap: ::std::os::raw::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::std::os::raw::c_int,
    #[doc = "< Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    #[doc = "< APU vs dGPU"]
    pub integrated: ::std::os::raw::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::std::os::raw::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::std::os::raw::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 1D mipmap texture size"]
    pub maxTexture1DMipmap: ::std::os::raw::c_int,
    #[doc = "< Maximum size for 1D textures bound to linear memory"]
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum number of elements in 2D array mipmap of images"]
    pub maxTexture2DMipmap: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D tex dimensions if tex are bound to pitched memory"]
    pub maxTexture2DLinear: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 2D tex dimensions if gather has to be performed"]
    pub maxTexture2DGather: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image\n< elements"]
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum alternate 3D texture dims"]
    pub maxTexture3DAlt: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum cubemap texture dims"]
    pub maxTextureCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum number of elements in 1D array images"]
    pub maxTexture1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum number of elements in 2D array images"]
    pub maxTexture2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum cubemaps layered texture dims"]
    pub maxTextureCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 1D surface size"]
    pub maxSurface1D: ::std::os::raw::c_int,
    #[doc = "< Maximum 2D surface size"]
    pub maxSurface2D: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 3D surface size"]
    pub maxSurface3D: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum 1D layered surface size"]
    pub maxSurface1DLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Maximum 2D layared surface size"]
    pub maxSurface2DLayered: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum cubemap surface size"]
    pub maxSurfaceCubemap: ::std::os::raw::c_int,
    #[doc = "< Maximum cubemap layered surface size"]
    pub maxSurfaceCubemapLayered: [::std::os::raw::c_int; 2usize],
    #[doc = "< Alignment requirement for surface"]
    pub surfaceAlignment: usize,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::std::os::raw::c_int,
    #[doc = "< Device has ECC support enabled"]
    pub ECCEnabled: ::std::os::raw::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::std::os::raw::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::std::os::raw::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::std::os::raw::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::std::os::raw::c_int,
    #[doc = "< Number of async engines"]
    pub asyncEngineCount: ::std::os::raw::c_int,
    #[doc = "< Does device and host share unified address space"]
    pub unifiedAddressing: ::std::os::raw::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::std::os::raw::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::std::os::raw::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::std::os::raw::c_int,
    #[doc = "< Device's max L2 persisting lines in bytes"]
    pub persistingL2CacheMaxSize: ::std::os::raw::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Device supports stream priority"]
    pub streamPrioritiesSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates globals are cached in L1"]
    pub globalL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Locals are cahced in L1"]
    pub localL1CacheSupported: ::std::os::raw::c_int,
    #[doc = "< Amount of shared memory available per multiprocessor."]
    pub sharedMemPerMultiprocessor: usize,
    #[doc = "< registers available per multiprocessor"]
    pub regsPerMultiprocessor: ::std::os::raw::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::std::os::raw::c_int,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    #[doc = "< Unique identifier for a group of devices on same multiboard GPU"]
    pub multiGpuBoardGroupID: ::std::os::raw::c_int,
    #[doc = "< Link between host and device supports native atomics"]
    pub hostNativeAtomicSupported: ::std::os::raw::c_int,
    #[doc = "< Deprecated. CUDA only."]
    pub singleToDoublePrecisionPerfRatio: ::std::os::raw::c_int,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with\n< the CPU"]
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    #[doc = "< Is compute preemption supported on the device"]
    pub computePreemptionSupported: ::std::os::raw::c_int,
    #[doc = "< Device can access host registered memory with same\n< address as the host"]
    pub canUseHostPointerForRegisteredMem: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple\n< devices"]
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    #[doc = "< Per device m ax shared mem per block usable by special opt in"]
    pub sharedMemPerBlockOptin: usize,
    #[doc = "< Device accesses pageable memory via the host's\n< page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
    #[doc = "< Host can directly access managed memory on the device\n< without migration"]
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    #[doc = "< Max number of blocks on CU"]
    pub maxBlocksPerMultiProcessor: ::std::os::raw::c_int,
    #[doc = "< Max value of access policy window"]
    pub accessPolicyMaxWindowSize: ::std::os::raw::c_int,
    #[doc = "< Shared memory reserved by driver per block"]
    pub reservedSharedMemPerBlock: usize,
    #[doc = "< Device supports hipHostRegister"]
    pub hostRegisterSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates if device supports sparse hip arrays"]
    pub sparseHipArraySupported: ::std::os::raw::c_int,
    #[doc = "< Device supports using the hipHostRegisterReadOnly flag\n< with hipHostRegistger"]
    pub hostRegisterReadOnlySupported: ::std::os::raw::c_int,
    #[doc = "< Indicates external timeline semaphore support"]
    pub timelineSemaphoreInteropSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates if device supports hipMallocAsync and hipMemPool APIs"]
    pub memoryPoolsSupported: ::std::os::raw::c_int,
    #[doc = "< Indicates device support of RDMA APIs"]
    pub gpuDirectRDMASupported: ::std::os::raw::c_int,
    #[doc = "< Bitmask to be interpreted according to\n< hipFlushGPUDirectRDMAWritesOptions"]
    pub gpuDirectRDMAFlushWritesOptions: ::std::os::raw::c_uint,
    #[doc = "< value of hipGPUDirectRDMAWritesOrdering"]
    pub gpuDirectRDMAWritesOrdering: ::std::os::raw::c_int,
    #[doc = "< Bitmask of handle types support with mempool based IPC"]
    pub memoryPoolSupportedHandleTypes: ::std::os::raw::c_uint,
    #[doc = "< Device supports deferred mapping HIP arrays and HIP\n< mipmapped arrays"]
    pub deferredMappingHipArraySupported: ::std::os::raw::c_int,
    #[doc = "< Device supports IPC events"]
    pub ipcEventSupported: ::std::os::raw::c_int,
    #[doc = "< Device supports cluster launch"]
    pub clusterLaunch: ::std::os::raw::c_int,
    #[doc = "< Indicates device supports unified function pointers"]
    pub unifiedFunctionPointers: ::std::os::raw::c_int,
    #[doc = "< CUDA Reserved."]
    pub reserved: [::std::os::raw::c_int; 63usize],
    #[doc = "< Reserved for adding new entries for HIP/CUDA."]
    pub hipReserved: [::std::os::raw::c_int; 32usize],
    #[doc = "< AMD GCN Arch Name. HIP Only."]
    pub gcnArchName: [::std::os::raw::c_char; 256usize],
    #[doc = "< Maximum Shared Memory Per CU. HIP Only."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\"\n< instructions.  New for HIP."]
    pub clockInstructionRate: ::std::os::raw::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::std::os::raw::c_uint,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::std::os::raw::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::std::os::raw::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::std::os::raw::c_int,
    #[doc = "< Revision of the GPU in this device"]
    pub asicRevision: ::std::os::raw::c_int,
}
#[doc = "< Unregistered memory"]
pub const hipMemoryType_hipMemoryTypeUnregistered: hipMemoryType = 0;
#[doc = "< Memory is physically located on host"]
pub const hipMemoryType_hipMemoryTypeHost: hipMemoryType = 1;
#[doc = "< Memory is physically located on device. (see deviceId for\n< specific device)"]
pub const hipMemoryType_hipMemoryTypeDevice: hipMemoryType = 2;
#[doc = "< Managed memory, automaticallly managed by the unified\n< memory system\n< place holder for new values."]
pub const hipMemoryType_hipMemoryTypeManaged: hipMemoryType = 3;
#[doc = "< Array memory, physically located on device. (see deviceId for\n< specific device)"]
pub const hipMemoryType_hipMemoryTypeArray: hipMemoryType = 10;
#[doc = "< unified address space"]
pub const hipMemoryType_hipMemoryTypeUnified: hipMemoryType = 11;
#[doc = " hipMemoryType (for pointer attributes)\n\n @note hipMemoryType enum values are combination of cudaMemoryType and cuMemoryType and AMD specific enum values.\n"]
pub type hipMemoryType = ::std::os::raw::c_uint;
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPointerAttribute_t {
    pub type_: hipMemoryType,
    pub device: ::std::os::raw::c_int,
    pub devicePointer: *mut ::std::os::raw::c_void,
    pub hostPointer: *mut ::std::os::raw::c_void,
    pub isManaged: ::std::os::raw::c_int,
    pub allocationFlags: ::std::os::raw::c_uint,
}
#[doc = "< Successful completion."]
pub const hipError_t_hipSuccess: hipError_t = 0;
#[doc = "< One or more of the parameters passed to the API call is NULL\n< or not in an acceptable range."]
pub const hipError_t_hipErrorInvalidValue: hipError_t = 1;
#[doc = "< out of memory range."]
pub const hipError_t_hipErrorOutOfMemory: hipError_t = 2;
#[doc = "< Memory allocation error."]
pub const hipError_t_hipErrorMemoryAllocation: hipError_t = 2;
#[doc = "< Invalid not initialized"]
pub const hipError_t_hipErrorNotInitialized: hipError_t = 3;
pub const hipError_t_hipErrorInitializationError: hipError_t = 3;
#[doc = "< Deinitialized"]
pub const hipError_t_hipErrorDeinitialized: hipError_t = 4;
pub const hipError_t_hipErrorProfilerDisabled: hipError_t = 5;
pub const hipError_t_hipErrorProfilerNotInitialized: hipError_t = 6;
pub const hipError_t_hipErrorProfilerAlreadyStarted: hipError_t = 7;
pub const hipError_t_hipErrorProfilerAlreadyStopped: hipError_t = 8;
#[doc = "< Invalide configuration"]
pub const hipError_t_hipErrorInvalidConfiguration: hipError_t = 9;
#[doc = "< Invalid pitch value"]
pub const hipError_t_hipErrorInvalidPitchValue: hipError_t = 12;
#[doc = "< Invalid symbol"]
pub const hipError_t_hipErrorInvalidSymbol: hipError_t = 13;
#[doc = "< Invalid Device Pointer"]
pub const hipError_t_hipErrorInvalidDevicePointer: hipError_t = 17;
#[doc = "< Invalid memory copy direction"]
pub const hipError_t_hipErrorInvalidMemcpyDirection: hipError_t = 21;
pub const hipError_t_hipErrorInsufficientDriver: hipError_t = 35;
pub const hipError_t_hipErrorMissingConfiguration: hipError_t = 52;
pub const hipError_t_hipErrorPriorLaunchFailure: hipError_t = 53;
#[doc = "< Invalid device function"]
pub const hipError_t_hipErrorInvalidDeviceFunction: hipError_t = 98;
#[doc = "< Call to hipGetDeviceCount returned 0 devices"]
pub const hipError_t_hipErrorNoDevice: hipError_t = 100;
#[doc = "< DeviceID must be in range from 0 to compute-devices."]
pub const hipError_t_hipErrorInvalidDevice: hipError_t = 101;
#[doc = "< Invalid image"]
pub const hipError_t_hipErrorInvalidImage: hipError_t = 200;
#[doc = "< Produced when input context is invalid."]
pub const hipError_t_hipErrorInvalidContext: hipError_t = 201;
pub const hipError_t_hipErrorContextAlreadyCurrent: hipError_t = 202;
pub const hipError_t_hipErrorMapFailed: hipError_t = 205;
#[doc = "< Produced when the IPC memory attach failed from ROCr."]
pub const hipError_t_hipErrorMapBufferObjectFailed: hipError_t = 205;
pub const hipError_t_hipErrorUnmapFailed: hipError_t = 206;
pub const hipError_t_hipErrorArrayIsMapped: hipError_t = 207;
pub const hipError_t_hipErrorAlreadyMapped: hipError_t = 208;
pub const hipError_t_hipErrorNoBinaryForGpu: hipError_t = 209;
pub const hipError_t_hipErrorAlreadyAcquired: hipError_t = 210;
pub const hipError_t_hipErrorNotMapped: hipError_t = 211;
pub const hipError_t_hipErrorNotMappedAsArray: hipError_t = 212;
pub const hipError_t_hipErrorNotMappedAsPointer: hipError_t = 213;
pub const hipError_t_hipErrorECCNotCorrectable: hipError_t = 214;
#[doc = "< Unsupported limit"]
pub const hipError_t_hipErrorUnsupportedLimit: hipError_t = 215;
#[doc = "< The context is already in use"]
pub const hipError_t_hipErrorContextAlreadyInUse: hipError_t = 216;
pub const hipError_t_hipErrorPeerAccessUnsupported: hipError_t = 217;
#[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
pub const hipError_t_hipErrorInvalidKernelFile: hipError_t = 218;
pub const hipError_t_hipErrorInvalidGraphicsContext: hipError_t = 219;
#[doc = "< Invalid source."]
pub const hipError_t_hipErrorInvalidSource: hipError_t = 300;
#[doc = "< the file is not found."]
pub const hipError_t_hipErrorFileNotFound: hipError_t = 301;
pub const hipError_t_hipErrorSharedObjectSymbolNotFound: hipError_t = 302;
#[doc = "< Failed to initialize shared object."]
pub const hipError_t_hipErrorSharedObjectInitFailed: hipError_t = 303;
#[doc = "< Not the correct operating system"]
pub const hipError_t_hipErrorOperatingSystem: hipError_t = 304;
#[doc = "< Invalide handle"]
pub const hipError_t_hipErrorInvalidHandle: hipError_t = 400;
#[doc = "< Resource handle (hipEvent_t or hipStream_t) invalid."]
pub const hipError_t_hipErrorInvalidResourceHandle: hipError_t = 400;
#[doc = "< Resource required is not in a valid state to perform operation."]
pub const hipError_t_hipErrorIllegalState: hipError_t = 401;
#[doc = "< Not found"]
pub const hipError_t_hipErrorNotFound: hipError_t = 500;
#[doc = "< Indicates that asynchronous operations enqueued earlier are not\n< ready.  This is not actually an error, but is used to distinguish\n< from hipSuccess (which indicates completion).  APIs that return\n< this error include hipEventQuery and hipStreamQuery."]
pub const hipError_t_hipErrorNotReady: hipError_t = 600;
pub const hipError_t_hipErrorIllegalAddress: hipError_t = 700;
#[doc = "< Out of resources error."]
pub const hipError_t_hipErrorLaunchOutOfResources: hipError_t = 701;
#[doc = "< Timeout for the launch."]
pub const hipError_t_hipErrorLaunchTimeOut: hipError_t = 702;
#[doc = "< Peer access was already enabled from the current\n< device."]
pub const hipError_t_hipErrorPeerAccessAlreadyEnabled: hipError_t = 704;
#[doc = "< Peer access was never enabled from the current device."]
pub const hipError_t_hipErrorPeerAccessNotEnabled: hipError_t = 705;
#[doc = "< The process is active."]
pub const hipError_t_hipErrorSetOnActiveProcess: hipError_t = 708;
#[doc = "< The context is already destroyed"]
pub const hipError_t_hipErrorContextIsDestroyed: hipError_t = 709;
#[doc = "< Produced when the kernel calls assert."]
pub const hipError_t_hipErrorAssert: hipError_t = 710;
#[doc = "< Produced when trying to lock a page-locked\n< memory."]
pub const hipError_t_hipErrorHostMemoryAlreadyRegistered: hipError_t = 712;
#[doc = "< Produced when trying to unlock a non-page-locked\n< memory."]
pub const hipError_t_hipErrorHostMemoryNotRegistered: hipError_t = 713;
#[doc = "< An exception occurred on the device while executing a kernel."]
pub const hipError_t_hipErrorLaunchFailure: hipError_t = 719;
#[doc = "< This error indicates that the number of blocks\n< launched per grid for a kernel that was launched\n< via cooperative launch APIs exceeds the maximum\n< number of allowed blocks for the current device."]
pub const hipError_t_hipErrorCooperativeLaunchTooLarge: hipError_t = 720;
#[doc = "< Produced when the hip API is not supported/implemented"]
pub const hipError_t_hipErrorNotSupported: hipError_t = 801;
#[doc = "< The operation is not permitted when the stream\n< is capturing."]
pub const hipError_t_hipErrorStreamCaptureUnsupported: hipError_t = 900;
#[doc = "< The current capture sequence on the stream\n< has been invalidated due to a previous error."]
pub const hipError_t_hipErrorStreamCaptureInvalidated: hipError_t = 901;
#[doc = "< The operation would have resulted in a merge of\n< two independent capture sequences."]
pub const hipError_t_hipErrorStreamCaptureMerge: hipError_t = 902;
#[doc = "< The capture was not initiated in this stream."]
pub const hipError_t_hipErrorStreamCaptureUnmatched: hipError_t = 903;
#[doc = "< The capture sequence contains a fork that was not\n< joined to the primary stream."]
pub const hipError_t_hipErrorStreamCaptureUnjoined: hipError_t = 904;
#[doc = "< A dependency would have been created which crosses\n< the capture sequence boundary. Only implicit\n< in-stream ordering dependencies  are allowed\n< to cross the boundary"]
pub const hipError_t_hipErrorStreamCaptureIsolation: hipError_t = 905;
#[doc = "< The operation would have resulted in a disallowed\n< implicit dependency on a current capture sequence\n< from hipStreamLegacy."]
pub const hipError_t_hipErrorStreamCaptureImplicit: hipError_t = 906;
#[doc = "< The operation is not permitted on an event which was last\n< recorded in a capturing stream."]
pub const hipError_t_hipErrorCapturedEvent: hipError_t = 907;
#[doc = "< A stream capture sequence not initiated with\n< the hipStreamCaptureModeRelaxed argument to\n< hipStreamBeginCapture was passed to\n< hipStreamEndCapture in a different thread."]
pub const hipError_t_hipErrorStreamCaptureWrongThread: hipError_t = 908;
#[doc = "< This error indicates that the graph update\n< not performed because it included changes which\n< violated constraintsspecific to instantiated graph\n< update."]
pub const hipError_t_hipErrorGraphExecUpdateFailure: hipError_t = 910;
#[doc = "< Unknown error."]
pub const hipError_t_hipErrorUnknown: hipError_t = 999;
#[doc = "< HSA runtime memory call returned error.  Typically not seen\n< in production systems."]
pub const hipError_t_hipErrorRuntimeMemory: hipError_t = 1052;
#[doc = "< HSA runtime call other than memory returned error.  Typically\n< not seen in production systems."]
pub const hipError_t_hipErrorRuntimeOther: hipError_t = 1053;
#[doc = "< Marker that more error codes are needed."]
pub const hipError_t_hipErrorTbd: hipError_t = 1054;
#[doc = " HIP error type\n"]
pub type hipError_t = ::std::os::raw::c_uint;
pub const hipDeviceAttribute_t_hipDeviceAttributeCudaCompatibleBegin: hipDeviceAttribute_t = 0;
#[doc = "< Whether ECC support is enabled."]
pub const hipDeviceAttribute_t_hipDeviceAttributeEccEnabled: hipDeviceAttribute_t = 0;
#[doc = "< Cuda only. The maximum size of the window policy in bytes."]
pub const hipDeviceAttribute_t_hipDeviceAttributeAccessPolicyMaxWindowSize: hipDeviceAttribute_t =
    1;
#[doc = "< Asynchronous engines number."]
pub const hipDeviceAttribute_t_hipDeviceAttributeAsyncEngineCount: hipDeviceAttribute_t = 2;
#[doc = "< Whether host memory can be mapped into device address space"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCanMapHostMemory: hipDeviceAttribute_t = 3;
#[doc = "< Device can access host registered memory\n< at the same virtual address as the CPU"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCanUseHostPointerForRegisteredMem:
    hipDeviceAttribute_t = 4;
#[doc = "< Peak clock frequency in kilohertz."]
pub const hipDeviceAttribute_t_hipDeviceAttributeClockRate: hipDeviceAttribute_t = 5;
#[doc = "< Compute mode that device is currently in."]
pub const hipDeviceAttribute_t_hipDeviceAttributeComputeMode: hipDeviceAttribute_t = 6;
#[doc = "< Device supports Compute Preemption."]
pub const hipDeviceAttribute_t_hipDeviceAttributeComputePreemptionSupported: hipDeviceAttribute_t =
    7;
#[doc = "< Device can possibly execute multiple kernels concurrently."]
pub const hipDeviceAttribute_t_hipDeviceAttributeConcurrentKernels: hipDeviceAttribute_t = 8;
#[doc = "< Device can coherently access managed memory concurrently with the CPU"]
pub const hipDeviceAttribute_t_hipDeviceAttributeConcurrentManagedAccess: hipDeviceAttribute_t = 9;
#[doc = "< Support cooperative launch"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCooperativeLaunch: hipDeviceAttribute_t = 10;
#[doc = "< Support cooperative launch on multiple devices"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCooperativeMultiDeviceLaunch:
    hipDeviceAttribute_t = 11;
#[doc = "< Device can concurrently copy memory and execute a kernel.\n< Deprecated. Use instead asyncEngineCount."]
pub const hipDeviceAttribute_t_hipDeviceAttributeDeviceOverlap: hipDeviceAttribute_t = 12;
#[doc = "< Host can directly access managed memory on\n< the device without migration"]
pub const hipDeviceAttribute_t_hipDeviceAttributeDirectManagedMemAccessFromHost:
    hipDeviceAttribute_t = 13;
#[doc = "< Device supports caching globals in L1"]
pub const hipDeviceAttribute_t_hipDeviceAttributeGlobalL1CacheSupported: hipDeviceAttribute_t = 14;
#[doc = "< Link between the device and the host supports native atomic operations"]
pub const hipDeviceAttribute_t_hipDeviceAttributeHostNativeAtomicSupported: hipDeviceAttribute_t =
    15;
#[doc = "< Device is integrated GPU"]
pub const hipDeviceAttribute_t_hipDeviceAttributeIntegrated: hipDeviceAttribute_t = 16;
#[doc = "< Multiple GPU devices."]
pub const hipDeviceAttribute_t_hipDeviceAttributeIsMultiGpuBoard: hipDeviceAttribute_t = 17;
#[doc = "< Run time limit for kernels executed on the device"]
pub const hipDeviceAttribute_t_hipDeviceAttributeKernelExecTimeout: hipDeviceAttribute_t = 18;
#[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2 cache."]
pub const hipDeviceAttribute_t_hipDeviceAttributeL2CacheSize: hipDeviceAttribute_t = 19;
#[doc = "< caching locals in L1 is supported"]
pub const hipDeviceAttribute_t_hipDeviceAttributeLocalL1CacheSupported: hipDeviceAttribute_t = 20;
#[doc = "< 8-byte locally unique identifier in 8 bytes. Undefined on TCC and non-Windows platforms"]
pub const hipDeviceAttribute_t_hipDeviceAttributeLuid: hipDeviceAttribute_t = 21;
#[doc = "< Luid device node mask. Undefined on TCC and non-Windows platforms"]
pub const hipDeviceAttribute_t_hipDeviceAttributeLuidDeviceNodeMask: hipDeviceAttribute_t = 22;
#[doc = "< Major compute capability version number."]
pub const hipDeviceAttribute_t_hipDeviceAttributeComputeCapabilityMajor: hipDeviceAttribute_t = 23;
#[doc = "< Device supports allocating managed memory on this system"]
pub const hipDeviceAttribute_t_hipDeviceAttributeManagedMemory: hipDeviceAttribute_t = 24;
#[doc = "< Max block size per multiprocessor"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxBlocksPerMultiProcessor: hipDeviceAttribute_t =
    25;
#[doc = "< Max block size in width."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxBlockDimX: hipDeviceAttribute_t = 26;
#[doc = "< Max block size in height."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxBlockDimY: hipDeviceAttribute_t = 27;
#[doc = "< Max block size in depth."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxBlockDimZ: hipDeviceAttribute_t = 28;
#[doc = "< Max grid size  in width."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxGridDimX: hipDeviceAttribute_t = 29;
#[doc = "< Max grid size  in height."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxGridDimY: hipDeviceAttribute_t = 30;
#[doc = "< Max grid size  in depth."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxGridDimZ: hipDeviceAttribute_t = 31;
#[doc = "< Maximum size of 1D surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurface1D: hipDeviceAttribute_t = 32;
#[doc = "< Cuda only. Maximum dimensions of 1D layered surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurface1DLayered: hipDeviceAttribute_t = 33;
#[doc = "< Maximum dimension (width, height) of 2D surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurface2D: hipDeviceAttribute_t = 34;
#[doc = "< Cuda only. Maximum dimensions of 2D layered surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurface2DLayered: hipDeviceAttribute_t = 35;
#[doc = "< Maximum dimension (width, height, depth) of 3D surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurface3D: hipDeviceAttribute_t = 36;
#[doc = "< Cuda only. Maximum dimensions of Cubemap surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurfaceCubemap: hipDeviceAttribute_t = 37;
#[doc = "< Cuda only. Maximum dimension of Cubemap layered surface."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSurfaceCubemapLayered: hipDeviceAttribute_t =
    38;
#[doc = "< Maximum size of 1D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture1DWidth: hipDeviceAttribute_t = 39;
#[doc = "< Maximum dimensions of 1D layered texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture1DLayered: hipDeviceAttribute_t = 40;
#[doc = "< Maximum number of elements allocatable in a 1D linear texture.\n< Use cudaDeviceGetTexture1DLinearMaxWidth() instead on Cuda."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture1DLinear: hipDeviceAttribute_t = 41;
#[doc = "< Maximum size of 1D mipmapped texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture1DMipmap: hipDeviceAttribute_t = 42;
#[doc = "< Maximum dimension width of 2D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture2DWidth: hipDeviceAttribute_t = 43;
#[doc = "< Maximum dimension hight of 2D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture2DHeight: hipDeviceAttribute_t = 44;
#[doc = "< Maximum dimensions of 2D texture if gather operations  performed."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture2DGather: hipDeviceAttribute_t = 45;
#[doc = "< Maximum dimensions of 2D layered texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture2DLayered: hipDeviceAttribute_t = 46;
#[doc = "< Maximum dimensions (width, height, pitch) of 2D textures bound to pitched memory."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture2DLinear: hipDeviceAttribute_t = 47;
#[doc = "< Maximum dimensions of 2D mipmapped texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture2DMipmap: hipDeviceAttribute_t = 48;
#[doc = "< Maximum dimension width of 3D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture3DWidth: hipDeviceAttribute_t = 49;
#[doc = "< Maximum dimension height of 3D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture3DHeight: hipDeviceAttribute_t = 50;
#[doc = "< Maximum dimension depth of 3D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture3DDepth: hipDeviceAttribute_t = 51;
#[doc = "< Maximum dimensions of alternate 3D texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTexture3DAlt: hipDeviceAttribute_t = 52;
#[doc = "< Maximum dimensions of Cubemap texture"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTextureCubemap: hipDeviceAttribute_t = 53;
#[doc = "< Maximum dimensions of Cubemap layered texture."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxTextureCubemapLayered: hipDeviceAttribute_t =
    54;
#[doc = "< Maximum dimension of a block"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxThreadsDim: hipDeviceAttribute_t = 55;
#[doc = "< Maximum number of threads per block."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxThreadsPerBlock: hipDeviceAttribute_t = 56;
#[doc = "< Maximum resident threads per multiprocessor."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxThreadsPerMultiProcessor: hipDeviceAttribute_t =
    57;
#[doc = "< Maximum pitch in bytes allowed by memory copies"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxPitch: hipDeviceAttribute_t = 58;
#[doc = "< Global memory bus width in bits."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMemoryBusWidth: hipDeviceAttribute_t = 59;
#[doc = "< Peak memory clock frequency in kilohertz."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMemoryClockRate: hipDeviceAttribute_t = 60;
#[doc = "< Minor compute capability version number."]
pub const hipDeviceAttribute_t_hipDeviceAttributeComputeCapabilityMinor: hipDeviceAttribute_t = 61;
#[doc = "< Unique ID of device group on the same multi-GPU board"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMultiGpuBoardGroupID: hipDeviceAttribute_t = 62;
#[doc = "< Number of multiprocessors on the device."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMultiprocessorCount: hipDeviceAttribute_t = 63;
#[doc = "< Previously hipDeviceAttributeName"]
pub const hipDeviceAttribute_t_hipDeviceAttributeUnused1: hipDeviceAttribute_t = 64;
#[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
pub const hipDeviceAttribute_t_hipDeviceAttributePageableMemoryAccess: hipDeviceAttribute_t = 65;
#[doc = "< Device accesses pageable memory via the host's page tables"]
pub const hipDeviceAttribute_t_hipDeviceAttributePageableMemoryAccessUsesHostPageTables:
    hipDeviceAttribute_t = 66;
#[doc = "< PCI Bus ID."]
pub const hipDeviceAttribute_t_hipDeviceAttributePciBusId: hipDeviceAttribute_t = 67;
#[doc = "< PCI Device ID."]
pub const hipDeviceAttribute_t_hipDeviceAttributePciDeviceId: hipDeviceAttribute_t = 68;
#[doc = "< PCI Domain ID."]
pub const hipDeviceAttribute_t_hipDeviceAttributePciDomainID: hipDeviceAttribute_t = 69;
#[doc = "< Maximum l2 persisting lines capacity in bytes"]
pub const hipDeviceAttribute_t_hipDeviceAttributePersistingL2CacheMaxSize: hipDeviceAttribute_t =
    70;
#[doc = "< 32-bit registers available to a thread block. This number is shared\n< by all thread blocks simultaneously resident on a multiprocessor."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxRegistersPerBlock: hipDeviceAttribute_t = 71;
#[doc = "< 32-bit registers available per block."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxRegistersPerMultiprocessor:
    hipDeviceAttribute_t = 72;
#[doc = "< Shared memory reserved by CUDA driver per block."]
pub const hipDeviceAttribute_t_hipDeviceAttributeReservedSharedMemPerBlock: hipDeviceAttribute_t =
    73;
#[doc = "< Maximum shared memory available per block in bytes."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSharedMemoryPerBlock: hipDeviceAttribute_t = 74;
#[doc = "< Maximum shared memory per block usable by special opt in."]
pub const hipDeviceAttribute_t_hipDeviceAttributeSharedMemPerBlockOptin: hipDeviceAttribute_t = 75;
#[doc = "< Shared memory available per multiprocessor."]
pub const hipDeviceAttribute_t_hipDeviceAttributeSharedMemPerMultiprocessor: hipDeviceAttribute_t =
    76;
#[doc = "< Cuda only. Performance ratio of single precision to double precision."]
pub const hipDeviceAttribute_t_hipDeviceAttributeSingleToDoublePrecisionPerfRatio:
    hipDeviceAttribute_t = 77;
#[doc = "< Whether to support stream priorities."]
pub const hipDeviceAttribute_t_hipDeviceAttributeStreamPrioritiesSupported: hipDeviceAttribute_t =
    78;
#[doc = "< Alignment requirement for surfaces"]
pub const hipDeviceAttribute_t_hipDeviceAttributeSurfaceAlignment: hipDeviceAttribute_t = 79;
#[doc = "< Cuda only. Whether device is a Tesla device using TCC driver"]
pub const hipDeviceAttribute_t_hipDeviceAttributeTccDriver: hipDeviceAttribute_t = 80;
#[doc = "< Alignment requirement for textures"]
pub const hipDeviceAttribute_t_hipDeviceAttributeTextureAlignment: hipDeviceAttribute_t = 81;
#[doc = "< Pitch alignment requirement for 2D texture references bound to pitched memory;"]
pub const hipDeviceAttribute_t_hipDeviceAttributeTexturePitchAlignment: hipDeviceAttribute_t = 82;
#[doc = "< Constant memory size in bytes."]
pub const hipDeviceAttribute_t_hipDeviceAttributeTotalConstantMemory: hipDeviceAttribute_t = 83;
#[doc = "< Global memory available on devicice."]
pub const hipDeviceAttribute_t_hipDeviceAttributeTotalGlobalMem: hipDeviceAttribute_t = 84;
#[doc = "< Cuda only. An unified address space shared with the host."]
pub const hipDeviceAttribute_t_hipDeviceAttributeUnifiedAddressing: hipDeviceAttribute_t = 85;
#[doc = "< Previously hipDeviceAttributeUuid"]
pub const hipDeviceAttribute_t_hipDeviceAttributeUnused2: hipDeviceAttribute_t = 86;
#[doc = "< Warp size in threads."]
pub const hipDeviceAttribute_t_hipDeviceAttributeWarpSize: hipDeviceAttribute_t = 87;
#[doc = "< Device supports HIP Stream Ordered Memory Allocator"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMemoryPoolsSupported: hipDeviceAttribute_t = 88;
#[doc = "< Device supports HIP virtual memory management"]
pub const hipDeviceAttribute_t_hipDeviceAttributeVirtualMemoryManagementSupported:
    hipDeviceAttribute_t = 89;
#[doc = "< Can device support host memory registration via hipHostRegister"]
pub const hipDeviceAttribute_t_hipDeviceAttributeHostRegisterSupported: hipDeviceAttribute_t = 90;
#[doc = "< Supported handle mask for HIP Stream Ordered Memory Allocator"]
pub const hipDeviceAttribute_t_hipDeviceAttributeMemoryPoolSupportedHandleTypes:
    hipDeviceAttribute_t = 91;
pub const hipDeviceAttribute_t_hipDeviceAttributeCudaCompatibleEnd: hipDeviceAttribute_t = 9999;
pub const hipDeviceAttribute_t_hipDeviceAttributeAmdSpecificBegin: hipDeviceAttribute_t = 10000;
#[doc = "< Frequency in khz of the timer used by the device-side \"clock*\""]
pub const hipDeviceAttribute_t_hipDeviceAttributeClockInstructionRate: hipDeviceAttribute_t = 10000;
#[doc = "< Previously hipDeviceAttributeArch"]
pub const hipDeviceAttribute_t_hipDeviceAttributeUnused3: hipDeviceAttribute_t = 10001;
#[doc = "< Maximum Shared Memory PerMultiprocessor."]
pub const hipDeviceAttribute_t_hipDeviceAttributeMaxSharedMemoryPerMultiprocessor:
    hipDeviceAttribute_t = 10002;
#[doc = "< Previously hipDeviceAttributeGcnArch"]
pub const hipDeviceAttribute_t_hipDeviceAttributeUnused4: hipDeviceAttribute_t = 10003;
#[doc = "< Previously hipDeviceAttributeGcnArchName"]
pub const hipDeviceAttribute_t_hipDeviceAttributeUnused5: hipDeviceAttribute_t = 10004;
#[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
pub const hipDeviceAttribute_t_hipDeviceAttributeHdpMemFlushCntl: hipDeviceAttribute_t = 10005;
#[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
pub const hipDeviceAttribute_t_hipDeviceAttributeHdpRegFlushCntl: hipDeviceAttribute_t = 10006;
#[doc = "< Supports cooperative launch on multiple\n< devices with unmatched functions"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc:
    hipDeviceAttribute_t = 10007;
#[doc = "< Supports cooperative launch on multiple\n< devices with unmatched grid dimensions"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim:
    hipDeviceAttribute_t = 10008;
#[doc = "< Supports cooperative launch on multiple\n< devices with unmatched block dimensions"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim:
    hipDeviceAttribute_t = 10009;
#[doc = "< Supports cooperative launch on multiple\n< devices with unmatched shared memories"]
pub const hipDeviceAttribute_t_hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem:
    hipDeviceAttribute_t = 10010;
#[doc = "< Whether it is LargeBar"]
pub const hipDeviceAttribute_t_hipDeviceAttributeIsLargeBar: hipDeviceAttribute_t = 10011;
#[doc = "< Revision of the GPU in this device"]
pub const hipDeviceAttribute_t_hipDeviceAttributeAsicRevision: hipDeviceAttribute_t = 10012;
#[doc = "< '1' if Device supports hipStreamWaitValue32() and\n< hipStreamWaitValue64(), '0' otherwise."]
pub const hipDeviceAttribute_t_hipDeviceAttributeCanUseStreamWaitValue: hipDeviceAttribute_t =
    10013;
#[doc = "< '1' if Device supports image, '0' otherwise."]
pub const hipDeviceAttribute_t_hipDeviceAttributeImageSupport: hipDeviceAttribute_t = 10014;
#[doc = "< All available physical compute\n< units for the device"]
pub const hipDeviceAttribute_t_hipDeviceAttributePhysicalMultiProcessorCount: hipDeviceAttribute_t =
    10015;
#[doc = "< '1' if Device supports fine grain, '0' otherwise"]
pub const hipDeviceAttribute_t_hipDeviceAttributeFineGrainSupport: hipDeviceAttribute_t = 10016;
#[doc = "< Constant frequency of wall clock in kilohertz."]
pub const hipDeviceAttribute_t_hipDeviceAttributeWallClockRate: hipDeviceAttribute_t = 10017;
pub const hipDeviceAttribute_t_hipDeviceAttributeAmdSpecificEnd: hipDeviceAttribute_t = 19999;
pub const hipDeviceAttribute_t_hipDeviceAttributeVendorSpecificBegin: hipDeviceAttribute_t = 20000;
#[doc = " hipDeviceAttribute_t\n hipDeviceAttributeUnused number: 5"]
pub type hipDeviceAttribute_t = ::std::os::raw::c_uint;
pub const hipDriverProcAddressQueryResult_HIP_GET_PROC_ADDRESS_SUCCESS:
    hipDriverProcAddressQueryResult = 0;
pub const hipDriverProcAddressQueryResult_HIP_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND:
    hipDriverProcAddressQueryResult = 1;
pub const hipDriverProcAddressQueryResult_HIP_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT:
    hipDriverProcAddressQueryResult = 2;
pub type hipDriverProcAddressQueryResult = ::std::os::raw::c_uint;
pub const hipComputeMode_hipComputeModeDefault: hipComputeMode = 0;
pub const hipComputeMode_hipComputeModeExclusive: hipComputeMode = 1;
pub const hipComputeMode_hipComputeModeProhibited: hipComputeMode = 2;
pub const hipComputeMode_hipComputeModeExclusiveProcess: hipComputeMode = 3;
pub type hipComputeMode = ::std::os::raw::c_uint;
pub const hipFlushGPUDirectRDMAWritesOptions_hipFlushGPUDirectRDMAWritesOptionHost:
    hipFlushGPUDirectRDMAWritesOptions = 1;
pub const hipFlushGPUDirectRDMAWritesOptions_hipFlushGPUDirectRDMAWritesOptionMemOps:
    hipFlushGPUDirectRDMAWritesOptions = 2;
pub type hipFlushGPUDirectRDMAWritesOptions = ::std::os::raw::c_uint;
pub const hipGPUDirectRDMAWritesOrdering_hipGPUDirectRDMAWritesOrderingNone:
    hipGPUDirectRDMAWritesOrdering = 0;
pub const hipGPUDirectRDMAWritesOrdering_hipGPUDirectRDMAWritesOrderingOwner:
    hipGPUDirectRDMAWritesOrdering = 100;
pub const hipGPUDirectRDMAWritesOrdering_hipGPUDirectRDMAWritesOrderingAllDevices:
    hipGPUDirectRDMAWritesOrdering = 200;
pub type hipGPUDirectRDMAWritesOrdering = ::std::os::raw::c_uint;
pub type hipDeviceptr_t = *mut ::std::os::raw::c_void;
pub const hipChannelFormatKind_hipChannelFormatKindSigned: hipChannelFormatKind = 0;
pub const hipChannelFormatKind_hipChannelFormatKindUnsigned: hipChannelFormatKind = 1;
pub const hipChannelFormatKind_hipChannelFormatKindFloat: hipChannelFormatKind = 2;
pub const hipChannelFormatKind_hipChannelFormatKindNone: hipChannelFormatKind = 3;
pub type hipChannelFormatKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChannelFormatDesc {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub f: hipChannelFormatKind,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    _unused: [u8; 0],
}
pub type hipArray_t = *mut hipArray;
pub type hipArray_const_t = *const hipArray;
pub const hipArray_Format_HIP_AD_FORMAT_UNSIGNED_INT8: hipArray_Format = 1;
pub const hipArray_Format_HIP_AD_FORMAT_UNSIGNED_INT16: hipArray_Format = 2;
pub const hipArray_Format_HIP_AD_FORMAT_UNSIGNED_INT32: hipArray_Format = 3;
pub const hipArray_Format_HIP_AD_FORMAT_SIGNED_INT8: hipArray_Format = 8;
pub const hipArray_Format_HIP_AD_FORMAT_SIGNED_INT16: hipArray_Format = 9;
pub const hipArray_Format_HIP_AD_FORMAT_SIGNED_INT32: hipArray_Format = 10;
pub const hipArray_Format_HIP_AD_FORMAT_HALF: hipArray_Format = 16;
pub const hipArray_Format_HIP_AD_FORMAT_FLOAT: hipArray_Format = 32;
pub type hipArray_Format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hip_Memcpy2D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMipmappedArray {
    pub data: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
    pub min_mipmap_level: ::std::os::raw::c_uint,
    pub max_mipmap_level: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub format: hipArray_Format,
    pub num_channels: ::std::os::raw::c_uint,
}
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipmipmappedArray = hipMipmappedArray_t;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
pub const hipResourceType_hipResourceTypeArray: hipResourceType = 0;
pub const hipResourceType_hipResourceTypeMipmappedArray: hipResourceType = 1;
pub const hipResourceType_hipResourceTypeLinear: hipResourceType = 2;
pub const hipResourceType_hipResourceTypePitch2D: hipResourceType = 3;
#[doc = " hip resource types"]
pub type hipResourceType = ::std::os::raw::c_uint;
#[doc = "< Array resoure"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_ARRAY: HIPresourcetype_enum = 0;
#[doc = "< Mipmapped array resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY: HIPresourcetype_enum = 1;
#[doc = "< Linear resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_LINEAR: HIPresourcetype_enum = 2;
#[doc = "< Pitch 2D resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_PITCH2D: HIPresourcetype_enum = 3;
pub type HIPresourcetype_enum = ::std::os::raw::c_uint;
pub use self::HIPresourcetype_enum as HIPresourcetype;
pub use self::HIPresourcetype_enum as hipResourcetype;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_WRAP: HIPaddress_mode_enum = 0;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_CLAMP: HIPaddress_mode_enum = 1;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_MIRROR: HIPaddress_mode_enum = 2;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_BORDER: HIPaddress_mode_enum = 3;
#[doc = " hip address modes"]
pub type HIPaddress_mode_enum = ::std::os::raw::c_uint;
#[doc = " hip address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_POINT: HIPfilter_mode_enum = 0;
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_LINEAR: HIPfilter_mode_enum = 1;
#[doc = " hip filter modes"]
pub type HIPfilter_mode_enum = ::std::os::raw::c_uint;
#[doc = " hip filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[doc = " Texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
pub const hipResourceViewFormat_hipResViewFormatNone: hipResourceViewFormat = 0;
pub const hipResourceViewFormat_hipResViewFormatUnsignedChar1: hipResourceViewFormat = 1;
pub const hipResourceViewFormat_hipResViewFormatUnsignedChar2: hipResourceViewFormat = 2;
pub const hipResourceViewFormat_hipResViewFormatUnsignedChar4: hipResourceViewFormat = 3;
pub const hipResourceViewFormat_hipResViewFormatSignedChar1: hipResourceViewFormat = 4;
pub const hipResourceViewFormat_hipResViewFormatSignedChar2: hipResourceViewFormat = 5;
pub const hipResourceViewFormat_hipResViewFormatSignedChar4: hipResourceViewFormat = 6;
pub const hipResourceViewFormat_hipResViewFormatUnsignedShort1: hipResourceViewFormat = 7;
pub const hipResourceViewFormat_hipResViewFormatUnsignedShort2: hipResourceViewFormat = 8;
pub const hipResourceViewFormat_hipResViewFormatUnsignedShort4: hipResourceViewFormat = 9;
pub const hipResourceViewFormat_hipResViewFormatSignedShort1: hipResourceViewFormat = 10;
pub const hipResourceViewFormat_hipResViewFormatSignedShort2: hipResourceViewFormat = 11;
pub const hipResourceViewFormat_hipResViewFormatSignedShort4: hipResourceViewFormat = 12;
pub const hipResourceViewFormat_hipResViewFormatUnsignedInt1: hipResourceViewFormat = 13;
pub const hipResourceViewFormat_hipResViewFormatUnsignedInt2: hipResourceViewFormat = 14;
pub const hipResourceViewFormat_hipResViewFormatUnsignedInt4: hipResourceViewFormat = 15;
pub const hipResourceViewFormat_hipResViewFormatSignedInt1: hipResourceViewFormat = 16;
pub const hipResourceViewFormat_hipResViewFormatSignedInt2: hipResourceViewFormat = 17;
pub const hipResourceViewFormat_hipResViewFormatSignedInt4: hipResourceViewFormat = 18;
pub const hipResourceViewFormat_hipResViewFormatHalf1: hipResourceViewFormat = 19;
pub const hipResourceViewFormat_hipResViewFormatHalf2: hipResourceViewFormat = 20;
pub const hipResourceViewFormat_hipResViewFormatHalf4: hipResourceViewFormat = 21;
pub const hipResourceViewFormat_hipResViewFormatFloat1: hipResourceViewFormat = 22;
pub const hipResourceViewFormat_hipResViewFormatFloat2: hipResourceViewFormat = 23;
pub const hipResourceViewFormat_hipResViewFormatFloat4: hipResourceViewFormat = 24;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed1: hipResourceViewFormat =
    25;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed2: hipResourceViewFormat =
    26;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed3: hipResourceViewFormat =
    27;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed4: hipResourceViewFormat =
    28;
pub const hipResourceViewFormat_hipResViewFormatSignedBlockCompressed4: hipResourceViewFormat = 29;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed5: hipResourceViewFormat =
    30;
pub const hipResourceViewFormat_hipResViewFormatSignedBlockCompressed5: hipResourceViewFormat = 31;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed6H: hipResourceViewFormat =
    32;
pub const hipResourceViewFormat_hipResViewFormatSignedBlockCompressed6H: hipResourceViewFormat = 33;
pub const hipResourceViewFormat_hipResViewFormatUnsignedBlockCompressed7: hipResourceViewFormat =
    34;
#[doc = " hip texture resource view formats"]
pub type hipResourceViewFormat = ::std::os::raw::c_uint;
#[doc = "< No resource view format (use underlying resource format)"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_NONE: HIPresourceViewFormat_enum = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X8: HIPresourceViewFormat_enum = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X8: HIPresourceViewFormat_enum = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X8: HIPresourceViewFormat_enum = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X8: HIPresourceViewFormat_enum = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X8: HIPresourceViewFormat_enum = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X8: HIPresourceViewFormat_enum = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X16: HIPresourceViewFormat_enum = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X16: HIPresourceViewFormat_enum = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X16: HIPresourceViewFormat_enum = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X16: HIPresourceViewFormat_enum = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X16: HIPresourceViewFormat_enum = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X16: HIPresourceViewFormat_enum = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X32: HIPresourceViewFormat_enum = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X32: HIPresourceViewFormat_enum = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X32: HIPresourceViewFormat_enum = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X32: HIPresourceViewFormat_enum = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X32: HIPresourceViewFormat_enum = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X32: HIPresourceViewFormat_enum = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X16: HIPresourceViewFormat_enum =
    19;
#[doc = "< 2 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X16: HIPresourceViewFormat_enum =
    20;
#[doc = "< 4 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X16: HIPresourceViewFormat_enum =
    21;
#[doc = "< 1 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X32: HIPresourceViewFormat_enum =
    22;
#[doc = "< 2 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X32: HIPresourceViewFormat_enum =
    23;
#[doc = "< 4 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X32: HIPresourceViewFormat_enum =
    24;
#[doc = "< Block compressed 1"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC1: HIPresourceViewFormat_enum =
    25;
#[doc = "< Block compressed 2"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC2: HIPresourceViewFormat_enum =
    26;
#[doc = "< Block compressed 3"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC3: HIPresourceViewFormat_enum =
    27;
#[doc = "< Block compressed 4 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC4: HIPresourceViewFormat_enum =
    28;
#[doc = "< Block compressed 4 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC4: HIPresourceViewFormat_enum =
    29;
#[doc = "< Block compressed 5 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC5: HIPresourceViewFormat_enum =
    30;
#[doc = "< Block compressed 5 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC5: HIPresourceViewFormat_enum =
    31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H: HIPresourceViewFormat_enum =
    32;
#[doc = "< Block compressed 6 signed half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC6H: HIPresourceViewFormat_enum =
    33;
#[doc = "< Block compressed 7"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC7: HIPresourceViewFormat_enum =
    34;
pub type HIPresourceViewFormat_enum = ::std::os::raw::c_uint;
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " hip resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceViewDesc {
    pub format: hipResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
#[doc = "< Host-to-Host Copy"]
pub const hipMemcpyKind_hipMemcpyHostToHost: hipMemcpyKind = 0;
#[doc = "< Host-to-Device Copy"]
pub const hipMemcpyKind_hipMemcpyHostToDevice: hipMemcpyKind = 1;
#[doc = "< Device-to-Host Copy"]
pub const hipMemcpyKind_hipMemcpyDeviceToHost: hipMemcpyKind = 2;
#[doc = "< Device-to-Device Copy"]
pub const hipMemcpyKind_hipMemcpyDeviceToDevice: hipMemcpyKind = 3;
#[doc = "< Runtime will automatically determine\n<copy-kind based on virtual addresses."]
pub const hipMemcpyKind_hipMemcpyDefault: hipMemcpyKind = 4;
#[doc = "< Device-to-Device Copy without using compute units"]
pub const hipMemcpyKind_hipMemcpyDeviceToDeviceNoCU: hipMemcpyKind = 1024;
pub type hipMemcpyKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPitchedPtr {
    pub ptr: *mut ::std::os::raw::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpy3DParms {
    pub srcArray: hipArray_t,
    pub srcPos: hipPos,
    pub srcPtr: hipPitchedPtr,
    pub dstArray: hipArray_t,
    pub dstPos: hipPos,
    pub dstPtr: hipPitchedPtr,
    pub extent: hipExtent,
    pub kind: hipMemcpyKind,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMCPY3D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcZ: usize,
    pub srcLOD: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: usize,
    pub srcHeight: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstZ: usize,
    pub dstLOD: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: usize,
    pub dstHeight: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
    pub Depth: usize,
}
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: hipFunction_attribute = 0;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: hipFunction_attribute = 1;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: hipFunction_attribute = 2;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: hipFunction_attribute = 3;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_NUM_REGS: hipFunction_attribute = 4;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_PTX_VERSION: hipFunction_attribute = 5;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_BINARY_VERSION: hipFunction_attribute = 6;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA: hipFunction_attribute = 7;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES:
    hipFunction_attribute = 8;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT:
    hipFunction_attribute = 9;
pub const hipFunction_attribute_HIP_FUNC_ATTRIBUTE_MAX: hipFunction_attribute = 10;
pub type hipFunction_attribute = ::std::os::raw::c_uint;
#[doc = "< The context on which a pointer was allocated\n< @warning - not supported in HIP"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_CONTEXT: hipPointer_attribute = 1;
#[doc = "< memory type describing location of a pointer"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_MEMORY_TYPE: hipPointer_attribute = 2;
#[doc = "< address at which the pointer is allocated on device"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_DEVICE_POINTER: hipPointer_attribute = 3;
#[doc = "< address at which the pointer is allocated on host"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_HOST_POINTER: hipPointer_attribute = 4;
#[doc = "< A pair of tokens for use with linux kernel interface\n< @warning - not supported in HIP"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_P2P_TOKENS: hipPointer_attribute = 5;
#[doc = "< Synchronize every synchronous memory operation\n< initiated on this region"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS: hipPointer_attribute = 6;
#[doc = "< Unique ID for an allocated memory region"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_BUFFER_ID: hipPointer_attribute = 7;
#[doc = "< Indicates if the pointer points to managed memory"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_IS_MANAGED: hipPointer_attribute = 8;
#[doc = "< device ordinal of a device on which a pointer\n< was allocated or registered"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL: hipPointer_attribute = 9;
#[doc = "< if this pointer maps to an allocation\n< that is suitable for hipIpcGetMemHandle\n< @warning - not supported in HIP"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE:
    hipPointer_attribute = 10;
#[doc = "< Starting address for this requested pointer"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR: hipPointer_attribute = 11;
#[doc = "< Size of the address range for this requested pointer"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_RANGE_SIZE: hipPointer_attribute = 12;
#[doc = "< tells if this pointer is in a valid address range\n< that is mapped to a backing allocation"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_MAPPED: hipPointer_attribute = 13;
#[doc = "< Bitmask of allowed hipmemAllocationHandleType\n< for this allocation @warning - not supported in HIP"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES: hipPointer_attribute =
    14;
#[doc = "< returns if the memory referenced by\n< this pointer can be used with the GPUDirect RDMA API\n< @warning - not supported in HIP"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE:
    hipPointer_attribute = 15;
#[doc = "< Returns the access flags the device associated with\n< for the corresponding memory referenced by the ptr"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS: hipPointer_attribute = 16;
#[doc = "< Returns the mempool handle for the allocation if\n< it was allocated from a mempool\n< @warning - not supported in HIP"]
pub const hipPointer_attribute_HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE: hipPointer_attribute = 17;
pub type hipPointer_attribute = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[link_name = "\u{1}_ZN8hip_impl8hip_initEv"]
    pub fn hip_impl_hip_init() -> hipError_t;
}
pub type uchar1 = u8;
pub type uchar2 = u16;
pub type uchar3 = __BindgenOpaqueArray<u8, 3usize>;
pub type uchar4 = u32;
pub type char1 = u8;
pub type char2 = u16;
pub type char3 = __BindgenOpaqueArray<u8, 3usize>;
pub type char4 = u32;
pub type ushort1 = u16;
pub type ushort2 = u32;
pub type ushort3 = __BindgenOpaqueArray<u16, 3usize>;
pub type ushort4 = u64;
pub type short1 = u16;
pub type short2 = u32;
pub type short3 = __BindgenOpaqueArray<u16, 3usize>;
pub type short4 = u64;
pub type uint1 = u32;
pub type uint2 = u64;
pub type uint3 = __BindgenOpaqueArray<u32, 3usize>;
pub type uint4 = u128;
pub type int1 = u32;
pub type int2 = u64;
pub type int3 = __BindgenOpaqueArray<u32, 3usize>;
pub type int4 = u128;
pub type ulong1 = u64;
pub type ulong2 = u128;
pub type ulong3 = __BindgenOpaqueArray<u64, 3usize>;
pub type ulong4 = __BindgenOpaqueArray<u8, 32usize>;
pub type long1 = u64;
pub type long2 = u128;
pub type long3 = __BindgenOpaqueArray<u64, 3usize>;
pub type long4 = __BindgenOpaqueArray<u8, 32usize>;
pub type ulonglong1 = u64;
pub type ulonglong2 = u128;
pub type ulonglong3 = __BindgenOpaqueArray<u64, 3usize>;
pub type ulonglong4 = __BindgenOpaqueArray<u8, 32usize>;
pub type longlong1 = u64;
pub type longlong2 = u128;
pub type longlong3 = __BindgenOpaqueArray<u64, 3usize>;
pub type longlong4 = __BindgenOpaqueArray<u8, 32usize>;
pub type float1 = u32;
pub type float2 = u64;
pub type float3 = __BindgenOpaqueArray<u32, 3usize>;
pub type float4 = u128;
pub type double1 = u64;
pub type double2 = u128;
pub type double3 = __BindgenOpaqueArray<u64, 3usize>;
pub type double4 = __BindgenOpaqueArray<u8, 32usize>;
unsafe extern "C" {
    pub fn hipCreateChannelDesc(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc;
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
pub const hipTextureAddressMode_hipAddressModeWrap: hipTextureAddressMode = 0;
pub const hipTextureAddressMode_hipAddressModeClamp: hipTextureAddressMode = 1;
pub const hipTextureAddressMode_hipAddressModeMirror: hipTextureAddressMode = 2;
pub const hipTextureAddressMode_hipAddressModeBorder: hipTextureAddressMode = 3;
#[doc = " hip texture address modes"]
pub type hipTextureAddressMode = ::std::os::raw::c_uint;
pub const hipTextureFilterMode_hipFilterModePoint: hipTextureFilterMode = 0;
pub const hipTextureFilterMode_hipFilterModeLinear: hipTextureFilterMode = 1;
#[doc = " hip texture filter modes"]
pub type hipTextureFilterMode = ::std::os::raw::c_uint;
pub const hipTextureReadMode_hipReadModeElementType: hipTextureReadMode = 0;
pub const hipTextureReadMode_hipReadModeNormalizedFloat: hipTextureReadMode = 1;
#[doc = " hip texture read modes"]
pub type hipTextureReadMode = ::std::os::raw::c_uint;
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::std::os::raw::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::std::os::raw::c_int,
    pub format: hipArray_Format,
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::std::os::raw::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
pub type hipTexRef = *mut textureReference;
#[doc = " An opaque value that represents a hip surface object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_surface {
    _unused: [u8; 0],
}
pub type hipSurfaceObject_t = *mut __hip_surface;
#[doc = " hip surface reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surfaceReference {
    pub surfaceObject: hipSurfaceObject_t,
}
pub const hipSurfaceBoundaryMode_hipBoundaryModeZero: hipSurfaceBoundaryMode = 0;
pub const hipSurfaceBoundaryMode_hipBoundaryModeTrap: hipSurfaceBoundaryMode = 1;
pub const hipSurfaceBoundaryMode_hipBoundaryModeClamp: hipSurfaceBoundaryMode = 2;
#[doc = " hip surface boundary modes"]
pub type hipSurfaceBoundaryMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::std::os::raw::c_int;
pub const hipDeviceP2PAttr_hipDevP2PAttrPerformanceRank: hipDeviceP2PAttr = 0;
pub const hipDeviceP2PAttr_hipDevP2PAttrAccessSupported: hipDeviceP2PAttr = 1;
pub const hipDeviceP2PAttr_hipDevP2PAttrNativeAtomicSupported: hipDeviceP2PAttr = 2;
pub const hipDeviceP2PAttr_hipDevP2PAttrHipArrayAccessSupported: hipDeviceP2PAttr = 3;
pub type hipDeviceP2PAttr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemPoolHandle_t {
    _unused: [u8; 0],
}
#[doc = " HIP memory pool"]
pub type hipMemPool_t = *mut ihipMemPoolHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::std::os::raw::c_int,
    pub cacheModeCA: ::std::os::raw::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub numRegs: ::std::os::raw::c_int,
    pub preferredShmemCarveout: ::std::os::raw::c_int,
    pub ptxVersion: ::std::os::raw::c_int,
    pub sharedSizeBytes: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
#[doc = "< Limit of stack size in bytes on the current device, per\n< thread. The size is in units of 256 dwords, up to the\n< limit of (128K - 16)"]
pub const hipLimit_t_hipLimitStackSize: hipLimit_t = 0;
#[doc = "< Size limit in bytes of fifo used by printf call on the\n< device. Currently not supported"]
pub const hipLimit_t_hipLimitPrintfFifoSize: hipLimit_t = 1;
#[doc = "< Limit of heap size in bytes on the current device, should\n< be less than the global memory size on the device"]
pub const hipLimit_t_hipLimitMallocHeapSize: hipLimit_t = 2;
#[doc = "< Supported limit range"]
pub const hipLimit_t_hipLimitRange: hipLimit_t = 3;
#[doc = " hipLimit\n\n @note In HIP device limit-related APIs, any input limit value other than those defined in the\n enum is treated as \"UnsupportedLimit\" by default."]
pub type hipLimit_t = ::std::os::raw::c_uint;
#[doc = "< Data will mostly be read and only occassionally\n< be written to"]
pub const hipMemoryAdvise_hipMemAdviseSetReadMostly: hipMemoryAdvise = 1;
#[doc = "< Undo the effect of hipMemAdviseSetReadMostly"]
pub const hipMemoryAdvise_hipMemAdviseUnsetReadMostly: hipMemoryAdvise = 2;
#[doc = "< Set the preferred location for the data as\n< the specified device"]
pub const hipMemoryAdvise_hipMemAdviseSetPreferredLocation: hipMemoryAdvise = 3;
#[doc = "< Clear the preferred location for the data"]
pub const hipMemoryAdvise_hipMemAdviseUnsetPreferredLocation: hipMemoryAdvise = 4;
#[doc = "< Data will be accessed by the specified device\n< so prevent page faults as much as possible"]
pub const hipMemoryAdvise_hipMemAdviseSetAccessedBy: hipMemoryAdvise = 5;
#[doc = "< Let HIP to decide on the page faulting policy\n< for the specified device"]
pub const hipMemoryAdvise_hipMemAdviseUnsetAccessedBy: hipMemoryAdvise = 6;
#[doc = "< The default memory model is fine-grain. That allows\n< coherent operations between host and device, while\n< executing kernels. The coarse-grain can be used\n< for data that only needs to be coherent at dispatch\n< boundaries for better performance"]
pub const hipMemoryAdvise_hipMemAdviseSetCoarseGrain: hipMemoryAdvise = 100;
#[doc = "< Restores cache coherency policy back to fine-grain"]
pub const hipMemoryAdvise_hipMemAdviseUnsetCoarseGrain: hipMemoryAdvise = 101;
#[doc = " HIP Memory Advise values\n\n @note This memory advise enumeration is used on Linux, not Windows."]
pub type hipMemoryAdvise = ::std::os::raw::c_uint;
#[doc = "< Updates to memory with this attribute can be\n< done coherently from all devices"]
pub const hipMemRangeCoherencyMode_hipMemRangeCoherencyModeFineGrain: hipMemRangeCoherencyMode = 0;
#[doc = "< Writes to memory with this attribute can be\n< performed by a single device at a time"]
pub const hipMemRangeCoherencyMode_hipMemRangeCoherencyModeCoarseGrain: hipMemRangeCoherencyMode =
    1;
#[doc = "< Memory region queried contains subregions with\n< both hipMemRangeCoherencyModeFineGrain and\n< hipMemRangeCoherencyModeCoarseGrain attributes"]
pub const hipMemRangeCoherencyMode_hipMemRangeCoherencyModeIndeterminate: hipMemRangeCoherencyMode =
    2;
#[doc = " HIP Coherency Mode"]
pub type hipMemRangeCoherencyMode = ::std::os::raw::c_uint;
#[doc = "< Whether the range will mostly be read and\n< only occassionally be written to"]
pub const hipMemRangeAttribute_hipMemRangeAttributeReadMostly: hipMemRangeAttribute = 1;
#[doc = "< The preferred location of the range"]
pub const hipMemRangeAttribute_hipMemRangeAttributePreferredLocation: hipMemRangeAttribute = 2;
#[doc = "< Memory range has hipMemAdviseSetAccessedBy\n< set for the specified device"]
pub const hipMemRangeAttribute_hipMemRangeAttributeAccessedBy: hipMemRangeAttribute = 3;
#[doc = "< The last location to where the range was\n< prefetched"]
pub const hipMemRangeAttribute_hipMemRangeAttributeLastPrefetchLocation: hipMemRangeAttribute = 4;
#[doc = "< Returns coherency mode\n< @ref hipMemRangeCoherencyMode for the range"]
pub const hipMemRangeAttribute_hipMemRangeAttributeCoherencyMode: hipMemRangeAttribute = 100;
#[doc = " HIP range attributes"]
pub type hipMemRangeAttribute = ::std::os::raw::c_uint;
#[doc = " (value type = int)\n Allow @p hipMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n hip events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
pub const hipMemPoolAttr_hipMemPoolReuseFollowEventDependencies: hipMemPoolAttr = 1;
#[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
pub const hipMemPoolAttr_hipMemPoolReuseAllowOpportunistic: hipMemPoolAttr = 2;
#[doc = " (value type = int)\n Allow @p hipMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
pub const hipMemPoolAttr_hipMemPoolReuseAllowInternalDependencies: hipMemPoolAttr = 3;
#[doc = " (value type = uint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
pub const hipMemPoolAttr_hipMemPoolAttrReleaseThreshold: hipMemPoolAttr = 4;
#[doc = " (value type = uint64_t)\n Amount of backing memory currently allocated for the mempool."]
pub const hipMemPoolAttr_hipMemPoolAttrReservedMemCurrent: hipMemPoolAttr = 5;
#[doc = " (value type = uint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
pub const hipMemPoolAttr_hipMemPoolAttrReservedMemHigh: hipMemPoolAttr = 6;
#[doc = " (value type = uint64_t)\n Amount of memory from the pool that is currently in use by the application."]
pub const hipMemPoolAttr_hipMemPoolAttrUsedMemCurrent: hipMemPoolAttr = 7;
#[doc = " (value type = uint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
pub const hipMemPoolAttr_hipMemPoolAttrUsedMemHigh: hipMemPoolAttr = 8;
#[doc = " HIP memory pool attributes"]
pub type hipMemPoolAttr = ::std::os::raw::c_uint;
pub const hipMemLocationType_hipMemLocationTypeInvalid: hipMemLocationType = 0;
#[doc = "< Device location, thus it's HIP device ID"]
pub const hipMemLocationType_hipMemLocationTypeDevice: hipMemLocationType = 1;
#[doc = " Specifies the type of location"]
pub type hipMemLocationType = ::std::os::raw::c_uint;
#[doc = " Specifies a memory location.\n\n To specify a gpu, set type = @p hipMemLocationTypeDevice and set id = the gpu's device ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemLocation {
    #[doc = "< Specifies the location type, which describes the meaning of id"]
    pub type_: hipMemLocationType,
    #[doc = "< Identifier for the provided location type @p hipMemLocationType"]
    pub id: ::std::os::raw::c_int,
}
#[doc = "< Default, make the address range not accessible"]
pub const hipMemAccessFlags_hipMemAccessFlagsProtNone: hipMemAccessFlags = 0;
#[doc = "< Set the address range read accessible"]
pub const hipMemAccessFlags_hipMemAccessFlagsProtRead: hipMemAccessFlags = 1;
#[doc = "< Set the address range read-write accessible"]
pub const hipMemAccessFlags_hipMemAccessFlagsProtReadWrite: hipMemAccessFlags = 3;
#[doc = " Specifies the memory protection flags for mapping\n"]
pub type hipMemAccessFlags = ::std::os::raw::c_uint;
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAccessDesc {
    #[doc = "< Location on which the accessibility has to change"]
    pub location: hipMemLocation,
    #[doc = "< Accessibility flags to set"]
    pub flags: hipMemAccessFlags,
}
pub const hipMemAllocationType_hipMemAllocationTypeInvalid: hipMemAllocationType = 0;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const hipMemAllocationType_hipMemAllocationTypePinned: hipMemAllocationType = 1;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const hipMemAllocationType_hipMemAllocationTypeMax: hipMemAllocationType = 2147483647;
#[doc = " Defines the allocation types"]
pub type hipMemAllocationType = ::std::os::raw::c_uint;
#[doc = "< Does not allow any export mechanism"]
pub const hipMemAllocationHandleType_hipMemHandleTypeNone: hipMemAllocationHandleType = 0;
#[doc = "< Allows a file descriptor for exporting. Permitted only on POSIX systems"]
pub const hipMemAllocationHandleType_hipMemHandleTypePosixFileDescriptor:
    hipMemAllocationHandleType = 1;
#[doc = "< Allows a Win32 NT handle for exporting. (HANDLE)"]
pub const hipMemAllocationHandleType_hipMemHandleTypeWin32: hipMemAllocationHandleType = 2;
#[doc = "< Allows a Win32 KMT handle for exporting. (D3DKMT_HANDLE)"]
pub const hipMemAllocationHandleType_hipMemHandleTypeWin32Kmt: hipMemAllocationHandleType = 4;
#[doc = " Flags for specifying handle types for memory pool allocations\n"]
pub type hipMemAllocationHandleType = ::std::os::raw::c_uint;
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as @p hipMemAllocationTypePinned"]
    pub allocType: hipMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool"]
    pub handleTypes: hipMemAllocationHandleType,
    #[doc = "< Location where allocations should reside"]
    pub location: hipMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when @p hipMemHandleTypeWin32 is specified"]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< Maximum pool size. When set to 0, defaults to a system dependent value"]
    pub maxSize: usize,
    #[doc = "< Reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 56usize],
}
#[doc = " Opaque data structure for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemPoolPtrExportData {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
pub const hipJitOption_hipJitOptionMaxRegisters: hipJitOption = 0;
pub const hipJitOption_hipJitOptionThreadsPerBlock: hipJitOption = 1;
pub const hipJitOption_hipJitOptionWallTime: hipJitOption = 2;
pub const hipJitOption_hipJitOptionInfoLogBuffer: hipJitOption = 3;
pub const hipJitOption_hipJitOptionInfoLogBufferSizeBytes: hipJitOption = 4;
pub const hipJitOption_hipJitOptionErrorLogBuffer: hipJitOption = 5;
pub const hipJitOption_hipJitOptionErrorLogBufferSizeBytes: hipJitOption = 6;
pub const hipJitOption_hipJitOptionOptimizationLevel: hipJitOption = 7;
pub const hipJitOption_hipJitOptionTargetFromContext: hipJitOption = 8;
pub const hipJitOption_hipJitOptionTarget: hipJitOption = 9;
pub const hipJitOption_hipJitOptionFallbackStrategy: hipJitOption = 10;
pub const hipJitOption_hipJitOptionGenerateDebugInfo: hipJitOption = 11;
pub const hipJitOption_hipJitOptionLogVerbose: hipJitOption = 12;
pub const hipJitOption_hipJitOptionGenerateLineInfo: hipJitOption = 13;
pub const hipJitOption_hipJitOptionCacheMode: hipJitOption = 14;
pub const hipJitOption_hipJitOptionSm3xOpt: hipJitOption = 15;
pub const hipJitOption_hipJitOptionFastCompile: hipJitOption = 16;
pub const hipJitOption_hipJitOptionNumOptions: hipJitOption = 17;
#[doc = " hipJitOption"]
pub type hipJitOption = ::std::os::raw::c_uint;
pub const hipFuncAttribute_hipFuncAttributeMaxDynamicSharedMemorySize: hipFuncAttribute = 8;
pub const hipFuncAttribute_hipFuncAttributePreferredSharedMemoryCarveout: hipFuncAttribute = 9;
pub const hipFuncAttribute_hipFuncAttributeMax: hipFuncAttribute = 10;
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
pub type hipFuncAttribute = ::std::os::raw::c_uint;
#[doc = "< no preference for shared memory or L1 (default)"]
pub const hipFuncCache_t_hipFuncCachePreferNone: hipFuncCache_t = 0;
#[doc = "< prefer larger shared memory and smaller L1 cache"]
pub const hipFuncCache_t_hipFuncCachePreferShared: hipFuncCache_t = 1;
#[doc = "< prefer larger L1 cache and smaller shared memory"]
pub const hipFuncCache_t_hipFuncCachePreferL1: hipFuncCache_t = 2;
#[doc = "< prefer equal size L1 cache and shared memory"]
pub const hipFuncCache_t_hipFuncCachePreferEqual: hipFuncCache_t = 3;
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
pub type hipFuncCache_t = ::std::os::raw::c_uint;
#[doc = "< The compiler selects a device-specific value for the banking."]
pub const hipSharedMemConfig_hipSharedMemBankSizeDefault: hipSharedMemConfig = 0;
#[doc = "< Shared mem is banked at 4-bytes intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
pub const hipSharedMemConfig_hipSharedMemBankSizeFourByte: hipSharedMemConfig = 1;
#[doc = "< Shared mem is banked at 8-byte intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
pub const hipSharedMemConfig_hipSharedMemBankSizeEightByte: hipSharedMemConfig = 2;
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
pub type hipSharedMemConfig = ::std::os::raw::c_uint;
#[doc = " Struct for data in 3D"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[doc = " struct hipLaunchParams_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::std::os::raw::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
#[doc = " struct hipLaunchParams_t"]
pub type hipLaunchParams = hipLaunchParams_t;
#[doc = " struct hipFunctionLaunchParams_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFunctionLaunchParams_t {
    #[doc = "< Kernel to launch"]
    pub function: hipFunction_t,
    #[doc = "< Width(X) of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height(Y) of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth(Z) of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Shared memory"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Stream identifier"]
    pub hStream: hipStream_t,
    #[doc = "< Kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[doc = " struct hipFunctionLaunchParams_t"]
pub type hipFunctionLaunchParams = hipFunctionLaunchParams_t;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeOpaqueFd:
    hipExternalMemoryHandleType_enum = 1;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeOpaqueWin32:
    hipExternalMemoryHandleType_enum = 2;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeOpaqueWin32Kmt:
    hipExternalMemoryHandleType_enum = 3;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeD3D12Heap:
    hipExternalMemoryHandleType_enum = 4;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeD3D12Resource:
    hipExternalMemoryHandleType_enum = 5;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeD3D11Resource:
    hipExternalMemoryHandleType_enum = 6;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeD3D11ResourceKmt:
    hipExternalMemoryHandleType_enum = 7;
pub const hipExternalMemoryHandleType_enum_hipExternalMemoryHandleTypeNvSciBuf:
    hipExternalMemoryHandleType_enum = 8;
pub type hipExternalMemoryHandleType_enum = ::std::os::raw::c_uint;
pub use self::hipExternalMemoryHandleType_enum as hipExternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st {
    pub type_: hipExternalMemoryHandleType,
    pub handle: hipExternalMemoryHandleDesc_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalMemoryHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryBufferDesc_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
pub type hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalMemoryMipmappedArrayDesc_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub formatDesc: hipChannelFormatDesc,
    pub extent: hipExtent,
    pub flags: ::std::os::raw::c_uint,
    pub numLevels: ::std::os::raw::c_uint,
}
pub type hipExternalMemoryMipmappedArrayDesc = hipExternalMemoryMipmappedArrayDesc_st;
pub type hipExternalMemory_t = *mut ::std::os::raw::c_void;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeOpaqueFd:
    hipExternalSemaphoreHandleType_enum = 1;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeOpaqueWin32:
    hipExternalSemaphoreHandleType_enum = 2;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeOpaqueWin32Kmt:
    hipExternalSemaphoreHandleType_enum = 3;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeD3D12Fence:
    hipExternalSemaphoreHandleType_enum = 4;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeD3D11Fence:
    hipExternalSemaphoreHandleType_enum = 5;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeNvSciSync:
    hipExternalSemaphoreHandleType_enum = 6;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeKeyedMutex:
    hipExternalSemaphoreHandleType_enum = 7;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeKeyedMutexKmt:
    hipExternalSemaphoreHandleType_enum = 8;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeTimelineSemaphoreFd:
    hipExternalSemaphoreHandleType_enum = 9;
pub const hipExternalSemaphoreHandleType_enum_hipExternalSemaphoreHandleTypeTimelineSemaphoreWin32 : hipExternalSemaphoreHandleType_enum = 10 ;
pub type hipExternalSemaphoreHandleType_enum = ::std::os::raw::c_uint;
pub use self::hipExternalSemaphoreHandleType_enum as hipExternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st {
    pub type_: hipExternalSemaphoreHandleType,
    pub handle: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreHandleDesc_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    pub NvSciSyncObj: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
pub type hipExternalSemaphoreHandleDesc = hipExternalSemaphoreHandleDesc_st;
pub type hipExternalSemaphore_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st {
    pub params: hipExternalSemaphoreSignalParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
pub type hipExternalSemaphoreSignalParams = hipExternalSemaphoreSignalParams_st;
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st {
    pub params: hipExternalSemaphoreWaitParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[doc = " External semaphore wait parameters, compatible with driver type"]
pub type hipExternalSemaphoreWaitParams = hipExternalSemaphoreWaitParams_st;
unsafe extern "C" {
    #[doc = " Internal use only. This API may change in the future\n Pre-Compiled header for online compilation"]
    pub fn __hipGetPCH(pch: *mut *const ::std::os::raw::c_char, size: *mut ::std::os::raw::c_uint);
}
pub const hipGraphicsRegisterFlags_hipGraphicsRegisterFlagsNone: hipGraphicsRegisterFlags = 0;
#[doc = "< HIP will not write to this registered resource"]
pub const hipGraphicsRegisterFlags_hipGraphicsRegisterFlagsReadOnly: hipGraphicsRegisterFlags = 1;
pub const hipGraphicsRegisterFlags_hipGraphicsRegisterFlagsWriteDiscard: hipGraphicsRegisterFlags =
    2;
#[doc = "< HIP will bind this resource to a surface"]
pub const hipGraphicsRegisterFlags_hipGraphicsRegisterFlagsSurfaceLoadStore:
    hipGraphicsRegisterFlags = 4;
pub const hipGraphicsRegisterFlags_hipGraphicsRegisterFlagsTextureGather: hipGraphicsRegisterFlags =
    8;
#[doc = " HIP Access falgs for Interop resources."]
pub type hipGraphicsRegisterFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _hipGraphicsResource {
    _unused: [u8; 0],
}
pub type hipGraphicsResource = _hipGraphicsResource;
pub type hipGraphicsResource_t = *mut hipGraphicsResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipGraph {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph"]
pub type hipGraph_t = *mut ihipGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphNode {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph node"]
pub type hipGraphNode_t = *mut hipGraphNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphExec {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph Exec"]
pub type hipGraphExec_t = *mut hipGraphExec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUserObject {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a user obj"]
pub type hipUserObject_t = *mut hipUserObject;
#[doc = "< GPU kernel node"]
pub const hipGraphNodeType_hipGraphNodeTypeKernel: hipGraphNodeType = 0;
#[doc = "< Memcpy node"]
pub const hipGraphNodeType_hipGraphNodeTypeMemcpy: hipGraphNodeType = 1;
#[doc = "< Memset node"]
pub const hipGraphNodeType_hipGraphNodeTypeMemset: hipGraphNodeType = 2;
#[doc = "< Host (executable) node"]
pub const hipGraphNodeType_hipGraphNodeTypeHost: hipGraphNodeType = 3;
#[doc = "< Node which executes an embedded graph"]
pub const hipGraphNodeType_hipGraphNodeTypeGraph: hipGraphNodeType = 4;
#[doc = "< Empty (no-op) node"]
pub const hipGraphNodeType_hipGraphNodeTypeEmpty: hipGraphNodeType = 5;
#[doc = "< External event wait node"]
pub const hipGraphNodeType_hipGraphNodeTypeWaitEvent: hipGraphNodeType = 6;
#[doc = "< External event record node"]
pub const hipGraphNodeType_hipGraphNodeTypeEventRecord: hipGraphNodeType = 7;
#[doc = "< External Semaphore signal node"]
pub const hipGraphNodeType_hipGraphNodeTypeExtSemaphoreSignal: hipGraphNodeType = 8;
#[doc = "< External Semaphore wait node"]
pub const hipGraphNodeType_hipGraphNodeTypeExtSemaphoreWait: hipGraphNodeType = 9;
#[doc = "< Memory alloc node"]
pub const hipGraphNodeType_hipGraphNodeTypeMemAlloc: hipGraphNodeType = 10;
#[doc = "< Memory free node"]
pub const hipGraphNodeType_hipGraphNodeTypeMemFree: hipGraphNodeType = 11;
#[doc = "< MemcpyFromSymbol node"]
pub const hipGraphNodeType_hipGraphNodeTypeMemcpyFromSymbol: hipGraphNodeType = 12;
#[doc = "< MemcpyToSymbol node"]
pub const hipGraphNodeType_hipGraphNodeTypeMemcpyToSymbol: hipGraphNodeType = 13;
pub const hipGraphNodeType_hipGraphNodeTypeCount: hipGraphNodeType = 14;
#[doc = " hipGraphNodeType"]
pub type hipGraphNodeType = ::std::os::raw::c_uint;
pub type hipHostFn_t =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipHostNodeParams {
    pub fn_: hipHostFn_t,
    pub userData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipKernelNodeParams {
    pub blockDim: dim3,
    pub extra: *mut *mut ::std::os::raw::c_void,
    pub func: *mut ::std::os::raw::c_void,
    pub gridDim: dim3,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    pub sharedMemBytes: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemsetParams {
    pub dst: *mut ::std::os::raw::c_void,
    pub elementSize: ::std::os::raw::c_uint,
    pub height: usize,
    pub pitch: usize,
    pub value: ::std::os::raw::c_uint,
    pub width: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocNodeParams {
    #[doc = "< Pool properties, which contain where\n< the location should reside"]
    pub poolProps: hipMemPoolProps,
    #[doc = "< The number of memory access descriptors.\n< Must not be bigger than the number of GPUs"]
    pub accessDescs: *const hipMemAccessDesc,
    #[doc = "< The number of access descriptors"]
    pub accessDescCount: usize,
    #[doc = "< The size of the requested allocation in bytes"]
    pub bytesize: usize,
    #[doc = "< Returned device address of the allocation"]
    pub dptr: *mut ::std::os::raw::c_void,
}
pub const hipAccessProperty_hipAccessPropertyNormal: hipAccessProperty = 0;
pub const hipAccessProperty_hipAccessPropertyStreaming: hipAccessProperty = 1;
pub const hipAccessProperty_hipAccessPropertyPersisting: hipAccessProperty = 2;
pub type hipAccessProperty = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipAccessPolicyWindow {
    pub base_ptr: *mut ::std::os::raw::c_void,
    pub hitProp: hipAccessProperty,
    pub hitRatio: f32,
    pub missProp: hipAccessProperty,
    pub num_bytes: usize,
}
#[doc = "< Valid for Streams, graph nodes, launches"]
pub const hipLaunchAttributeID_hipLaunchAttributeAccessPolicyWindow: hipLaunchAttributeID = 1;
#[doc = "< Valid for graph nodes, launches"]
pub const hipLaunchAttributeID_hipLaunchAttributeCooperative: hipLaunchAttributeID = 2;
#[doc = "< Valid for graph node, streams, launches"]
pub const hipLaunchAttributeID_hipLaunchAttributePriority: hipLaunchAttributeID = 8;
#[doc = "  Launch Attribute ID"]
pub type hipLaunchAttributeID = ::std::os::raw::c_uint;
#[doc = "  Launch Attribute Value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipLaunchAttributeValue {
    #[doc = "< Value of launch attribute::\nhipLaunchAttributePolicyWindow."]
    pub accessPolicyWindow: hipAccessPolicyWindow,
    #[doc = "< Value of launch attribute ::hipLaunchAttributeCooperative"]
    pub cooperative: ::std::os::raw::c_int,
    #[doc = "< Value of launch attribute :: hipLaunchAttributePriority. Execution\npriority of kernel."]
    pub priority: ::std::os::raw::c_int,
}
#[doc = " Memset node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMSET_NODE_PARAMS {
    #[doc = "< Destination pointer on device"]
    pub dst: hipDeviceptr_t,
    #[doc = "< Destination device pointer pitch. Unused if height equals 1"]
    pub pitch: usize,
    #[doc = "< Value of memset to be set"]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::std::os::raw::c_uint,
    #[doc = "< Width of a row"]
    pub width: usize,
    #[doc = "< Number of rows"]
    pub height: usize,
}
#[doc = "< The update succeeded"]
pub const hipGraphExecUpdateResult_hipGraphExecUpdateSuccess: hipGraphExecUpdateResult = 0;
#[doc = "< The update failed for an unexpected reason which is described\n< in the return value of the function"]
pub const hipGraphExecUpdateResult_hipGraphExecUpdateError: hipGraphExecUpdateResult = 1;
#[doc = "< The update failed because the topology changed"]
pub const hipGraphExecUpdateResult_hipGraphExecUpdateErrorTopologyChanged:
    hipGraphExecUpdateResult = 2;
#[doc = "< The update failed because a node type changed"]
pub const hipGraphExecUpdateResult_hipGraphExecUpdateErrorNodeTypeChanged:
    hipGraphExecUpdateResult = 3;
pub const hipGraphExecUpdateResult_hipGraphExecUpdateErrorFunctionChanged:
    hipGraphExecUpdateResult = 4;
pub const hipGraphExecUpdateResult_hipGraphExecUpdateErrorParametersChanged:
    hipGraphExecUpdateResult = 5;
pub const hipGraphExecUpdateResult_hipGraphExecUpdateErrorNotSupported: hipGraphExecUpdateResult =
    6;
pub const hipGraphExecUpdateResult_hipGraphExecUpdateErrorUnsupportedFunctionChange:
    hipGraphExecUpdateResult = 7;
#[doc = " Graph execution update result"]
pub type hipGraphExecUpdateResult = ::std::os::raw::c_uint;
pub const hipStreamCaptureMode_hipStreamCaptureModeGlobal: hipStreamCaptureMode = 0;
pub const hipStreamCaptureMode_hipStreamCaptureModeThreadLocal: hipStreamCaptureMode = 1;
pub const hipStreamCaptureMode_hipStreamCaptureModeRelaxed: hipStreamCaptureMode = 2;
pub type hipStreamCaptureMode = ::std::os::raw::c_uint;
#[doc = "< Stream is not capturing"]
pub const hipStreamCaptureStatus_hipStreamCaptureStatusNone: hipStreamCaptureStatus = 0;
#[doc = "< Stream is actively capturing"]
pub const hipStreamCaptureStatus_hipStreamCaptureStatusActive: hipStreamCaptureStatus = 1;
#[doc = "< Stream is part of a capture sequence that has been\n< invalidated, but not terminated"]
pub const hipStreamCaptureStatus_hipStreamCaptureStatusInvalidated: hipStreamCaptureStatus = 2;
pub type hipStreamCaptureStatus = ::std::os::raw::c_uint;
#[doc = "< Add new nodes to the dependency set"]
pub const hipStreamUpdateCaptureDependenciesFlags_hipStreamAddCaptureDependencies:
    hipStreamUpdateCaptureDependenciesFlags = 0;
#[doc = "< Replace the dependency set with the new nodes"]
pub const hipStreamUpdateCaptureDependenciesFlags_hipStreamSetCaptureDependencies:
    hipStreamUpdateCaptureDependenciesFlags = 1;
pub type hipStreamUpdateCaptureDependenciesFlags = ::std::os::raw::c_uint;
#[doc = "< Amount of memory, in bytes, currently associated with graphs"]
pub const hipGraphMemAttributeType_hipGraphMemAttrUsedMemCurrent: hipGraphMemAttributeType = 0;
#[doc = "< High watermark of memory, in bytes, associated with graphs since the last time."]
pub const hipGraphMemAttributeType_hipGraphMemAttrUsedMemHigh: hipGraphMemAttributeType = 1;
#[doc = "< Amount of memory, in bytes, currently allocated for graphs."]
pub const hipGraphMemAttributeType_hipGraphMemAttrReservedMemCurrent: hipGraphMemAttributeType = 2;
#[doc = "< High watermark of memory, in bytes, currently allocated for graphs"]
pub const hipGraphMemAttributeType_hipGraphMemAttrReservedMemHigh: hipGraphMemAttributeType = 3;
pub type hipGraphMemAttributeType = ::std::os::raw::c_uint;
#[doc = "< Destructor execution is not synchronized."]
pub const hipUserObjectFlags_hipUserObjectNoDestructorSync: hipUserObjectFlags = 1;
pub type hipUserObjectFlags = ::std::os::raw::c_uint;
#[doc = "< Add new reference or retain."]
pub const hipUserObjectRetainFlags_hipGraphUserObjectMove: hipUserObjectRetainFlags = 1;
pub type hipUserObjectRetainFlags = ::std::os::raw::c_uint;
pub const hipGraphInstantiateFlags_hipGraphInstantiateFlagAutoFreeOnLaunch:
    hipGraphInstantiateFlags = 1;
pub const hipGraphInstantiateFlags_hipGraphInstantiateFlagUpload: hipGraphInstantiateFlags = 2;
pub const hipGraphInstantiateFlags_hipGraphInstantiateFlagDeviceLaunch: hipGraphInstantiateFlags =
    4;
pub const hipGraphInstantiateFlags_hipGraphInstantiateFlagUseNodePriority:
    hipGraphInstantiateFlags = 8;
pub type hipGraphInstantiateFlags = ::std::os::raw::c_uint;
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsVerbose: hipGraphDebugDotFlags = 1;
#[doc = "< Adds hipKernelNodeParams to output"]
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsKernelNodeParams: hipGraphDebugDotFlags = 4;
#[doc = "< Adds hipMemcpy3DParms to output"]
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsMemcpyNodeParams: hipGraphDebugDotFlags = 8;
#[doc = "< Adds hipMemsetParams to output"]
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsMemsetNodeParams: hipGraphDebugDotFlags = 16;
#[doc = "< Adds hipHostNodeParams to output"]
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsHostNodeParams: hipGraphDebugDotFlags = 32;
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsEventNodeParams: hipGraphDebugDotFlags = 64;
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsExtSemasSignalNodeParams:
    hipGraphDebugDotFlags = 128;
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsExtSemasWaitNodeParams: hipGraphDebugDotFlags =
    256;
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsKernelNodeAttributes: hipGraphDebugDotFlags =
    512;
pub const hipGraphDebugDotFlags_hipGraphDebugDotFlagsHandles: hipGraphDebugDotFlags = 1024;
pub type hipGraphDebugDotFlags = ::std::os::raw::c_uint;
#[doc = "< Instantiation Success"]
pub const hipGraphInstantiateResult_hipGraphInstantiateSuccess: hipGraphInstantiateResult = 0;
#[doc = "< Instantiation failed for an\nunexpected reason which is described in the return value of the function"]
pub const hipGraphInstantiateResult_hipGraphInstantiateError: hipGraphInstantiateResult = 1;
#[doc = "< Instantiation failed due\nto invalid structure, such as cycles"]
pub const hipGraphInstantiateResult_hipGraphInstantiateInvalidStructure: hipGraphInstantiateResult =
    2;
#[doc = "< Instantiation for device launch failed\nbecause the graph contained an unsupported operation"]
pub const hipGraphInstantiateResult_hipGraphInstantiateNodeOperationNotSupported:
    hipGraphInstantiateResult = 3;
#[doc = "< Instantiation for device launch failed\ndue to the nodes belonging to different contexts"]
pub const hipGraphInstantiateResult_hipGraphInstantiateMultipleDevicesNotSupported:
    hipGraphInstantiateResult = 4;
#[doc = " hipGraphInstantiateWithParams results"]
pub type hipGraphInstantiateResult = ::std::os::raw::c_uint;
#[doc = " Graph Instantiation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphInstantiateParams {
    #[doc = "< The node which caused instantiation to fail, if any"]
    pub errNode_out: hipGraphNode_t,
    #[doc = "< Instantiation flags"]
    pub flags: ::std::os::raw::c_ulonglong,
    #[doc = "< Whether instantiation was successful.\nIf it failed, the reason why"]
    pub result_out: hipGraphInstantiateResult,
    #[doc = "< Upload stream"]
    pub uploadStream: hipStream_t,
}
#[doc = " Memory allocation properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocationProp {
    #[doc = "< Memory allocation type"]
    pub type_: hipMemAllocationType,
    #[doc = "< Requested handle type"]
    pub requestedHandleType: hipMemAllocationHandleType,
    #[doc = "< Memory location"]
    pub location: hipMemLocation,
    #[doc = "< Metadata for Win32 handles"]
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: hipMemAllocationProp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemAllocationProp__bindgen_ty_1 {
    #[doc = "< Compression type"]
    pub compressionType: ::std::os::raw::c_uchar,
    #[doc = "< RDMA capable"]
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    #[doc = "< Usage"]
    pub usage: ::std::os::raw::c_ushort,
}
#[doc = " External semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreSignalNodeParams {
    pub extSemArray: *mut hipExternalSemaphore_t,
    pub paramsArray: *const hipExternalSemaphoreSignalParams,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[doc = " External semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExternalSemaphoreWaitNodeParams {
    pub extSemArray: *mut hipExternalSemaphore_t,
    pub paramsArray: *const hipExternalSemaphoreWaitParams,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemGenericAllocationHandle {
    _unused: [u8; 0],
}
#[doc = " Generic handle for memory allocation"]
pub type hipMemGenericAllocationHandle_t = *mut ihipMemGenericAllocationHandle;
#[doc = "< Minimum granularity"]
pub const hipMemAllocationGranularity_flags_hipMemAllocationGranularityMinimum:
    hipMemAllocationGranularity_flags = 0;
#[doc = "< Recommended granularity for performance"]
pub const hipMemAllocationGranularity_flags_hipMemAllocationGranularityRecommended:
    hipMemAllocationGranularity_flags = 1;
#[doc = " Flags for granularity"]
pub type hipMemAllocationGranularity_flags = ::std::os::raw::c_uint;
#[doc = "< Generic handle type"]
pub const hipMemHandleType_hipMemHandleTypeGeneric: hipMemHandleType = 0;
#[doc = " Memory handle type"]
pub type hipMemHandleType = ::std::os::raw::c_uint;
#[doc = "< Map operation"]
pub const hipMemOperationType_hipMemOperationTypeMap: hipMemOperationType = 1;
#[doc = "< Unmap operation"]
pub const hipMemOperationType_hipMemOperationTypeUnmap: hipMemOperationType = 2;
#[doc = " Memory operation types"]
pub type hipMemOperationType = ::std::os::raw::c_uint;
#[doc = "< Sparse level"]
pub const hipArraySparseSubresourceType_hipArraySparseSubresourceTypeSparseLevel:
    hipArraySparseSubresourceType = 0;
#[doc = "< Miptail"]
pub const hipArraySparseSubresourceType_hipArraySparseSubresourceTypeMiptail:
    hipArraySparseSubresourceType = 1;
#[doc = " Subresource types for sparse arrays"]
pub type hipArraySparseSubresourceType = ::std::os::raw::c_uint;
#[doc = " Map info for arrays"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipArrayMapInfo {
    #[doc = "< Resource type"]
    pub resourceType: hipResourceType,
    pub resource: hipArrayMapInfo__bindgen_ty_1,
    #[doc = "< Sparse subresource type"]
    pub subresourceType: hipArraySparseSubresourceType,
    pub subresource: hipArrayMapInfo__bindgen_ty_2,
    #[doc = "< Memory operation type"]
    pub memOperationType: hipMemOperationType,
    #[doc = "< Memory handle type"]
    pub memHandleType: hipMemHandleType,
    pub memHandle: hipArrayMapInfo__bindgen_ty_3,
    #[doc = "< Offset within the memory"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Device ordinal bit mask"]
    pub deviceBitMask: ::std::os::raw::c_uint,
    #[doc = "< flags for future use, must be zero now."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use, must be zero now."]
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_1 {
    pub mipmap: hipMipmappedArray,
    pub array: hipArray_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_2 {
    pub sparseLevel: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1,
    pub miptail: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For mipmapped arrays must be a valid mipmap level. For arrays must be zero"]
    pub level: ::std::os::raw::c_uint,
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< X offset in elements"]
    pub offsetX: ::std::os::raw::c_uint,
    #[doc = "< Y offset in elements"]
    pub offsetY: ::std::os::raw::c_uint,
    #[doc = "< Z offset in elements"]
    pub offsetZ: ::std::os::raw::c_uint,
    #[doc = "< Width in elements"]
    pub extentWidth: ::std::os::raw::c_uint,
    #[doc = "< Height in elements"]
    pub extentHeight: ::std::os::raw::c_uint,
    #[doc = "< Depth in elements"]
    pub extentDepth: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Offset within mip tail"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Extent in bytes"]
    pub size: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_3 {
    pub memHandle: hipMemGenericAllocationHandle_t,
}
#[doc = " Memcpy node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpyNodeParams {
    #[doc = "< Must be zero."]
    pub flags: ::std::os::raw::c_int,
    #[doc = "< Must be zero."]
    pub reserved: [::std::os::raw::c_int; 3usize],
    #[doc = "< Params set for the memory copy."]
    pub copyParams: hipMemcpy3DParms,
}
#[doc = " Child graph node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChildGraphNodeParams {
    #[doc = "< Either the child graph to clone into the node, or\n< a handle to the graph possesed by the node used during query"]
    pub graph: hipGraph_t,
}
#[doc = " Event record node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipEventWaitNodeParams {
    #[doc = "< Event to wait on"]
    pub event: hipEvent_t,
}
#[doc = " Event record node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipEventRecordNodeParams {
    #[doc = "< The event to be recorded when node executes"]
    pub event: hipEvent_t,
}
#[doc = " Memory free node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemFreeNodeParams {
    #[doc = "< the pointer to be freed"]
    pub dptr: *mut ::std::os::raw::c_void,
}
#[doc = " Params for different graph nodes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipGraphNodeParams {
    pub type_: hipGraphNodeType,
    pub reserved0: [::std::os::raw::c_int; 3usize],
    pub __bindgen_anon_1: hipGraphNodeParams__bindgen_ty_1,
    pub reserved2: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipGraphNodeParams__bindgen_ty_1 {
    pub reserved1: [::std::os::raw::c_longlong; 29usize],
    pub kernel: hipKernelNodeParams,
    pub memcpy: hipMemcpyNodeParams,
    pub memset: hipMemsetParams,
    pub host: hipHostNodeParams,
    pub graph: hipChildGraphNodeParams,
    pub eventWait: hipEventWaitNodeParams,
    pub eventRecord: hipEventRecordNodeParams,
    pub extSemSignal: hipExternalSemaphoreSignalNodeParams,
    pub extSemWait: hipExternalSemaphoreWaitNodeParams,
    pub alloc: hipMemAllocNodeParams,
    pub free: hipMemFreeNodeParams,
}
pub const hipGraphDependencyType_hipGraphDependencyTypeDefault: hipGraphDependencyType = 0;
pub const hipGraphDependencyType_hipGraphDependencyTypeProgrammatic: hipGraphDependencyType = 1;
pub type hipGraphDependencyType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphEdgeData {
    #[doc = "< This indicates when the dependency is triggered from the upstream node on the\n< edge. The meaning is specfic to the node type. A value of 0 in all cases\n< means full completion of the upstream node, with memory visibility to the\n< downstream node or portion thereof (indicated by to_port). Only kernel nodes\n< define non-zero ports. A kernel node can use the following output port types:\n< hipGraphKernelNodePortDefault, hipGraphKernelNodePortProgrammatic, or\n< hipGraphKernelNodePortLaunchCompletion."]
    pub from_port: ::std::os::raw::c_uchar,
    #[doc = "< These bytes are unused and must be zeroed"]
    pub reserved: [::std::os::raw::c_uchar; 5usize],
    #[doc = "< Currently no node types define non-zero ports. This field must be set to zero."]
    pub to_port: ::std::os::raw::c_uchar,
    #[doc = "< This should be populated with a value from hipGraphDependencyType"]
    pub type_: ::std::os::raw::c_uchar,
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n  @defgroup API HIP API\n  @{\n\n  Defines the HIP API.  See the individual sections for more information.\n/\n/**\n  @defgroup Driver Initialization and Version\n  @{\n  This section describes the initializtion and version functions of HIP runtime API.\n\n/\n/**\n @brief Explicitly initializes the HIP runtime.\n\n @param [in] flags  Initialization flag, should be zero.\n\n Most HIP APIs implicitly initialize the HIP runtime.\n This API provides control over the timing of the initialization.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipInit(flags: ::std::os::raw::c_uint) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the approximate HIP driver version.\n\n @param [out] driverVersion driver version\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK driver revision.\n This function always set *driverVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the driver revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipRuntimeGetVersion"]
    pub fn hipDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the approximate HIP Runtime version.\n\n @param [out] runtimeVersion HIP runtime version\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The version definition of HIP runtime is different from CUDA.\n On AMD platform, the function returns HIP runtime version,\n while on NVIDIA platform, it returns CUDA runtime version.\n And there is no mapping/correlation between HIP version and CUDA version.\n\n @see hipDriverGetVersion"]
    pub fn hipRuntimeGetVersion(runtimeVersion: *mut ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a handle to a compute device\n @param [out] device Handle of device\n @param [in] ordinal Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGet(device: *mut hipDevice_t, ordinal: ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the compute capability of the device\n @param [out] major Major compute capability version number\n @param [out] minor Minor compute capability version number\n @param [in] device Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns an identifer string for the device.\n @param [out] name String of the device name\n @param [in] len Maximum length of string to store in device name\n @param [in] device Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns an UUID for the device.[BETA]\n @param [out] uuid UUID for the device\n @param [in] device device ordinal\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorDeinitialized"]
    pub fn hipDeviceGetUuid(uuid: *mut hipUUID, device: hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a value for attribute of link between two devices\n @param [out] value Pointer of the value for the attrubute\n @param [in] attr enum of hipDeviceP2PAttr to query\n @param [in] srcDevice The source device of the link\n @param [in] dstDevice The destination device of the link\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: hipDeviceP2PAttr,
        srcDevice: ::std::os::raw::c_int,
        dstDevice: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID.\n @param [out] pciBusId The string of PCI Bus Id format for the device\n @param [in] len Maximum length of string\n @param [in] device The device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a handle to a compute device.\n @param [out] device The handle of the device\n @param [in] pciBusId The string of PCI Bus Id for the device\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetByPCIBusId(
        device: *mut ::std::os::raw::c_int,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the total amount of memory on the device.\n @param [out] bytes The size of memory in bytes, on the device\n @param [in] device The ordinal of the device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceTotalMem(bytes: *mut usize, device: hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n  @defgroup Device Device Management\n  @{\n  This section describes the device management functions of HIP runtime API.\n/\n/**\n @brief Waits on all active streams on current device\n\n When this command is invoked, the host thread gets blocked until all the commands associated\n with streams associated with the device. HIP does not support multiple blocking modes (yet!).\n\n @returns #hipSuccess\n\n @see hipSetDevice, hipDeviceReset"]
    pub fn hipDeviceSynchronize() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief The state of current device is discarded and updated to a fresh state.\n\n Calling this function deletes all streams created, memory allocated, kernels running, events\n created. Make sure that no other thread is using the device or streams, memory, kernels, events\n associated with the current device.\n\n @returns #hipSuccess\n\n @see hipDeviceSynchronize"]
    pub fn hipDeviceReset() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread.\n\n @param[in] deviceId Valid device in range 0...hipGetDeviceCount().\n\n Sets @p device as the default device for the calling host thread.  Valid device id's are 0...\n (hipGetDeviceCount()-1).\n\n Many HIP APIs implicitly use the \"default device\" :\n\n - Any device memory subsequently allocated from this host thread (using hipMalloc) will be\n allocated on device.\n - Any streams or events created from this host thread will be associated with device.\n - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device\n (unless a specific stream is specified, in which case the device associated with that stream will\n be used).\n\n This function may be called from any host thread.  Multiple host threads may use the same device.\n This function does no synchronization with the previous or new device, and has very little\n runtime overhead. Applications can use hipSetDevice to quickly switch the default device before\n making a HIP runtime call which uses the default device.\n\n The default device is stored in thread-local-storage for each thread.\n Thread-pool implementations may inherit the default device of the previous thread.  A good\n practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known\n standard device.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorNoDevice\n\n @see #hipGetDevice, #hipGetDeviceCount"]
    pub fn hipSetDevice(deviceId: ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set a list of devices that can be used.\n\n @param[in] device_arr List of devices to try\n @param[in] len Number of devices in specified list\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n @see #hipGetDevice, #hipGetDeviceCount. #hipSetDevice. #hipGetDeviceProperties. #hipSetDeviceFlags. #hipChooseDevice\n"]
    pub fn hipSetValidDevices(
        device_arr: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return the default device id for the calling host thread.\n\n @param [out] deviceId *device is written with the default device\n\n HIP maintains an default device for each thread using thread-local-storage.\n This device is used implicitly for HIP runtime APIs called by this thread.\n hipGetDevice returns in * @p device the default device for the calling host thread.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n @see hipSetDevice, hipGetDevicesizeBytes"]
    pub fn hipGetDevice(deviceId: *mut ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return number of compute-capable devices.\n\n @param [out] count Returns number of compute-capable devices.\n\n @returns #hipSuccess, #hipErrorNoDevice\n\n\n Returns in @p *count the number of devices that have ability to run compute commands.  If there\n are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more\n devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub fn hipGetDeviceCount(count: *mut ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query for a specific device attribute.\n\n @param [out] pi pointer to value to return\n @param [in] attr attribute to query\n @param [in] deviceId which device to query for information\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the default memory pool of the specified device\n\n @param [out] mem_pool Default memory pool to return\n @param [in] device    Device index for query the default memory pool\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGetDefaultMemPool(
        mem_pool: *mut hipMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n @p hipMallocAsync allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n @note Use @p hipMallocFromPoolAsync for asynchronous memory allocations from a device\n different than the one the stream runs on.\n\n @param [in] device   Device index for the update\n @param [in] mem_pool Memory pool for update as the current on the specified device\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceSetMemPool(device: ::std::os::raw::c_int, mem_pool: hipMemPool_t)
        -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the current memory pool for the specified device\n\n Returns the last pool provided to @p hipDeviceSetMemPool for this device\n or the device's default memory pool if @p hipDeviceSetMemPool has never been called.\n By default the current mempool is the default mempool for a device,\n otherwise the returned pool must have been set with @p hipDeviceSetMemPool.\n\n @param [out] mem_pool Current memory pool on the specified device\n @param [in] device    Device index to query the current memory pool\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGetMemPool(
        mem_pool: *mut hipMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns device properties.\n\n @param [out] prop written with device properties\n @param [in]  deviceId which device to query for information\n\n @return #hipSuccess, #hipErrorInvalidDevice\n @bug HCC always returns 0 for maxThreadsPerMultiProcessor\n @bug HCC always returns 0 for regsPerBlock\n @bug HCC always returns 0 for l2CacheSize\n\n Populates hipGetDeviceProperties with information for the specified device."]
    pub fn hipGetDevicePropertiesR0600(
        prop: *mut hipDeviceProp_tR0600,
        deviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set L1/Shared cache partition.\n\n @param [in] cacheConfig Cache configuration\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorNotSupported\n\n Note: AMD devices do not support reconfigurable cache. This API is not implemented\n on AMD platform. If the function is called, it will return hipErrorNotSupported.\n"]
    pub fn hipDeviceSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get Cache configuration for a specific Device\n\n @param [out] cacheConfig Pointer of cache configuration\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices do not support reconfigurable cache. This hint is ignored\n on these architectures.\n"]
    pub fn hipDeviceGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets resource limits of current device\n\n The function queries the size of limit value, as required by the input enum value hipLimit_t,\n which can be either #hipLimitStackSize, or #hipLimitMallocHeapSize. Any other input as\n default, the function will return #hipErrorUnsupportedLimit.\n\n @param [out] pValue Returns the size of the limit in bytes\n @param [in]  limit The limit to query\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub fn hipDeviceGetLimit(pValue: *mut usize, limit: hipLimit_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets resource limits of current device.\n\n As the input enum limit,\n #hipLimitStackSize sets the limit value of the stack size on the current GPU device, per thread.\n The limit size can get via hipDeviceGetLimit. The size is in units of 256 dwords, up to the limit\n (128K - 16).\n\n #hipLimitMallocHeapSize sets the limit value of the heap used by the malloc()/free()\n calls. For limit size, use the #hipDeviceGetLimit API.\n\n Any other input as default, the funtion will return hipErrorUnsupportedLimit.\n\n @param [in] limit Enum of hipLimit_t to set\n @param [in] value The size of limit value in bytes\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub fn hipDeviceSetLimit(limit: hipLimit_t, value: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns bank width of shared memory for current device\n\n @param [out] pConfig The pointer of the bank width for shared memory\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipDeviceGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the flags set for current device\n\n @param [out] flags Pointer of the flags\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipGetDeviceFlags(flags: *mut ::std::os::raw::c_uint) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief The bank width of shared memory on current device is set\n\n @param [in] config Configuration for the bank width of shared memory\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipDeviceSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief The current device behavior is changed according the flags passed.\n\n @param [in] flags Flag to set on the current device\n\n The schedule flags impact how HIP waits for the completion of a command running on a device.\n hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the\n work until the command completes.  This offers the lowest latency, but will consume a CPU core\n and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to\n system so that other tasks can use it.  This may increase latency to detect the completion but\n will consume less power and is friendlier to other tasks in the system.\n hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield.\n hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the\n number of HIP contexts is greater than the number of logical processors in the system, use Spin\n scheduling.  Else use Yield scheduling.\n\n\n hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and\n the flag is ignored. hipDeviceLmemResizeToMax      : @warning ROCm silently ignores this flag.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess\n\n"]
    pub fn hipSetDeviceFlags(flags: ::std::os::raw::c_uint) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Device which matches hipDeviceProp_t is returned\n\n @param [out] device Pointer of the device\n @param [in]  prop Pointer of the properties\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipChooseDeviceR0600(
        device: *mut ::std::os::raw::c_int,
        prop: *const hipDeviceProp_tR0600,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the link type and hop count between two devices\n\n @param [in] device1 Ordinal for device1\n @param [in] device2 Ordinal for device2\n @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices\n @param [out] hopcount Returns the hop count between the two devices\n\n Queries and returns the HSA link type and the hop count between the two specified devices.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipExtGetLinkTypeAndHopCount(
        device1: ::std::os::raw::c_int,
        device2: ::std::os::raw::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory\n          allocation\n\n Takes a pointer to the base of an existing device memory allocation created\n with hipMalloc and exports it for use in another process. This is a\n lightweight operation and may be called multiple times on an allocation\n without adverse effects.\n\n If a region of memory is freed with hipFree and a subsequent call\n to hipMalloc returns memory with the same device address,\n hipIpcGetMemHandle will return a unique handle for the\n new memory.\n\n @param handle - Pointer to user allocated hipIpcMemHandle to return\n                    the handle in.\n @param devPtr - Base pointer to previously allocated device memory\n\n @returns #hipSuccess, #hipErrorInvalidHandle, #hipErrorOutOfMemory, #hipErrorMapFailed\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcGetMemHandle(
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Opens an interprocess memory handle exported from another process\n          and returns a device pointer usable in the local process.\n\n Maps memory exported from another process with hipIpcGetMemHandle into\n the current device address space. For contexts on different devices\n hipIpcOpenMemHandle can attempt to enable peer access between the\n devices as if the user called hipDeviceEnablePeerAccess. This behavior is\n controlled by the hipIpcMemLazyEnablePeerAccess flag.\n hipDeviceCanAccessPeer can determine if a mapping is possible.\n\n Contexts that may open hipIpcMemHandles are restricted in the following way.\n hipIpcMemHandles from each device in a given process may only be opened\n by one context per device per other process.\n\n Memory returned from hipIpcOpenMemHandle must be freed with\n hipIpcCloseMemHandle.\n\n Calling hipFree on an exported memory region before calling\n hipIpcCloseMemHandle in the importing context will result in undefined\n behavior.\n\n @param devPtr - Returned device pointer\n @param handle - hipIpcMemHandle to open\n @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext,\n  #hipErrorInvalidDevicePointer\n\n @note During multiple processes, using the same memory handle opened by the current context,\n there is no guarantee that the same device poiter will be returned in @p *devPtr.\n This is diffrent from CUDA.\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcOpenMemHandle(
        devPtr: *mut *mut ::std::os::raw::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Close memory mapped with hipIpcOpenMemHandle\n\n Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation\n in the exporting process as well as imported mappings in other processes\n will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the\n last mapping using them.\n\n @param devPtr - Device pointer returned by hipIpcOpenMemHandle\n\n @returns #hipSuccess, #hipErrorMapFailed, #hipErrorInvalidHandle\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcCloseMemHandle(devPtr: *mut ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets an opaque interprocess handle for an event.\n\n This opaque handle may be copied into other processes and opened with hipIpcOpenEventHandle.\n Then hipEventRecord, hipEventSynchronize, hipStreamWaitEvent and hipEventQuery may be used in\n either process. Operations on the imported event after the exported event has been freed with hipEventDestroy\n will result in undefined behavior.\n\n @param[out]  handle Pointer to hipIpcEventHandle to return the opaque event handle\n @param[in]   event  Event allocated with hipEventInterprocess and hipEventDisableTiming flags\n\n @returns #hipSuccess, #hipErrorInvalidConfiguration, #hipErrorInvalidValue\n\n @note This IPC event related feature API is currently applicable on Linux.\n"]
    pub fn hipIpcGetEventHandle(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Opens an interprocess event handles.\n\n Opens an interprocess event handle exported from another process with hipIpcGetEventHandle. The returned\n hipEvent_t behaves like a locally created event with the hipEventDisableTiming flag specified. This event\n need be freed with hipEventDestroy. Operations on the imported event after the exported event has been freed\n with hipEventDestroy will result in undefined behavior. If the function is called within the same process where\n handle is returned by hipIpcGetEventHandle, it will return hipErrorInvalidContext.\n\n @param[out]  event  Pointer to hipEvent_t to return the event\n @param[in]   handle The opaque interprocess handle to open\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext\n\n @note This IPC event related feature API is currently applicable on Linux.\n"]
    pub fn hipIpcOpenEventHandle(event: *mut hipEvent_t, handle: hipIpcEventHandle_t)
        -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n\n  @defgroup Execution Execution Control\n  @{\n  This section describes the execution control functions of HIP runtime API.\n\n/\n/**\n @brief Set attribute for a specific function\n\n @param [in] func Pointer of the function\n @param [in] attr Attribute to set\n @param [in] value Value to set\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipFuncSetAttribute(
        func: *const ::std::os::raw::c_void,
        attr: hipFuncAttribute,
        value: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function\n\n @param [in] func Pointer of the function.\n @param [in] config Configuration to set.\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored\n on those architectures.\n"]
    pub fn hipFuncSetCacheConfig(
        func: *const ::std::os::raw::c_void,
        config: hipFuncCache_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set shared memory configuation for a specific function\n\n @param [in] func Pointer of the function\n @param [in] config Configuration\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipFuncSetSharedMemConfig(
        func: *const ::std::os::raw::c_void,
        config: hipSharedMemConfig,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Error Error Handling\n  @{\n  This section describes the error handling functions of HIP runtime API.\n/\n/**\n @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetLastError() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipExtGetLastError() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call.\n\n @return #hipSuccess\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread. Unlike hipGetLastError, this function does not reset the saved error code.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipPeekAtLastError() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return hip error as text string form.\n\n @param hip_error Error code to convert to name.\n @return const char pointer to the NULL-terminated error name\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorName(hip_error: hipError_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param hipError Error code to convert to string.\n @return const char pointer to the NULL-terminated error string\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorString(hipError: hipError_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Return hip error as text string form.\n\n @param [in] hipError Error code to convert to string.\n @param [out] errorString char pointer to the NULL-terminated error string\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipDrvGetErrorName(
        hipError: hipError_t,
        errorString: *mut *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param [in] hipError Error code to convert to string.\n @param [out] errorString char pointer to the NULL-terminated error string\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipDrvGetErrorString(
        hipError: hipError_t,
        errorString: *mut *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the\n newly created stream.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, application must call hipStreamDestroy.\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreate(stream: *mut hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, application must call hipStreamDestroy. Flags controls behavior of the\n stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithFlags(
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified priority.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @param[in ] priority of the stream. Lower numbers represent higher priorities.\n @return #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, application must call hipStreamDestroy. Flags controls\n behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithPriority(
        stream: *mut hipStream_t,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority.\n\n @param[in, out] leastPriority pointer in which value corresponding to least priority is returned.\n @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned.\n @returns #hipSuccess\n\n Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least\n and greatest stream priority respectively. Stream priorities follow a convention where lower numbers\n imply greater priorities. The range of meaningful stream priorities is given by\n [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value\n that is outside the meaningful range as specified by this API, the priority is automatically\n clamped to within the valid range."]
    pub fn hipDeviceGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys the specified stream.\n\n @param[in] stream stream identifier.\n @return #hipSuccess #hipErrorInvalidHandle\n\n Destroys the specified stream.\n\n If commands are still executing on the specified stream, some may complete execution before the\n queue is deleted.\n\n The queue may be destroyed while some commands are still inflight, or may wait for all commands\n queued to the stream before destroying it.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery,\n hipStreamWaitEvent, hipStreamSynchronize"]
    pub fn hipStreamDestroy(stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or\n #hipErrorNotReady if not.\n\n @param[in] stream stream to query\n\n @return #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle\n\n This is thread-safe and returns a snapshot of the current state of the queue.  However, if other\n host threads are sending work to the stream, the status may change immediately after the function\n is called.  It is typically used for debug.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent,\n hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamQuery(stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Wait for all commands in stream to complete.\n\n @param[in] stream stream identifier.\n\n @return #hipSuccess, #hipErrorInvalidHandle\n\n This command is host-synchronous : the host will block until the specified stream is empty.\n\n This command follows standard null-stream semantics.  Specifically, specifying the null stream\n will cause the command to wait for other streams on the same device to complete all pending\n operations.\n\n This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active\n or blocking.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent,\n hipStreamDestroy\n"]
    pub fn hipStreamSynchronize(stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Make the specified compute stream wait for an event\n\n @param[in] stream stream to make wait.\n @param[in] event event to wait on\n @param[in] flags control operation [must be 0]\n\n @return #hipSuccess, #hipErrorInvalidHandle\n\n This function inserts a wait operation into the specified stream.\n All future work submitted to @p stream will wait until @p event reports completion before\n beginning execution.\n\n This function only waits for commands in the current stream to complete.  Notably, this function\n does not implicitly wait for commands in the default stream to complete, even if the specified\n stream is created with hipStreamNonBlocking = 0.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamWaitEvent(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return flags associated with this stream.\n\n @param[in] stream stream to be queried\n @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Return flags associated with this stream in *@p flags.\n\n @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetFlags(stream: hipStream_t, flags: *mut ::std::os::raw::c_uint)
        -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query the priority of a stream.\n\n @param[in] stream stream to be queried\n @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Query the priority of a stream. The priority is returned in in priority.\n\n @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetPriority(
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the device assocaited with the stream\n\n @param[in] stream stream to be queried\n @param[out] device device associated with the stream\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorContextIsDestroyed, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorDeinitialized, #hipErrorInvalidContext\n\n @see hipStreamCreate, hipStreamDestroy, hipDeviceGetStreamPriorityRange"]
    pub fn hipStreamGetDevice(stream: hipStream_t, device: *mut hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified CU mask.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] cuMaskSize Size of CU mask bit array passed in.\n @param[in ] cuMask Bit-vector representing the CU mask. Each active bit represents using one CU.\n The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical\n CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored.\n It is user's responsibility to make sure the input is meaningful.\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified CU mask.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, application must call hipStreamDestroy.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamCreateWithCUMask(
        stream: *mut hipStream_t,
        cuMaskSize: u32,
        cuMask: *const u32,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get CU mask associated with an asynchronous stream\n\n @param[in] stream stream to be queried\n @param[in] cuMaskSize number of the block of memories (uint32_t *) allocated by user\n @param[out] cuMask Pointer to a pre-allocated block of memories (uint32_t *) in which\n the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where\n each active bit represents one active CU\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamGetCUMask(
        stream: hipStream_t,
        cuMaskSize: u32,
        cuMask: *mut u32,
    ) -> hipError_t;
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: hipStream_t,
        status: hipError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n hipStreamAddCallback call, a callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n @param[in] stream   - Stream to add callback to\n @param[in] callback - The function to call once preceding stream operations are complete\n @param[in] userData - User specified data to be passed to the callback function\n @param[in] flags    - Reserved for future use, must be 0\n @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,\n hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority\n"]
    pub fn hipStreamAddCallback(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup StreamM Stream Memory Operations\n  @{\n  This section describes Stream Memory Wait and Write functions of HIP runtime API.\n/\n/**\n @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte\n hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value,\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n hipStreamWaitValueGte: waits until *ptr&mask >= value\n hipStreamWaitValueEq : waits until *ptr&mask == value\n hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue64, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue32(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        flags: ::std::os::raw::c_uint,
        mask: u32,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are hipStreamWaitValueGte\n hipStreamWaitValueEq, hipStreamWaitValueAnd and hipStreamWaitValueNor.\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n hipStreamWaitValueGte: waits until *ptr&mask >= value\n hipStreamWaitValueEq : waits until *ptr&mask == value\n hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using 'hipStreamWaitValueNor', mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue32, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue64(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u64,
        flags: ::std::os::raw::c_uint,
        mask: u64,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub fn hipStreamWriteValue32(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub fn hipStreamWriteValue64(
        stream: hipStream_t,
        ptr: *mut ::std::os::raw::c_void,
        value: u64,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Event Event Management\n  @{\n  This section describes the event management functions of HIP runtime API.\n/\n/**\n @brief Create an event with the specified flags\n\n @param[in,out] event Returns the newly created event.\n @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,\n#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess\n #hipEventDefault : Default flag.  The event will use active synchronization and will support\ntiming.  Blocking synchronization provides lowest possible latency at the expense of dedicating a\nCPU to poll on the event.\n #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is\ncalled on this event, the thread will block until the event completes.  This can increase latency\nfor the synchroniation but can result in lower power and more resources for other CPU threads.\n #hipEventDisableTiming : Disable recording of timing information. Events created with this flag\nwould not record profiling data and provide best performance if used for synchronization.\n #hipEventInterprocess : The event can be used as an interprocess event. hipEventDisableTiming\nflag also must be set when hipEventInterprocess flag is set.\n #hipEventDisableSystemFence : Disable acquire and release system scope fence. This may\nimprove performance but device memory may not be visible to the host and other devices\nif this flag is set.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n#hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreateWithFlags(
        event: *mut hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  Create an event\n\n @param[in,out] event Returns the newly created event.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,\n hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreate(event: *mut hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipEventRecord(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Destroy the specified event.\n\n  @param[in] event Event to destroy.\n  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure\n\n  Releases memory associated with the event.  If the event is recording but has not completed\n recording when hipEventDestroy() is called, the function will return immediately and the\n completion_future resources will be released later, when the hipDevice is synchronized.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,\n hipEventElapsedTime\n\n @returns #hipSuccess"]
    pub fn hipEventDestroy(event: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Wait for an event to complete.\n\n  This function will block until the event is ready, waiting for all previous work in the stream\n specified when event was recorded with hipEventRecord().\n\n  If hipEventRecord() has not been called on @p event, this function returns #hipSuccess when no\n  event is captured.\n\n\n  @param[in] event Event on which to wait.\n\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorInvalidHandle, #hipErrorLaunchFailure\n\n  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventElapsedTime"]
    pub fn hipEventSynchronize(event: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return the elapsed time between two events.\n\n @param[out] ms : Return time between start and stop in ms.\n @param[in]   start : Start event.\n @param[in]   stop  : Stop event.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Computes the elapsed time between two events. Time is computed in ms, with\n a resolution of approximately 1 us.\n\n Events which are recorded in a NULL stream will block until all commands\n on all other streams complete execution, and then record the timestamp.\n\n Events which are recorded in a non-NULL stream will record their timestamp\n when they reach the head of the specified stream, after all previous\n commands in that stream have completed executing.  Thus the time that\n the event recorded may be significantly after the host calls hipEventRecord().\n\n If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is\n returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been\n recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at\n least one of the events), then #hipErrorNotReady is returned.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventSynchronize"]
    pub fn hipEventElapsedTime(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query event status\n\n @param[in] event Event to query.\n @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Query the status of the specified event.  This function will return #hipSuccess if all\n commands in the appropriate stream (specified to hipEventRecord()) have completed.  If any execution\n has not completed, then #hipErrorNotReady is returned.\n\n @note: This API returns #hipSuccess, if hipEventRecord() is not called before this API.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,\n hipEventSynchronize, hipEventElapsedTime"]
    pub fn hipEventQuery(event: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Sets information on the specified pointer.[BETA]\n\n  @param [in]      value     Sets pointer attribute value\n  @param [in]      attribute  Attribute to set\n  @param [in]      ptr      Pointer to set attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @warning This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n"]
    pub fn hipPointerSetAttribute(
        value: *const ::std::os::raw::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Returns attributes for the specified pointer\n\n  @param [out]  attributes  attributes for the specified pointer\n  @param [in]   ptr         pointer to get attributes for\n\n  The output parameter 'attributes' has a member named 'type' that describes what memory the\n  pointer is associated with, such as device memory, host memory, managed memory, and others.\n  Otherwise, the API cannot handle the pointer and returns #hipErrorInvalidValue.\n\n  @note  The unrecognized memory type is unsupported to keep the HIP functionality backward\n  compatibility due to #hipMemoryType enum values.\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @note  The current behavior of this HIP API corresponds to the CUDA API before version 11.0.\n\n  @see hipPointerGetAttribute"]
    pub fn hipPointerGetAttributes(
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in, out] data     Returned pointer attribute value\n  @param [in]      attribute  Attribute to query for\n  @param [in]      ptr      Pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @warning This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n\n  @see hipPointerGetAttributes"]
    pub fn hipPointerGetAttribute(
        data: *mut ::std::os::raw::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in]  numAttributes   number of attributes to query for\n  @param [in]  attributes      attributes to query for\n  @param [in, out] data        a two-dimensional containing pointers to memory locations\n                               where the result of each attribute query will be written to\n  @param [in]  ptr             pointer to get attributes for\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @warning This API is marked as beta, meaning, while this is feature complete,\n  it is still open to changes and may have outstanding issues.\n\n  @see hipPointerGetAttribute"]
    pub fn hipDrvPointerGetAttributes(
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut hipPointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup External External Resource Interoperability\n  @{\n  @ingroup API\n\n  This section describes the external resource interoperability functions of HIP runtime API.\n\n/\n/**\n  @brief Imports an external semaphore.\n\n  @param[out] extSem_out  External semaphores to be waited on\n  @param[in] semHandleDesc Semaphore import handle descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipImportExternalSemaphore(
        extSem_out: *mut hipExternalSemaphore_t,
        semHandleDesc: *const hipExternalSemaphoreHandleDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Signals a set of external semaphore objects.\n\n  @param[in] extSemArray  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipSignalExternalSemaphoresAsync(
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreSignalParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Waits on a set of external semaphore objects\n\n  @param[in] extSemArray  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipWaitExternalSemaphoresAsync(
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreWaitParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.\n\n  @param[in] extSem handle to an external memory object\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipDestroyExternalSemaphore(extSem: hipExternalSemaphore_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Imports an external memory object.\n\n  @param[out] extMem_out  Returned handle to an external memory object\n  @param[in]  memHandleDesc Memory import handle descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipImportExternalMemory(
        extMem_out: *mut hipExternalMemory_t,
        memHandleDesc: *const hipExternalMemoryHandleDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Maps a buffer onto an imported memory object.\n\n  @param[out] devPtr Returned device pointer to buffer\n  @param[in]  extMem  Handle to external memory object\n  @param[in]  bufferDesc  Buffer descriptor\n\n  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        extMem: hipExternalMemory_t,
        bufferDesc: *const hipExternalMemoryBufferDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Destroys an external memory object.\n\n  @param[in] extMem  External memory object to be destroyed\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipDestroyExternalMemory(extMem: hipExternalMemory_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Maps a mipmapped array onto an external memory object.\n\n  @param[out] mipmap mipmapped array to return\n  @param[in]  extMem external memory object handle\n  @param[in]  mipmapDesc external mipmapped array descriptor\n\n  Returned mipmapped array must be freed using hipFreeMipmappedArray.\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidResourceHandle\n\n  @see hipImportExternalMemory, hipDestroyExternalMemory, hipExternalMemoryGetMappedBuffer, hipFreeMipmappedArray"]
    pub fn hipExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut hipMipmappedArray_t,
        extMem: hipExternalMemory_t,
        mipmapDesc: *const hipExternalMemoryMipmappedArrayDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr Pointer to the allocated memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub fn hipMalloc(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr  Pointer to the allocated memory\n  @param[in]  sizeBytes  Requested memory size\n  @param[in]  flags  Type of memory allocation\n\n  If requested memory size is 0, no memory is allocated, *ptr returns nullptr, and #hipSuccess\n  is returned.\n\n  The memory allocation flag should be either #hipDeviceMallocDefault,\n  #hipDeviceMallocFinegrained, #hipDeviceMallocUncached, or #hipMallocSignalMemory.\n  If the flag is any other value, the API returns #hipErrorInvalidValue.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub fn hipExtMallocWithFlags(
        ptr: *mut *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n  @warning  This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipMallocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n  @warning  This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipMemAllocHost(ptr: *mut *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocates device accessible page locked (pinned) host memory\n\n  This API allocates pinned host memory which is mapped into the address space of all GPUs\n  in the system, the memory can be accessed directly by the GPU device, and can be read or\n  written with much higher bandwidth than pageable memory obtained with functions such as\n  malloc().\n\n  Using the pinned host memory, applications can implement faster data transfers for HostToDevice\n  and DeviceToHost. The runtime tracks the hipHostMalloc allocations and can avoid some of the\n  setup required for regular unpinned memory.\n\n  When the memory accesses are infrequent, zero-copy memory can be a good choice, for coherent\n  allocation. GPU can directly access the host memory over the CPU/GPU interconnect, without need\n  to copy the data.\n\n  Currently the allocation granularity is 4KB for the API.\n\n  Developers need to choose proper allocation flag with consideration of synchronization.\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size in bytes\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  @param[in]  flags Type of host memory allocation\n\n  If no input for flags, it will be the default pinned memory allocation on the host.\n\n  @return #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostFree"]
    pub fn hipHostMalloc(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup MemoryM Managed Memory\n\n  @ingroup Memory\n @{\n  This section describes the managed memory management functions of HIP runtime API.\n\n  @note  The managed memory management APIs are implemented on Linux, under developement\n  on Windows.\n\n/\n/**\n @brief Allocates memory that will be automatically managed by HIP.\n\n This API is used for managed memory, allows data be shared and accessible to both CPU and\n GPU using a single pointer.\n\n The API returns the allocation pointer, managed by HMM, can be used further to execute kernels\n on device and fetch data between the host and device as needed.\n\n @note   It is recommend to do the capability check before call this API.\n\n @param [out] dev_ptr - pointer to allocated device memory\n @param [in]  size    - requested allocation size in bytes, it should be granularity of 4KB\n @param [in]  flags   - must be either hipMemAttachGlobal or hipMemAttachHost\n                        (defaults to hipMemAttachGlobal)\n\n @returns #hipSuccess, #hipErrorMemoryAllocation, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipMallocManaged(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Prefetches memory to the specified destination device using HIP.\n\n @param [in] dev_ptr  pointer to be prefetched\n @param [in] count    size in bytes for prefetching\n @param [in] device   destination device to prefetch to\n @param [in] stream   stream to enqueue prefetch operation\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPrefetchAsync(
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        device: ::std::os::raw::c_int,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Advise about the usage of a given memory range to HIP.\n\n @param [in] dev_ptr  pointer to memory to set the advice for\n @param [in] count    size in bytes of the memory range, it should be CPU page size alligned.\n @param [in] advice   advice to be applied for the specified memory range\n @param [in] device   device to apply the advice for\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n This HIP API advises about the usage to be applied on unified memory allocation in the\n range starting from the pointer address devPtr, with the size of count bytes.\n The memory range must refer to managed memory allocated via the API hipMallocManaged, and the\n range will be handled with proper round down and round up respectively in the driver to\n be aligned to CPU page size, the same way as corresponding CUDA API behaves in CUDA version 8.0\n and afterwards.\n\n @note  This API is implemented on Linux and is under development on Windows."]
    pub fn hipMemAdvise(
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
        advice: hipMemoryAdvise,
        device: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query an attribute of a given memory range in HIP.\n\n @param [in,out] data   a pointer to a memory location where the result of each\n                        attribute query will be written to\n @param [in] data_size  the size of data\n @param [in] attribute  the attribute to query\n @param [in] dev_ptr    start of the range to query\n @param [in] count      size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
        attribute: hipMemRangeAttribute,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query attributes of a given memory range in HIP.\n\n @param [in,out] data     a two-dimensional array containing pointers to memory locations\n                          where the result of each attribute query will be written to\n @param [in] data_sizes   an array, containing the sizes of each result\n @param [in] attributes   the attribute to query\n @param [in] num_attributes  an array of attributes to query (numAttributes and the number\n                          of attributes in this array should match)\n @param [in] dev_ptr      start of the range to query\n @param [in] count        size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        data_sizes: *mut usize,
        attributes: *mut hipMemRangeAttribute,
        num_attributes: usize,
        dev_ptr: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Attach memory to a stream asynchronously in HIP.\n\n @param [in] stream     - stream in which to enqueue the attach operation\n @param [in] dev_ptr    - pointer to memory (must be a pointer to managed memory or\n                          to a valid host-accessible region of system-allocated memory)\n @param [in] length     - length of memory (defaults to zero)\n @param [in] flags      - must be one of hipMemAttachGlobal, hipMemAttachHost or\n                          hipMemAttachSingle (defaults to hipMemAttachSingle)\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipStreamAttachMemAsync(
        stream: hipStream_t,
        dev_ptr: *mut ::std::os::raw::c_void,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocates memory with stream ordered semantics\n\n Inserts a memory allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the allocation operation completes.\n The allocation comes from the memory pool associated with the stream's device.\n\n @note The default memory pool of a device contains device memory from that device.\n @note Basic stream ordering allows future work submitted into the same stream to use the\n  allocation. Stream query, stream synchronize, and HIP events can be used to guarantee that\n  the allocation operation completes before work submitted in a separate stream runs.\n @note During stream capture, this function results in the creation of an allocation node.\n  In this case, the allocation is owned by the graph instead of the memory pool. The memory\n  pool's properties are used to set the node's creation parameters.\n\n @param [out] dev_ptr  Returned device pointer of memory allocation\n @param [in] size      Number of bytes to allocate\n @param [in] stream    The stream establishing the stream ordering contract and\n                       the memory pool to allocate from\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocFromPoolAsync, hipFreeAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMallocAsync(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Frees memory with stream ordered semantics\n\n Inserts a free operation into @p stream.\n The allocation must not be used after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n @note During stream capture, this function results in the creation of a free node and\n must therefore be passed the address of a graph allocation.\n\n @param [in] dev_ptr Pointer to device memory to free\n @param [in] stream  The stream, where the destruciton will occur according to the execution order\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipFreeAsync(dev_ptr: *mut ::std::os::raw::c_void, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Releases freed memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than @p min_bytes_to_keep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n @note: Allocations that have not been freed count as outstanding.\n @note: Allocations that have been asynchronously freed but whose completion has\n not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n @param[in] mem_pool          The memory pool to trim allocations\n @param[in] min_bytes_to_hold If the pool has less than min_bytes_to_hold reserved,\n then the TrimTo operation is a no-op.  Otherwise the memory pool will contain\n at least min_bytes_to_hold bytes reserved after the operation.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolTrimTo(mem_pool: hipMemPool_t, min_bytes_to_hold: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to modify\n @param [in] attr     The attribute to modify\n @param [in] value    Pointer to the value to assign\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolSetAttribute(
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to get attributes of\n @param [in] attr     The attribute to get\n @param [in] value    Retrieved value\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolGetAttribute(
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Controls visibility of the specified pool between devices\n\n @param [in] mem_pool   Memory pool for acccess change\n @param [in] desc_list  Array of access descriptors. Each descriptor instructs the access to enable for a single gpu\n @param [in] count  Number of descriptors in the map array.\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolSetAccess(
        mem_pool: hipMemPool_t,
        desc_list: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n @param [out] flags    Accessibility of the memory pool from the specified location/device\n @param [in] mem_pool   Memory pool being queried\n @param [in] location  Location/device for memory pool access\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolGetAccess(
        flags: *mut hipMemAccessFlags,
        mem_pool: hipMemPool_t,
        location: *mut hipMemLocation,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memory pool\n\n Creates a HIP memory pool and returns the handle in @p mem_pool. The @p pool_props determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n By default, the memory pool will be accessible from the device it is allocated on.\n\n @param [out] mem_pool    Contains createed memory pool\n @param [in] pool_props   Memory pool properties\n\n @note Specifying hipMemHandleTypeNone creates a memory pool that will not support IPC.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolDestroy,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolCreate(
        mem_pool: *mut hipMemPool_t,
        pool_props: *const hipMemPoolProps,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when @p hipMemPoolDestroy is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n @param [in] mem_pool Memory pool for destruction\n\n @note A device's default memory pool cannot be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolDestroy(mem_pool: hipMemPool_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in @p dev_ptr.\n The allocation must not be accessed until the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n @note The specified memory pool may be from a device different than that of the specified @p stream.\n\n Basic stream ordering allows future work submitted into the same stream to use the allocation.\n Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation\n operation completes before work submitted in a separate stream runs.\n\n @note During stream capture, this function results in the creation of an allocation node. In this case,\n the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n are used to set the node's creation parameters.\n\n @param [out] dev_ptr Returned device pointer\n @param [in] size     Number of bytes to allocate\n @param [in] mem_pool The pool to allocate from\n @param [in] stream   The stream establishing the stream ordering semantic\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess,\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMallocFromPoolAsync(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        mem_pool: hipMemPool_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with @p hipMemPoolImportFromShareableHandle.\n Individual pointers can then be shared with the @p hipMemPoolExportPointer and @p hipMemPoolImportPointer APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n @note: To create an IPC capable mempool, create a mempool with a @p hipMemAllocationHandleType other\n than @p hipMemHandleTypeNone.\n\n @param [out] shared_handle Pointer to the location in which to store the requested handle\n @param [in] mem_pool       Pool to export\n @param [in] handle_type    The type of handle to create\n @param [in] flags          Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportFromShareableHandle\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolExportToShareableHandle(
        shared_handle: *mut ::std::os::raw::c_void,
        mem_pool: hipMemPool_t,
        handle_type: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with @p hipMemPoolImportPointer.\n\n @note Imported memory pools do not support creating new allocations.\n As such imported memory pools may not be used in @p hipDeviceSetMemPool\n or @p hipMallocFromPoolAsync calls.\n\n @param [out] mem_pool     Returned memory pool\n @param [in] shared_handle OS handle of the pool to open\n @param [in] handle_type   The type of handle being imported\n @param [in] flags         Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolExportToShareableHandle\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolImportFromShareableHandle(
        mem_pool: *mut hipMemPool_t,
        shared_handle: *mut ::std::os::raw::c_void,
        handle_type: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Export data to share a memory pool allocation between processes.\n\n Constructs @p export_data for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the @p hipMemPoolImportPointer api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n @param[out] export_data  Returned export data\n @param[in] dev_ptr       Pointer to memory being exported\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportPointer\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolExportPointer(
        export_data: *mut hipMemPoolPtrExportData,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Import a memory pool allocation from another process.\n\n Returns in @p dev_ptr a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with @p hipFree\n or @p hipFreeAsync. If @p hipFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n @note The @p hipFreeAsync api may be used in the exporting process before\n the @p hipFreeAsync operation completes in its stream as long as the\n @p hipFreeAsync in the exporting process specifies a stream with\n a stream dependency on the importing process's @p hipFreeAsync.\n\n @param [out] dev_ptr     Pointer to imported memory\n @param [in] mem_pool     Memory pool from which to import a pointer\n @param [in] export_data  Data specifying the memory to import\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized, #hipErrorOutOfMemory\n\n @see hipMemPoolExportPointer\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemPoolImportPointer(
        dev_ptr: *mut *mut ::std::os::raw::c_void,
        mem_pool: hipMemPool_t,
        export_data: *mut hipMemPoolPtrExportData,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size in bytes\n  @param[in]  flags Type of host memory allocation see below\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  Flags:\n  - #hipHostAllocDefault   Default pinned memory allocation on the host.\n  - #hipHostAllocPortable  Memory is considered allocated by all contexts.\n  - #hipHostAllocMapped    Map the allocation into the address space for the current device.\n  - #hipHostAllocWriteCombined  Allocates the memory as write-combined.\n\n  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue"]
    pub fn hipHostAlloc(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc\n\n  @param[out] devPtr Device Pointer mapped to passed host pointer\n  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc\n  @param[in]  flags Flags to be passed for extension\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostMalloc"]
    pub fn hipHostGetDevicePointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        hstPtr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Return flags associated with host pointer\n\n  @param[out] flagsPtr Memory location to store flags\n  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc\n  @returns #hipSuccess, #hipErrorInvalidValue\n\n  @see hipHostMalloc"]
    pub fn hipHostGetFlags(
        flagsPtr: *mut ::std::os::raw::c_uint,
        hostPtr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Register host memory so it can be accessed from the current device.\n\n  @param[out] hostPtr Pointer to host memory to be registered.\n  @param[in] sizeBytes Size of the host memory\n  @param[in] flags  See below.\n\n  Flags:\n  - #hipHostRegisterDefault   Memory is Mapped and Portable\n  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports\n one context so this is always assumed true.\n  - #hipHostRegisterMapped    Map the allocation into the address space for the current device.\n The device pointer can be obtained with #hipHostGetDevicePointer.\n\n\n  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer.\n  On many systems, the mapped device pointer will have a different value than the mapped host\n pointer.  Applications must use the device pointer in device code, and the host pointer in host\n code.\n\n  On some systems, registered memory is pinned.  On some systems, registered memory may not be\n actually be pinned but uses OS or hardware facilities to all GPU access to the host memory.\n\n  Developers are strongly encouraged to register memory blocks which are aligned to the host\n cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction).\n\n  If registering non-aligned pointers, the application must take care when register pointers from\n the same cache line on different devices.  HIP's coarse-grained synchronization model does not\n guarantee correct results if different devices write to different parts of the same cache block -\n typically one of the writes will \"win\" and overwrite data from the other registered memory\n region.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub fn hipHostRegister(
        hostPtr: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Un-register host pointer\n\n  @param[in] hostPtr Host pointer previously registered with #hipHostRegister\n  @returns Error code\n\n  @see hipHostRegister"]
    pub fn hipHostUnregister(hostPtr: *mut ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] ptr Pointer to the allocated device memory\n  @param[out] pitch Pitch for allocation (in bytes)\n  @param[in]  width Requested pitched allocation width (in bytes)\n  @param[in]  height Requested pitched allocation height\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMallocPitch(
        ptr: *mut *mut ::std::os::raw::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] dptr  Pointer to the allocated device memory\n  @param[out] pitch  Pitch for allocation (in bytes)\n  @param[in]  widthInBytes  Requested pitched allocation width (in bytes)\n  @param[in]  height  Requested pitched allocation height\n  @param[in]  elementSizeBytes  The size of element bytes, should be 4, 8 or 16\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array.\n  Given the row and column of an array element of type T, the address is computed as:\n  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;\n\n  @returns Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMemAllocPitch(
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API.\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @returns #hipSuccess\n  @returns #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated\n with hipHostMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipFree(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Frees page-locked memory\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @returns #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated\n  with hipMalloc)\n"]
    pub fn hipFreeHost(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @ingroup MemoryD\n\n  @param[in] ptr Pointer to memory to be freed\n  @returns #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with\n hipMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipHostFree(ptr: *mut ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from src to dst.\n\n  It supports memory from host to device,\n  device to host, device to device and host to host\n  The src and dst must not overlap.\n\n  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice).\n  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the\n  device where the src data is physically located. For optimal peer-to-peer copies, the copy device\n  must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy\n  agent as the current device and src/dest as the peerDevice argument.  if this is not done, the\n  hipMemcpy will still work, but will perform the copy using a staging buffer on the host.\n  Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in\n  undefined behavior.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  kind Kind of transfer\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Memory copy on the stream.\n  It allows single or multiple devices to do memory copy on single or multiple streams.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  kind Kind of transfer\n  @param[in]  stream Valid stream\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorContextIsDestroyed\n\n  @see hipMemcpy, hipStreamCreate, hipStreamSynchronize, hipStreamDestroy, hipSetDevice, hipLaunchKernelGGL\n"]
    pub fn hipMemcpyWithStream(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from Host to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoD(
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from Device to Host\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoH(
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from Device to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoD(dst: hipDeviceptr_t, src: hipDeviceptr_t, sizeBytes: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies from one 1D array to device memory.\n\n  @param[out]  dstDevice Destination device pointer\n  @param[in]   srcArray Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   ByteCount Size of memory copy in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyAtoD(
        dstDevice: hipDeviceptr_t,
        srcArray: hipArray_t,
        srcOffset: usize,
        ByteCount: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies from device memory to a 1D array.\n\n  @param[out]  dstArray Destination array\n  @param[in]   dstOffset Offset in bytes of destination array\n  @param[in]   srcDevice Source device pointer\n  @param[in]   ByteCount Size of memory copy in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcDevice: hipDeviceptr_t,
        ByteCount: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies from one 1D array to another.\n\n  @param[out]  dstArray Destination array\n  @param[in]   dstOffset Offset in bytes of destination array\n  @param[in]   srcArray Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   ByteCount Size of memory copy in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyAtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcArray: hipArray_t,
        srcOffset: usize,
        ByteCount: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from Host to Device asynchronously\n\n  @param[out]  dst  Data being copy to\n  @param[in]   src  Data being copy from\n  @param[in]   sizeBytes  Data size in bytes\n  @param[in]   stream  Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoDAsync(
        dst: hipDeviceptr_t,
        src: *mut ::std::os::raw::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from Device to Host asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n  @param[in]   stream  Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoHAsync(
        dst: *mut ::std::os::raw::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from Device to Device asynchronously\n\n  @param[out]  dst  Data being copy to\n  @param[in]   src  Data being copy from\n  @param[in]   sizeBytes  Data size in bytes\n  @param[in]   stream  Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoDAsync(
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Copies from one 1D array to host memory.\n\n  @param[out]  dstHost Destination pointer\n  @param[in]   srcArray Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   ByteCount Size of memory copy in bytes\n  @param[in]   stream Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyAtoHAsync(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: hipArray_t,
        srcOffset: usize,
        ByteCount: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Copies from host memory to a 1D array.\n\n  @param[out]  dstArray Destination array\n  @param[in]   dstOffset Offset in bytes of destination array\n  @param[in]   srcHost Source host pointer\n  @param[in]   ByteCount Size of memory copy in bytes\n  @param[in]   stream Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoAAsync(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Returns a global pointer from a module.\n  Returns in *dptr and *bytes the pointer and size of the global of name name located in module hmod.\n  If no variable of that name exists, it returns hipErrorNotFound. Both parameters dptr and bytes are optional.\n  If one of them is NULL, it is ignored and hipSuccess is returned.\n\n  @param[out]  dptr  Returns global device pointer\n  @param[out]  bytes Returns global size in bytes\n  @param[in]   hmod  Module to retrieve global from\n  @param[in]   name  Name of global to retrieve\n\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotFound, #hipErrorInvalidContext\n"]
    pub fn hipModuleGetGlobal(
        dptr: *mut hipDeviceptr_t,
        bytes: *mut usize,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Gets device pointer associated with symbol on the device.\n\n  @param[out]  devPtr  pointer to the device associated the symbole\n  @param[in]   symbol  pointer to the symbole of the device\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetSymbolAddress(
        devPtr: *mut *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Gets the size of the given symbol on the device.\n\n  @param[in]   symbol  pointer to the device symbole\n  @param[out]  size  pointer to the size\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetSymbolSize(size: *mut usize, symbol: *const ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the pointer of requested HIP driver function.\n\n @param[in] symbol  The Symbol name of the driver function to request.\n @param[out] pfn  Output pointer to the requested driver function.\n @param[in] hipVersion  The HIP version for the requested driver function symbol.\n HIP version is defined as 100*version_major + version_minor. For example, in HIP 6.1, the\n hipversion is 601, for the symbol function \"hipGetDeviceProperties\", the specified hipVersion 601\n is greater or equal to the version 600, the symbol function will be handle properly as backend\n compatible function.\n\n @param[in] flags  Currently only default flag is suppported.\n @param[out] symbolStatus  Optional enumeration for returned status of searching for symbol driver\n function based on the input hipVersion.\n\n Returns hipSuccess if the returned pfn is addressed to the pointer of found driver function.\n\n @return #hipSuccess, #hipErrorInvalidValue."]
    pub fn hipGetProcAddress(
        symbol: *const ::std::os::raw::c_char,
        pfn: *mut *mut ::std::os::raw::c_void,
        hipVersion: ::std::os::raw::c_int,
        flags: u64,
        symbolStatus: *mut hipDriverProcAddressQueryResult,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data to the given symbol on the device.\n Symbol HIP APIs allow a kernel to define a device-side data symbol which can be accessed on\n the host side. The symbol can be in __constant or device space.\n Note that the symbol name needs to be encased in the HIP_SYMBOL macro.\n This also applies to hipMemcpyFromSymbol, hipGetSymbolAddress, and hipGetSymbolSize.\n For detailed usage, see the\n <a href=\"https://rocm.docs.amd.com/projects/HIP/en/latest/how-to/hip_porting_guide.html#memcpytosymbol\">memcpyToSymbol example</a>\n in the HIP Porting Guide.\n\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyToSymbol(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data to the given symbol on the device asynchronously.\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyToSymbolAsync(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data from the given symbol on the device.\n\n  @param[out]  dst  Returns pointer to destinition memory address\n  @param[in]   symbol  Pointer to the symbole address on the device\n  @param[in]   sizeBytes  Size in bytes to copy\n  @param[in]   offset  Offset in bytes from the start of symbole\n  @param[in]   kind  Type of memory transfer\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyFromSymbol(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data from the given symbol on the device asynchronously.\n\n  @param[out]  dst  Returns pointer to destinition memory address\n  @param[in]   symbol  pointer to the symbole address on the device\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from the start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyFromSymbolAsync(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copy data from src to dst asynchronously.\n\n  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For\n best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously.\n\n  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies.\n  For hipMemcpy, the copy is always performed by the device associated with the specified stream.\n\n  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a\n attached to the device where the src data is physically located. For optimal peer-to-peer copies,\n the copy device must be able to access the src and dst pointers (by calling\n hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice\n argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a\n staging buffer on the host.\n\n  @param[out] dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  kind  Type of memory transfer\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,\n hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,\n hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,\n hipMemcpyFromSymbolAsync"]
    pub fn hipMemcpyAsync(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dst  Data being filled\n  @param[in]  value  Value to be set\n  @param[in]  sizeBytes  Data size in bytes\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemset(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Value to be set\n  @param[in]  count  Number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8Async(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16Async(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer\n value for specified number of times.\n\n  @param[out] dest  Data being filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD32(
        dest: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant\n byte value value.\n\n hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  sizeBytes  Size in bytes to set\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemsetAsync(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer\n value for specified number of times.\n\n  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  count  Number of values to be set\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemsetD32Async(
        dst: hipDeviceptr_t,
        value: ::std::os::raw::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  pitch  Data size in bytes\n  @param[in]  value  Constant value to be set\n  @param[in]  width\n  @param[in]  height\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset2D(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value.\n\n  @param[in]  dst Pointer to 2D device memory\n  @param[in]  pitch  Pitch size in bytes\n  @param[in]  value  Value to be set for each byte of specified memory\n  @param[in]  width  Width of matrix set columns in bytes\n  @param[in]  height  Height of matrix set rows in bytes\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset2DAsync(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr  Pointer to pitched device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  extent  Size parameters for width field in bytes in device memory\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset3D(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr  Pointer to pitched device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  extent  Size parameters for width field in bytes in device memory\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset3DAsync(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query memory info.\n\n On ROCM, this function gets the actual free memory left on the current device, so supports\n the cases while running multi-workload (such as multiple processes, multiple threads, and\n multiple GPUs).\n\n @warning On Windows, the free memory only accounts for memory allocated by this process and may\n be optimistic.\n\n @param[out] free Returns free memory on the current device in bytes\n @param[out] total Returns total allocatable memory on the current device in bytes\n\n @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n"]
    pub fn hipMemGetInfo(free: *mut usize, total: *mut usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get allocated memory size via memory pointer.\n\n This function gets the allocated shared virtual memory size from memory pointer.\n\n @param[in] ptr Pointer to allocated memory\n @param[out] size Returns the allocated memory size in bytes\n\n @return #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemPtrGetInfo(ptr: *mut ::std::os::raw::c_void, size: *mut usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   width  Requested array allocation width\n  @param[in]   height Requested array allocation height\n  @param[in]   flags  Requested properties of allocated array\n  @return      #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMallocArray(
        array: *mut hipArray_t,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Create an array memory pointer on the device.\n\n  @param[out]  pHandle  Pointer to the array memory\n  @param[in]   pAllocateArray   Requested array desciptor\n\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocArray, hipArrayDestroy, hipFreeArray"]
    pub fn hipArrayCreate(
        pHandle: *mut hipArray_t,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Destroy an array memory pointer on the device.\n\n  @param[in]  array  Pointer to the array memory\n\n  @return      #hipSuccess, #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipFreeArray"]
    pub fn hipArrayDestroy(array: hipArray_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Create a 3D array memory pointer on the device.\n\n  @param[out]  array  Pointer to the 3D array memory\n  @param[in]   pAllocateArray   Requested array desciptor\n\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocArray, hipArrayDestroy, hipFreeArray"]
    pub fn hipArray3DCreate(
        array: *mut hipArray_t,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Create a 3D memory pointer on the device.\n\n  @param[out]  pitchedDevPtr  Pointer to the 3D memory\n  @param[in]   extent   Requested extent\n\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocPitch, hipMemGetInfo, hipFree"]
    pub fn hipMalloc3D(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Frees an array on the device.\n\n  @param[in]  array  Pointer to array to free\n  @return     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub fn hipFreeArray(array: hipArray_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   extent Requested array allocation width, height and depth\n  @param[in]   flags  Requested properties of allocated array\n  @return      #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMalloc3DArray(
        array: *mut hipArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets info about the specified array\n\n @param[out] desc   - Returned array type\n @param[out] extent - Returned array shape. 2D arrays will have depth of zero\n @param[out] flags  - Returned array flags\n @param[in]  array  - The HIP array to get info for\n\n @return #hipSuccess, #hipErrorInvalidValue #hipErrorInvalidHandle\n\n @see hipArrayGetDescriptor, hipArray3DGetDescriptor"]
    pub fn hipArrayGetInfo(
        desc: *mut hipChannelFormatDesc,
        extent: *mut hipExtent,
        flags: *mut ::std::os::raw::c_uint,
        array: hipArray_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a 1D or 2D array descriptor\n\n @param[out] pArrayDescriptor - Returned array descriptor\n @param[in]  array            - Array to get descriptor of\n\n @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue #hipErrorInvalidHandle\n\n @see hipArray3DCreate, hipArray3DGetDescriptor, hipArrayCreate, hipArrayDestroy, hipMemAlloc,\n hipMemAllocHost, hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned,\n hipMemcpy3D, hipMemcpy3DAsync, hipMemcpyAtoA, hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync,\n hipMemcpyDtoA, hipMemcpyDtoD, hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync,\n hipMemcpyHtoA, hipMemcpyHtoAAsync, hipMemcpyHtoD, hipMemcpyHtoDAsync, hipMemFree,\n hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo, hipMemHostAlloc,\n hipMemHostGetDevicePointer, hipMemsetD8, hipMemsetD16, hipMemsetD32, hipArrayGetInfo"]
    pub fn hipArrayGetDescriptor(
        pArrayDescriptor: *mut HIP_ARRAY_DESCRIPTOR,
        array: hipArray_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a 3D array descriptor\n\n @param[out] pArrayDescriptor - Returned 3D array descriptor\n @param[in]  array            - 3D array to get descriptor of\n\n @return #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue #hipErrorInvalidHandle, #hipErrorContextIsDestroyed\n\n @see hipArray3DCreate, hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc,\n hipMemAllocHost, hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned,\n hipMemcpy3D, hipMemcpy3DAsync, hipMemcpyAtoA, hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync,\n hipMemcpyDtoA, hipMemcpyDtoD, hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync,\n hipMemcpyHtoA, hipMemcpyHtoAAsync, hipMemcpyHtoD, hipMemcpyHtoDAsync, hipMemFree,\n hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo, hipMemHostAlloc,\n hipMemHostGetDevicePointer, hipMemsetD8, hipMemsetD16, hipMemsetD32, hipArrayGetInfo"]
    pub fn hipArray3DGetDescriptor(
        pArrayDescriptor: *mut HIP_ARRAY3D_DESCRIPTOR,
        array: hipArray_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2D(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2D(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @param[in]   stream Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2DAsync(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @param[in]   stream Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DToArray(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DToArrayAsync(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst Destination memory address\n  @param[in]   wOffsetDst Destination starting X offset\n  @param[in]   hOffsetDst Destination starting Y offset\n  @param[in]   src  Source memory address\n  @param[in]   wOffsetSrc Source starting X offset\n  @param[in]   hOffsetSrc Source starting Y offset (columns in bytes)\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind Type of transfer\n\n  @returns      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DArrayToArray(
        dst: hipArray_t,
        wOffsetDst: usize,
        hOffsetDst: usize,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device [Deprecated]\n\n  @ingroup MemoryD\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   count   size in bytes to copy\n  @param[in]   kind    Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n  hipMemcpyAsync\n  @warning  This API is deprecated."]
    pub fn hipMemcpyToArray(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device [Deprecated]\n\n  @ingroup MemoryD\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   count     Size in bytes to copy\n  @param[in]   kind      Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync\n @warning  This API is deprecated."]
    pub fn hipMemcpyFromArray(
        dst: *mut ::std::os::raw::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArray(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   count     Size of memory copy in bytes\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpyAtoH(
        dst: *mut ::std::os::raw::c_void,
        srcArray: hipArray_t,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dstArray   Destination memory address\n  @param[in]   dstOffset  Offset in bytes of destination array\n  @param[in]   srcHost    Source host pointer\n  @param[in]   count      Size of memory copy in bytes\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpyHtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   p   3D memory copy parameters\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy3D(p: *const hipMemcpy3DParms) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   p        3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy3DAsync(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   pCopy   3D memory copy parameters\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipDrvMemcpy3D(pCopy: *const HIP_MEMCPY3D) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   pCopy    3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipDrvMemcpy3DAsync(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup PeerToPeer PeerToPeer Device Memory Access\n  @{\n  @warning PeerToPeer support is experimental.\n  This section describes the PeerToPeer device memory access functions of HIP runtime API.\n/\n/**\n @brief Determine if a device can access a peer's memory.\n\n @param [out] canAccessPeer Returns the peer access capability (0 or 1)\n @param [in] deviceId - device from where memory may be accessed.\n @param [in] peerDeviceId - device where memory is physically located\n\n Returns \"1\" in @p canAccessPeer if the specified @p device is capable\n of directly accessing memory physically located on peerDevice , or \"0\" if not.\n\n Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a\n device is not a peer of itself.\n\n @returns #hipSuccess,\n @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub fn hipDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        deviceId: ::std::os::raw::c_int,
        peerDeviceId: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerDeviceId  Peer device to enable direct access to from the current device\n @param [in] flags  Reserved for future use, must be zero\n\n Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub fn hipDeviceEnablePeerAccess(
        peerDeviceId: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerDeviceId  Peer device to disable direct access to\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub fn hipDeviceDisablePeerAccess(peerDeviceId: ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get information on memory allocations.\n\n @param [out] pbase - BAse pointer address\n @param [out] psize - Size of allocation\n @param [in]  dptr- Device Pointer\n\n @returns #hipSuccess, #hipErrorNotFound\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipMemGetAddressRange(
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDeviceId - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeer(
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDeviceId: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDevice - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n @param [in] stream - Stream identifier\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeerAsync(
        dst: *mut ::std::os::raw::c_void,
        dstDeviceId: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create a context and set it as current/default context\n\n @param [out] ctx  Context to create\n @param [in] flags  Context creation flags\n @param [in] device  device handle\n\n @return #hipSuccess\n\n @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,\n hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform.\n"]
    pub fn hipCtxCreate(
        ctx: *mut hipCtx_t,
        flags: ::std::os::raw::c_uint,
        device: hipDevice_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a HIP context [Deprecated]\n\n @param [in] ctx Context to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxDestroy(ctx: hipCtx_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Pop the current/default context and return the popped context [Deprecated]\n\n @param [out] ctx  The current context to pop\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxPopCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Push the context to be set as current/ default context [Deprecated]\n\n @param [in] ctx  The current context to push\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxPushCurrent(ctx: hipCtx_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the passed context as current/default [Deprecated]\n\n @param [in] ctx The context to set as current\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSetCurrent(ctx: hipCtx_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the handle of the current/ default context [Deprecated]\n\n @param [out] ctx  The context to get as current\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the handle of the device associated with current/default context [Deprecated]\n\n @param [out] device The device from the current context\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetDevice(device: *mut hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the approximate HIP api version.\n\n @param [in]  ctx Context to check [Deprecated]\n @param [out] apiVersion API version to get\n\n @return #hipSuccess\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK api revision.\n This function always set *apiVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the api revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetApiVersion(ctx: hipCtx_t, apiVersion: *mut ::std::os::raw::c_int)
        -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get Cache configuration for a specific function [Deprecated]\n\n @param [out] cacheConfig  Cache configuration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set L1/Shared cache partition [Deprecated]\n\n @param [in] cacheConfig  Cache configuration to set\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set Shared memory bank configuration  [Deprecated]\n\n @param [in] config  Shared memory configuration to set\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get Shared memory bank configuration [Deprecated]\n\n @param [out] pConfig  Pointer of shared memory configuration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks [Deprecated]\n\n @return #hipSuccess\n\n @warning This function waits for all streams on the default context to complete execution, and\n then returns.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSynchronize() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return flags used for creating default context [Deprecated]\n\n @param [out] flags  Pointer of flags\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enables direct access to memory allocations in a peer context [Deprecated]\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerCtx  Peer context\n @param [in] flags  flags, need to set as 0\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n #hipErrorPeerAccessAlreadyEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental.\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxEnablePeerAccess(peerCtx: hipCtx_t, flags: ::std::os::raw::c_uint) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations\n physically located on a peer context.Disables direct access to memory allocations in a peer\n context and unregisters any registered allocations [Deprecated]\n\n Returns #hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerCtx  Peer context to be disabled\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental.\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxDisablePeerAccess(peerCtx: hipCtx_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the state of the primary context [Deprecated]\n\n @param [in] dev  Device to get primary context flags for\n @param [out] flags  Pointer to store flags\n @param [out] active  Pointer to store context state; 0 = inactive, 1 = active\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the\n NVIDIA platform."]
    pub fn hipDevicePrimaryCtxGetState(
        dev: hipDevice_t,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Release the primary context on the GPU.\n\n @param [in] dev  Device which primary context is released [Deprecated]\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning This function return #hipSuccess though doesn't release the primaryCtx by design on\n HIP/HCC path.\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxRelease(dev: hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Retain the primary context on the GPU [Deprecated]\n\n @param [out] pctx  Returned context handle of the new context\n @param [in] dev  Device which primary context is released\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxRetain(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Resets the primary context on the GPU [Deprecated]\n\n @param [in] dev  Device which primary context is reset\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxReset(dev: hipDevice_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set flags for the primary context [Deprecated]\n\n @param [in] dev  Device for which the primary context flags are set\n @param [in] flags  New flags for the device\n\n @returns #hipSuccess, #hipErrorContextAlreadyInUse\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxSetFlags(
        dev: hipDevice_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n\n  @defgroup Module Module Management\n  @{\n  @ingroup API\n  This section describes the module management functions of HIP runtime API.\n\n/\n/**\n @brief Loads code object from file into a module the currrent context.\n\n @param [in] fname  Filename of code object to load\n\n @param [out] module  Module\n\n @warning File/memory resources allocated in this function are released only in hipModuleUnload.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext, #hipErrorFileNotFound,\n #hipErrorOutOfMemory, #hipErrorSharedObjectInitFailed, #hipErrorNotInitialized\n"]
    pub fn hipModuleLoad(
        module: *mut hipModule_t,
        fname: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Frees the module\n\n @param [in] module  Module to free\n\n @returns #hipSuccess, #hipErrorInvalidResourceHandle\n\n The module is freed, and the code objects associated with it are destroyed."]
    pub fn hipModuleUnload(module: hipModule_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Function with kname will be extracted if present in module\n\n @param [in] module  Module to get function from\n @param [in] kname  Pointer to the name of function\n @param [out] function  Pointer to function handle\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext, #hipErrorNotInitialized,\n #hipErrorNotFound,"]
    pub fn hipModuleGetFunction(
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Find out attributes for a given function.\n\n @param [out] attr  Attributes of funtion\n @param [in] func  Pointer to the function handle\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttributes(
        attr: *mut hipFuncAttributes,
        func: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Find out a specific attribute for a given function.\n\n @param [out] value  Pointer to the value\n @param [in]  attrib  Attributes of the given funtion\n @param [in]  hfunc  Function to get attributes from\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets pointer to device entry function that matches entry function symbolPtr.\n\n @param [out] functionPtr  Device entry function\n @param [in]  symbolPtr  Pointer to device entry function to search for\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction\n"]
    pub fn hipGetFuncBySymbol(
        functionPtr: *mut hipFunction_t,
        symbolPtr: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief returns the handle of the texture reference with the name from the module.\n\n @param [in] hmod  Module\n @param [in] name  Pointer of name of texture reference\n @param [out] texRef  Pointer of texture reference\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorNotFound, #hipErrorInvalidValue"]
    pub fn hipModuleGetTexRef(
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::std::os::raw::c_char,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location.\n\n @param [in] image  The pointer to the location of data\n @param [out] module  Retuned module\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadData(
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location. Options are not used. hipModuleLoadData is called.\n\n @param [in] image  The pointer to the location of data\n @param [out] module  Retuned module\n @param [in] numOptions Number of options\n @param [in] options Options for JIT\n @param [in] optionValues  Option values for JIT\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadDataEx(
        module: *mut hipModule_t,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra\n\n @param [in] f         Kernel to launch.\n @param [in] gridDimX  X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX X block dimensions specified in work-items\n @param [in] blockDimY Y grid dimension specified in work-items\n @param [in] blockDimZ Z grid dimension specified in work-items\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n @param [in] kernelParams  Kernel parameters to launch\n @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and\n must be in the memory layout and alignment expected by the kernel.\n All passed arguments must be naturally aligned according to their type. The memory address of each\n argument should be a multiple of its size in bytes. Please refer to hip_porting_driver_api.md\n for sample usage.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32. So gridDim.x * blockDim.x, gridDim.y * blockDim.y\n and gridDim.z * blockDim.z are always less than 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue"]
    pub fn hipModuleLaunchKernel(
        f: hipFunction_t,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelParams, where thread blocks can cooperate and synchronize as they execute\n\n @param [in] f              Kernel to launch.\n @param [in] gridDimX       X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY       Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ       Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX      X block dimension specified in work-items.\n @param [in] blockDimY      Y block dimension specified in work-items.\n @param [in] blockDimZ      Z block dimension specified in work-items.\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream         Stream where the kernel should be dispatched. May be 0,\n in which case the default stream is used with associated synchronization rules.\n @param [in] kernelParams   A list of kernel arguments.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidHandle, #hipErrorInvalidImage, #hipErrorInvalidValue,\n #hipErrorInvalidConfiguration, #hipErrorLaunchFailure, #hipErrorLaunchOutOfResources,\n #hipErrorLaunchTimeOut, #hipErrorCooperativeLaunchTooLarge, #hipErrorSharedObjectInitFailed"]
    pub fn hipModuleLaunchCooperativeKernel(
        f: hipFunction_t,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidHandle, #hipErrorInvalidImage, #hipErrorInvalidValue,\n #hipErrorInvalidConfiguration, #hipErrorInvalidResourceHandle, #hipErrorLaunchFailure,\n #hipErrorLaunchOutOfResources, #hipErrorLaunchTimeOut, #hipErrorCooperativeLaunchTooLarge,\n #hipErrorSharedObjectInitFailed"]
    pub fn hipModuleLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipFunctionLaunchParams,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute\n\n @param [in] f - Kernel to launch.\n @param [in] gridDim - Grid dimensions specified as multiple of blockDim.\n @param [in] blockDimX - Block dimensions specified in work-items\n @param [in] kernelParams - Pointer of arguments passed to the kernel. If the kernel has multiple\n parameters, 'kernelParams' should be array of pointers, each points the corresponding argument.\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernel(
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDimX: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n  #hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched\n on respective streams before enqueuing any other work on the specified streams from any other threads\n\n\n @param [in] launchParamsList          List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue"]
    pub fn hipExtLaunchMultiKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Occupancy Occupancy\n  @{\n  This section describes the occupancy functions of HIP runtime API.\n\n/\n/**\n @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function (hipFunction) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @returns  #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n @returns  #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        f: hipFunction_t,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @returns  #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (currently ignored)\n @returns  #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Start recording of profiling information [Deprecated]\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @returns  #hipErrorNotSupported\n @warning : hipProfilerStart API is deprecated, use roctracer/rocTX instead."]
    pub fn hipProfilerStart() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Stop recording of profiling information [Deprecated]\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @returns  #hipErrorNotSupported\n @warning  hipProfilerStart API is deprecated, use roctracer/rocTX instead."]
    pub fn hipProfilerStop() -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Clang Launch API to support the triple-chevron syntax\n  @{\n  This section describes the API to support the triple-chevron syntax.\n/\n/**\n @brief Configure a kernel launch.\n\n @param [in] gridDim   grid dimension specified as multiple of blockDim.\n @param [in] blockDim  block dimensions specified in work-items\n @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n"]
    pub fn hipConfigureCall(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set a kernel argument.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n\n @param [in] arg    Pointer the argument in host memory.\n @param [in] size   Size of the argument.\n @param [in] offset Offset of the argument on the argument stack.\n"]
    pub fn hipSetupArgument(
        arg: *const ::std::os::raw::c_void,
        size: usize,
        offset: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Launch a kernel.\n\n @param [in] func Kernel to launch.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n"]
    pub fn hipLaunchByPtr(func: *const ::std::os::raw::c_void) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Push configuration of a kernel launch.\n\n @param [in] gridDim   grid dimension specified as multiple of blockDim.\n @param [in] blockDim  block dimensions specified in work-items\n @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n"]
    pub fn __hipPushCallConfiguration(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Pop configuration of a kernel launch.\n\n @param [out] gridDim   grid dimension specified as multiple of blockDim.\n @param [out] blockDim  block dimensions specified in work-items\n @param [out] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [out] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n"]
    pub fn __hipPopCallConfiguration(
        gridDim: *mut dim3,
        blockDim: *mut dim3,
        sharedMem: *mut usize,
        stream: *mut hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief C compliant kernel launch API\n\n @param [in] function_address - Kernel stub function pointer.\n @param [in] numBlocks - Number of blocks.\n @param [in] dimBlocks - Dimension of a block\n @param [in] args - Pointer of arguments passed to the kernel. If the kernel has multiple\n parameters, 'args' should be array of pointers, each points the corresponding argument.\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th\n  default stream is used with associated synchronization rules.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipLaunchKernel(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enqueues a host function call in a stream.\n\n @param [in] stream - The stream to enqueue work in.\n @param [in] fn - The function to call once enqueued preceeding operations are complete.\n @param [in] userData - User-specified data to be passed to the function.\n\n @returns #hipSuccess, #hipErrorInvalidResourceHandle, #hipErrorInvalidValue,\n #hipErrorNotSupported\n\n The host function to call in this API will be executed after the preceding operations in\n the stream are complete. The function is a blocking operation that blocks operations in the\n stream that follow it, until the function is returned.\n Event synchronization and internal callback functions make sure enqueued operations will\n execute in order, in the stream.\n\n The host function must not make any HIP API calls. The host function is non-reentrant. It must\n not perform sychronization with any operation that may depend on other processing execution\n but is not enqueued to run earlier in the stream.\n\n Host functions that are enqueued respectively in different non-blocking streams can run concurrently.\n\n @warning  This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipLaunchHostFunc(
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " Copies memory for 2D arrays.\n\n @param pCopy           - Parameters for the memory copy\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDrvMemcpy2DUnaligned(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Launches kernel from the pointer address, with arguments and shared memory on stream.\n\n @param [in] function_address - Pointer to the Kernel to launch.\n @param [in] numBlocks -  Number of blocks.\n @param [in] dimBlocks - Dimension of a block.\n @param [in] args - Pointer of arguments passed to the kernel. If the kernel has multiple\n parameters, 'args' should be array of pointers, each points the corresponding argument.\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel.\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.\n May be 0, in which case the default stream is used with associated synchronization rules.\n @param [in] startEvent - If non-null, specified event will be updated to track the start time of\n the kernel launch. The event must be created before calling this API.\n @param [in] stopEvent - If non-null, specified event will be updated to track the stop time of\n the kernel launch. The event must be created before calling this API.\n @param [in] flags - The value of hipExtAnyOrderLaunch, signifies if kernel can be\n launched in any order.\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue.\n"]
    pub fn hipExtLaunchKernel(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
        startEvent: hipEvent_t,
        stopEvent: hipEvent_t,
        flags: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to the texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @note 3D liner filter isn't supported on GFX90A boards, on which the API @p hipCreateTextureObject will\n return hipErrorNotSupported.\n"]
    pub fn hipCreateTextureObject(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const hipResourceDesc,
        pTexDesc: *const hipTextureDesc,
        pResViewDesc: *const hipResourceViewDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a texture object.\n\n @param [in] textureObject  texture object to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipDestroyTextureObject(textureObject: hipTextureObject_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the channel descriptor in an array.\n\n @param [in] desc  pointer to channel format descriptor\n @param [out] array  memory array on the device\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetChannelDesc(
        desc: *mut hipChannelFormatDesc,
        array: hipArray_const_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets resource descriptor for the texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectResourceDesc(
        pResDesc: *mut hipResourceDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets resource view descriptor for the texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut hipResourceViewDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets texture descriptor for the texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectTextureDesc(
        pTexDesc: *mut hipTextureDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectCreate(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const HIP_RESOURCE_DESC,
        pTexDesc: *const HIP_TEXTURE_DESC,
        pResViewDesc: *const HIP_RESOURCE_VIEW_DESC,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a texture object.\n\n @param [in] texObject  texture object to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectDestroy(texObject: hipTextureObject_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets resource descriptor of a texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetResourceDesc(
        pResDesc: *mut HIP_RESOURCE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets resource view descriptor of a texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetResourceViewDesc(
        pResViewDesc: *mut HIP_RESOURCE_VIEW_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets texture descriptor of a texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetTextureDesc(
        pTexDesc: *mut HIP_TEXTURE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a mipmapped array on the device.\n\n @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory\n @param[in]  desc            - Requested channel format\n @param[in]  extent          - Requested allocation size (width field in elements)\n @param[in]  numLevels       - Number of mipmap levels to allocate\n @param[in]  flags           - Flags for extensions\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipMallocMipmappedArray(
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Frees a mipmapped array on the device.\n\n @param[in] mipmappedArray - Pointer to mipmapped array to free\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipFreeMipmappedArray(mipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array.\n\n @param[out] levelArray     - Returned mipmap level HIP array\n @param[in]  mipmappedArray - HIP mipmapped array\n @param[in]  level          - Mipmap level\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipGetMipmappedArrayLevel(
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create a mipmapped array.\n\n @param [out] pHandle  pointer to mipmapped array\n @param [in] pMipmappedArrayDesc  mipmapped array descriptor\n @param [in] numMipmapLevels  mipmap level\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux."]
    pub fn hipMipmappedArrayCreate(
        pHandle: *mut hipMipmappedArray_t,
        pMipmappedArrayDesc: *mut HIP_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a mipmapped array.\n\n @param [out] hMipmappedArray  pointer to mipmapped array to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipMipmappedArrayDestroy(hMipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get a mipmapped array on a mipmapped level.\n\n @param [in] pLevelArray Pointer of array\n @param [out] hMipMappedArray Pointer of mipmapped array on the requested mipmap level\n @param [out] level  Mipmap level\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Windows, under development on Linux.\n"]
    pub fn hipMipmappedArrayGetLevel(
        pLevelArray: *mut hipArray_t,
        hMipMappedArray: hipMipmappedArray_t,
        level: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief  Binds a mipmapped array to a texture [Deprecated]\n\n @param [in] tex  pointer to the texture reference to bind\n @param [in] mipmappedArray memory mipmapped array on the device\n @param [in] desc  opointer to the channel format\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipBindTextureToMipmappedArray(
        tex: *const textureReference,
        mipmappedArray: hipMipmappedArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the texture reference related with the symbol [Deprecated]\n\n @param [out] texref  texture reference\n @param [in] symbol  pointer to the symbol related with the texture for the reference\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipGetTextureReference(
        texref: *mut *const textureReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the border color used by a texture reference [Deprecated]\n\n @param [out] pBorderColor  Returned Type and Value of RGBA color.\n @param [in] texRef  Texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetBorderColor(
        pBorderColor: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the array bound to a texture reference [Deprecated]\n\n\n @param [in] pArray  Returned array.\n @param [in] texRef  texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetArray(
        pArray: *mut hipArray_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets address mode for a texture reference [Deprecated]\n\n @param [in] texRef  texture reference.\n @param [in] dim  Dimension of the texture.\n @param [in] am  Value of the texture address mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddressMode(
        texRef: *mut textureReference,
        dim: ::std::os::raw::c_int,
        am: hipTextureAddressMode,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Binds an array as a texture reference [Deprecated]\n\n @param [in] tex  Pointer texture reference.\n @param [in] array  Array to bind.\n @param [in] flags  Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetArray(
        tex: *mut textureReference,
        array: hipArray_const_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set filter mode for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer texture reference.\n @param [in] fm  Value of texture filter mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set flags for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer texture reference.\n @param [in] Flags  Value of flags.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFlags(
        texRef: *mut textureReference,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set format for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer texture reference.\n @param [in] fmt  Value of format.\n @param [in] NumPackedComponents  Number of components per array.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFormat(
        texRef: *mut textureReference,
        fmt: hipArray_Format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Binds a memory area to a texture [Deprecated]\n\n @param [in] offset  Offset in bytes.\n @param [in] tex  Texture to bind.\n @param [in] devPtr  Pointer of memory on the device.\n @param [in] desc  Pointer of channel format descriptor.\n @param [in] size  Size of memory in bites.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTexture(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        size: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Binds a 2D memory area to a texture [Deprecated]\n\n @param [in] offset  Offset in bytes.\n @param [in] tex  Texture to bind.\n @param [in] devPtr  Pointer of 2D memory area on the device.\n @param [in] desc  Pointer of channel format descriptor.\n @param [in] width  Width in texel units.\n @param [in] height  Height in texel units.\n @param [in] pitch  Pitch in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTexture2D(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        pitch: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Binds a memory area to a texture [Deprecated]\n\n @param [in] tex  Pointer of texture reference.\n @param [in] array  Array to bind.\n @param [in] desc  Pointer of channel format descriptor.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTextureToArray(
        tex: *const textureReference,
        array: hipArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the offset of the alignment in a texture [Deprecated]\n\n @param [in] offset  Offset in bytes.\n @param [in] texref  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipGetTextureAlignmentOffset(
        offset: *mut usize,
        texref: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Unbinds a texture [Deprecated]\n\n @param [in] tex  Texture to unbind.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipUnbindTexture(tex: *const textureReference) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the address for a texture reference [Deprecated]\n\n @param [out] dev_ptr  Pointer of device address.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetAddress(
        dev_ptr: *mut hipDeviceptr_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the address mode for a texture reference [Deprecated]\n\n @param [out] pam  Pointer of address mode.\n @param [in] texRef  Pointer of texture reference.\n @param [in] dim  Dimension.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetAddressMode(
        pam: *mut hipTextureAddressMode,
        texRef: *const textureReference,
        dim: ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets filter mode for a texture reference [Deprecated]\n\n @param [out] pfm  Pointer of filter mode.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets flags for a texture reference [Deprecated]\n\n @param [out] pFlags  Pointer of flags.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets texture format for a texture reference [Deprecated]\n\n @param [out] pFormat  Pointer of the format.\n @param [out] pNumChannels  Pointer of number of channels.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFormat(
        pFormat: *mut hipArray_Format,
        pNumChannels: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the maximum anisotropy for a texture reference [Deprecated]\n\n @param [out] pmaxAnsio  Pointer of the maximum anisotropy.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMaxAnisotropy(
        pmaxAnsio: *mut ::std::os::raw::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the mipmap filter mode for a texture reference [Deprecated]\n\n @param [out] pfm  Pointer of the mipmap filter mode.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the mipmap level bias for a texture reference [Deprecated]\n\n @param [out] pbias  Pointer of the mipmap level bias.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapLevelBias(
        pbias: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the minimum and maximum mipmap level clamps for a texture reference [Deprecated]\n\n @param [out] pminMipmapLevelClamp  Pointer of the minimum mipmap level clamp.\n @param [out] pmaxMipmapLevelClamp  Pointer of the maximum mipmap level clamp.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the mipmapped array bound to a texture reference [Deprecated]\n\n @param [out] pArray  Pointer of the mipmapped array.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipMappedArray(
        pArray: *mut hipMipmappedArray_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets an bound address for a texture reference [Deprecated]\n\n @param [out] ByteOffset  Pointer of the offset in bytes.\n @param [in] texRef  Pointer of texture reference.\n @param [in] dptr  Pointer of device address to bind.\n @param [in] bytes  Size in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddress(
        ByteOffset: *mut usize,
        texRef: *mut textureReference,
        dptr: hipDeviceptr_t,
        bytes: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set a bind an address as a 2D texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] desc  Pointer of array descriptor.\n @param [in] dptr  Pointer of device address to bind.\n @param [in] Pitch  Pitch in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddress2D(
        texRef: *mut textureReference,
        desc: *const HIP_ARRAY_DESCRIPTOR,
        dptr: hipDeviceptr_t,
        Pitch: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the maximum anisotropy for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [out] maxAniso  Value of the maximum anisotropy.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMaxAnisotropy(
        texRef: *mut textureReference,
        maxAniso: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets border color for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] pBorderColor  Pointer of border color.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetBorderColor(
        texRef: *mut textureReference,
        pBorderColor: *mut f32,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets mipmap filter mode for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] fm  Value of filter mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets mipmap level bias for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] bias  Value of mipmap bias.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapLevelBias(texRef: *mut textureReference, bias: f32) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets mipmap level clamp for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] minMipMapLevelClamp  Value of minimum mipmap level clamp.\n @param [in] maxMipMapLevelClamp  Value of maximum mipmap level clamp.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapLevelClamp(
        texRef: *mut textureReference,
        minMipMapLevelClamp: f32,
        maxMipMapLevelClamp: f32,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Binds mipmapped array to a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference to bind.\n @param [in] mipmappedArray  Pointer of mipmapped array to bind.\n @param [in] Flags  Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmappedArray(
        texRef: *mut textureReference,
        mipmappedArray: *mut hipMipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = "  @defgroup Callback Callback Activity APIs\n  @{\n  This section describes the callback/Activity of HIP runtime API.\n/\n/**\n @brief Returns HIP API name by ID.\n\n @param [in] id ID of HIP API\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipApiName(id: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Returns kernel name reference by function name.\n\n @param [in] f Name of function\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipKernelNameRef(f: hipFunction_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Retrives kernel for a given host pointer, unless stated otherwise.\n\n @param [in] hostFunction Pointer of host function.\n @param [in] stream Stream the kernel is executed on.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipKernelNameRefByPtr(
        hostFunction: *const ::std::os::raw::c_void,
        stream: hipStream_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Returns device ID on the stream.\n\n @param [in] stream Stream of device executed on.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetStreamDeviceId(stream: hipStream_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Begins graph capture on a stream.\n\n @param [in] stream - Stream to initiate capture.\n @param [in] mode - Controls the interaction of this capture sequence with other API calls that\n are not safe.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamBeginCapture(stream: hipStream_t, mode: hipStreamCaptureMode) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Begins graph capture on a stream to an existing graph.\n\n @param [in] stream - Stream to initiate capture.\n @param [in] graph - Graph to capture into.\n @param [in] dependencies - Dependencies of the first node captured in the stream. Can be NULL if\n numDependencies is 0.\n @param [in] dependencyData - Optional array of data associated with each dependency.\n @param [in] numDependencies - Number of dependencies.\n @param [in] mode - Controls the interaction of this capture sequence with other API calls that\nare not safe.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : param \"const hipGraphEdgeData* dependencyData\" is currently not supported and has to\npassed as nullptr. This API is marked as beta, meaning, while this is feature complete, it is still\nopen to changes and may have outstanding issues."]
    pub fn hipStreamBeginCaptureToGraph(
        stream: hipStream_t,
        graph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        dependencyData: *const hipGraphEdgeData,
        numDependencies: usize,
        mode: hipStreamCaptureMode,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Ends capture on a stream, returning the captured graph.\n\n @param [in] stream - Stream to end capture.\n @param [out] pGraph - returns the graph captured.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamEndCapture(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get capture status of a stream.\n\n @param [in] stream - Stream under capture.\n @param [out] pCaptureStatus - returns current status of the capture.\n @param [out] pId - unique ID of the capture.\n\n @returns #hipSuccess, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamGetCaptureInfo(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream under capture.\n @param [out] captureStatus_out - returns current status of the capture.\n @param [out] id_out - unique ID of the capture.\n @param [in] graph_out - returns the graph being captured into.\n @param [out] dependencies_out - returns pointer to an array of nodes.\n @param [out] numDependencies_out - returns size of the array returned in dependencies_out.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamGetCaptureInfo_v2(
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream under capture.\n @param [out] pCaptureStatus - returns current status of the capture.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamIsCapturing(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Update the set of dependencies in a capturing stream\n\n @param [in] stream  Stream under capture.\n @param [in] dependencies  pointer to an array of nodes to Add/Replace.\n @param [in] numDependencies  size of the array in dependencies.\n @param [in] flags  Flag how to update dependency set. Should be one of value in enum\n #hipStreamUpdateCaptureDependenciesFlags\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorIllegalState\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipStreamUpdateCaptureDependencies(
        stream: hipStream_t,
        dependencies: *mut hipGraphNode_t,
        numDependencies: usize,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Swaps the stream capture mode of a thread.\n\n @param [in] mode - Pointer to mode value to swap with the current mode\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipThreadExchangeStreamCaptureMode(mode: *mut hipStreamCaptureMode) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a graph\n\n @param [out] pGraph - pointer to graph to create.\n @param [in] flags - flags for graph creation, must be 0.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphCreate(pGraph: *mut hipGraph_t, flags: ::std::os::raw::c_uint) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a graph\n\n @param [in] graph - instance of graph to destroy.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphDestroy(graph: hipGraph_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Adds dependency edges to a graph.\n\n @param [in] graph - instance of the graph to add dependencies.\n @param [in] from - pointer to the graph nodes with dependenties to add from.\n @param [in] to - pointer to the graph nodes to add dependenties to.\n @param [in] numDependencies - the number of dependencies to add.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphAddDependencies(
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Removes dependency edges from a graph.\n\n @param [in] graph - instance of the graph to remove dependencies.\n @param [in] from - Array of nodes that provide the dependencies.\n @param [in] to - Array of dependent nodes.\n @param [in] numDependencies - the number of dependencies to remove.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphRemoveDependencies(
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a graph's dependency edges.\n\n @param [in] graph - instance of the graph to get the edges from.\n @param [out] from - pointer to the graph nodes to return edge endpoints.\n @param [out] to - pointer to the graph nodes to return edge endpoints.\n @param [out] numEdges - returns number of edges.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n from and to may both be NULL, in which case this function only returns the number of edges in\n numEdges. Otherwise, numEdges entries will be filled in. If numEdges is higher than the actual\n number of edges, the remaining entries in from and to will be set to NULL, and the number of\n edges actually returned will be written to numEdges\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphGetEdges(
        graph: hipGraph_t,
        from: *mut hipGraphNode_t,
        to: *mut hipGraphNode_t,
        numEdges: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns graph nodes.\n\n @param [in] graph - instance of graph to get the nodes.\n @param [out] nodes - pointer to return the  graph nodes.\n @param [out] numNodes - returns number of graph nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n nodes may be NULL, in which case this function will return the number of nodes in numNodes.\n Otherwise, numNodes entries will be filled in. If numNodes is higher than the actual number of\n nodes, the remaining entries in nodes will be set to NULL, and the number of nodes actually\n obtained will be returned in numNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphGetNodes(
        graph: hipGraph_t,
        nodes: *mut hipGraphNode_t,
        numNodes: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns graph's root nodes.\n\n @param [in] graph - instance of the graph to get the nodes.\n @param [out] pRootNodes - pointer to return the graph's root nodes.\n @param [out] pNumRootNodes - returns the number of graph's root nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pRootNodes may be NULL, in which case this function will return the number of root nodes in\n pNumRootNodes. Otherwise, pNumRootNodes entries will be filled in. If pNumRootNodes is higher\n than the actual number of root nodes, the remaining entries in pRootNodes will be set to NULL,\n and the number of nodes actually obtained will be returned in pNumRootNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphGetRootNodes(
        graph: hipGraph_t,
        pRootNodes: *mut hipGraphNode_t,
        pNumRootNodes: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a node's dependencies.\n\n @param [in] node - graph node to get the dependencies from.\n @param [out] pDependencies - pointer to to return the dependencies.\n @param [out] pNumDependencies -  returns the number of graph node dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pDependencies may be NULL, in which case this function will return the number of dependencies in\n pNumDependencies. Otherwise, pNumDependencies entries will be filled in. If pNumDependencies is\n higher than the actual number of dependencies, the remaining entries in pDependencies will be set\n to NULL, and the number of nodes actually obtained will be returned in pNumDependencies.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeGetDependencies(
        node: hipGraphNode_t,
        pDependencies: *mut hipGraphNode_t,
        pNumDependencies: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a node's dependent nodes.\n\n @param [in] node - graph node to get the Dependent nodes from.\n @param [out] pDependentNodes - pointer to return the graph dependent nodes.\n @param [out] pNumDependentNodes - returns the number of graph node dependent nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n DependentNodes may be NULL, in which case this function will return the number of dependent nodes\n in pNumDependentNodes. Otherwise, pNumDependentNodes entries will be filled in. If\n pNumDependentNodes is higher than the actual number of dependent nodes, the remaining entries in\n pDependentNodes will be set to NULL, and the number of nodes actually obtained will be returned\n in pNumDependentNodes.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeGetDependentNodes(
        node: hipGraphNode_t,
        pDependentNodes: *mut hipGraphNode_t,
        pNumDependentNodes: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a node's type.\n\n @param [in] node - instance of the graph to add dependencies.\n @param [out] pType - pointer to the return the type\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeGetType(node: hipGraphNode_t, pType: *mut hipGraphNodeType) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Remove a node from the graph.\n\n @param [in] node - graph node to remove\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphDestroyNode(node: hipGraphNode_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Clones a graph.\n\n @param [out] pGraphClone - Returns newly created cloned graph.\n @param [in] originalGraph - original graph to clone from.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphClone(pGraphClone: *mut hipGraph_t, originalGraph: hipGraph_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Finds a cloned version of a node.\n\n @param [out] pNode - Returns the cloned node.\n @param [in] originalNode - original node handle.\n @param [in] clonedGraph - Cloned graph to query.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphNodeFindInClone(
        pNode: *mut hipGraphNode_t,
        originalNode: hipGraphNode_t,
        clonedGraph: hipGraph_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an executable graph from a graph\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [out] pErrorNode - pointer to error node in case error occured in graph instantiation,\n  it could modify the correponding node.\n @param [out] pLogBuffer - pointer to log buffer.\n @param [out] bufferSize - the size of log buffer.\n\n @returns #hipSuccess, #hipErrorOutOfMemory\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n"]
    pub fn hipGraphInstantiate(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        pErrorNode: *mut hipGraphNode_t,
        pLogBuffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an executable graph from a graph.\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [in] flags - Flags to control instantiation.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.It does not support\n any of flag and is behaving as hipGraphInstantiate."]
    pub fn hipGraphInstantiateWithFlags(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an executable graph from a graph.\n\n @param [out] pGraphExec - pointer to instantiated executable graph that is created.\n @param [in] graph - instance of graph to instantiate.\n @param [in] instantiateParams - Graph Instantiate Params\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphInstantiateWithParams(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        instantiateParams: *mut hipGraphInstantiateParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief launches an executable graph in a stream\n\n @param [in] graphExec - instance of executable graph to launch.\n @param [in] stream - instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphLaunch(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief uploads an executable graph in a stream\n\n @param [in] graphExec - instance of executable graph to launch.\n @param [in] stream - instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphUpload(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a kernel execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - pointer to the dependencies on the kernel execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] nodeParams - pointer to the parameters for the node.\n @returns #hipSuccess, #hipErrorInvalidValue.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *mut hipGraphNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Return the flags on executable graph.\n\n @param [in] graphExec - Executable graph to get the flags.\n @param [out] flags - Flags used to instantiate this executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecGetFlags(
        graphExec: hipGraphExec_t,
        flags: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates parameters of a created node.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] nodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction, #hipErrorNotSupported.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphNodeSetParams(
        node: hipGraphNode_t,
        nodeParams: *mut hipGraphNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates parameters of a created node on executable graph.\n\n @param [in] graphExec - instance of executable graph.\n @param [in] node - instance of the node to set parameters to.\n @param [in] nodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction, #hipErrorNotSupported.\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecNodeSetParams(
        graphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        nodeParams: *mut hipGraphNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys an executable graph\n\n @param [in] graphExec - instance of executable graph to destry.\n\n @returns #hipSuccess.\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecDestroy(graphExec: hipGraphExec_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Check whether an executable graph can be updated with a graph and perform the update if  *\n possible.\n\n @param [in] hGraphExec - instance of executable graph to update.\n @param [in] hGraph - graph that contains the updated parameters.\n @param [in] hErrorNode_out -  node which caused the permissibility check to forbid the update.\n @param [in] updateResult_out - Whether the graph update was permitted.\n @returns #hipSuccess, #hipErrorGraphExecUpdateFailure\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecUpdate(
        hGraphExec: hipGraphExec_t,
        hGraph: hipGraph_t,
        hErrorNode_out: *mut hipGraphNode_t,
        updateResult_out: *mut hipGraphExecUpdateResult,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a kernel execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - pointer to the dependencies on the kernel execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pNodeParams - pointer to the parameters to the kernel execution node on the GPU.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddKernelNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets kernel node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipKernelNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a kernel node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a kernel node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecKernelNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] phGraphNode - pointer to graph node to create.\n @param [in] hGraph - instance of graph to add the created node.\n @param [in] dependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] copyParams - const pointer to the parameters for the memory copy.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphAddMemcpyNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        copyParams: *const HIP_MEMCPY3D,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pCopyParams - const pointer to the parameters for the memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pCopyParams: *const hipMemcpy3DParms,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a memcpy node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipMemcpy3DParms,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a node attribute.\n\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] attr - the attribute node is set to.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeSetAttribute(
        hNode: hipGraphNode_t,
        attr: hipLaunchAttributeID,
        value: *const hipLaunchAttributeValue,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a node attribute.\n\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] attr - the attribute node is set to.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeGetAttribute(
        hNode: hipGraphNode_t,
        attr: hipLaunchAttributeID,
        value: *mut hipLaunchAttributeValue,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a 1D memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNode1D(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to perform a 1-dimensional copy.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParams1D(
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional\n copy.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] src - pointer to memory address to the source.\n @param [in] count - the size of the memory to copy.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParams1D(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memcpy node to copy from a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNodeFromSymbol(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to copy from a symbol on the device.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParamsFromSymbol(
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy from a symbol on the\n * device.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] dst - pointer to memory address to the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParamsFromSymbol(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memcpy node to copy to a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - pointer to graph node to create.\n @param [in] graph - instance of graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemcpyNodeToSymbol(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to copy to a symbol on the device.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParamsToSymbol(
        node: hipGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy to a symbol on the\n device.\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] symbol - Device symbol address.\n @param [in] src - pointer to memory address of the src.\n @param [in] count - the size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - the type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParamsToSymbol(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memset node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pMemsetParams - const pointer to the parameters for the memory set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemsetNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pMemsetParams: *const hipMemsetParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a memset node's parameters.\n\n @param [in] node - instane of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemsetNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemsetParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a memset node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemsetNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memset node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecMemsetNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a host execution node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] pNodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddHostNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a host node's parameters.\n\n @param [in] node - instane of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphHostNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipHostNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a host node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphHostNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a host node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecHostNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a child graph node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] childGraph - the graph to clone into this node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddChildGraphNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        childGraph: hipGraph_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a handle to the embedded graph of a child graph node.\n\n @param [in] node - instane of the node to get child graph.\n @param [out] pGraph - pointer to get the graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphChildGraphNodeGetGraph(
        node: hipGraphNode_t,
        pGraph: *mut hipGraph_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates node parameters in the child graph node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - node from the graph which was used to instantiate graphExec.\n @param [in] childGraph - child graph with updated parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecChildGraphNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        childGraph: hipGraph_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an empty node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node is add to.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddEmptyNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an event record node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddEventRecordNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the event associated with an event record node.\n\n @param [in] node -  instane of the node to get event from.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventRecordNodeGetEvent(
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets an event record node's event.\n\n @param [in] node - instane of the node to set event to.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventRecordNodeSetEvent(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecEventRecordNodeSetEvent(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an event wait node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create and add to the graph.\n @param [in] graph - instane of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependenties.\n @param [in] numDependencies - the number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddEventWaitNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the event associated with an event wait node.\n\n @param [in] node -  instane of the node to get event from.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventWaitNodeGetEvent(
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets an event wait node's event.\n\n @param [in] node - instane of the node to set event to.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphEventWaitNodeSetEvent(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecEventWaitNodeSetEvent(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memory allocation node and adds it to a graph\n\n @param [out] pGraphNode      - Pointer to the graph node to create and add to the graph\n @param [in] graph            - Instane of the graph the node to be added\n @param [in] pDependencies    - Const pointer to the node dependenties\n @param [in] numDependencies  - The number of dependencies\n @param [in] pNodeParams      - Node parameters for memory allocation\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemAllocNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *mut hipMemAllocNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns parameters for memory allocation node\n\n @param [in] node         - Memory allocation node for a query\n @param [out] pNodeParams - Parameters for the specified memory allocation node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemAllocNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemAllocNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memory free node and adds it to a graph\n\n @param [out] pGraphNode      - Pointer to the graph node to create and add to the graph\n @param [in] graph            - Instane of the graph the node to be added\n @param [in] pDependencies    - Const pointer to the node dependenties\n @param [in] numDependencies  - The number of dependencies\n @param [in] dev_ptr          - Pointer to the memory to be freed\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddMemFreeNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns parameters for memory free node\n\n @param [in] node     - Memory free node for a query\n @param [out] dev_ptr - Device pointer for the specified memory free node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphMemFreeNodeGetParams(
        node: hipGraphNode_t,
        dev_ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the mem attribute for graphs.\n\n @param [in] device - device the attr is get for.\n @param [in] attr - attr to get.\n @param [out] value - value for specific attr.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the mem attribute for graphs.\n\n @param [in] device - device the attr is set for.\n @param [in] attr - attr to set.\n @param [in] value - value for specific attr.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceSetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Free unused memory on specific device used for graph back to OS.\n\n @param [in] device - device the memory is used for graphs\n @returns #hipSuccess, #hipErrorInvalidDevice\n\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDeviceGraphMemTrim(device: ::std::os::raw::c_int) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create an instance of userObject to manage lifetime of a resource.\n\n @param [out] object_out - pointer to instace of userobj.\n @param [in] ptr - pointer to pass to destroy function.\n @param [in] destroy - destroy callback to remove resource.\n @param [in] initialRefcount - reference to resource.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipUserObjectCreate(
        object_out: *mut hipUserObject_t,
        ptr: *mut ::std::os::raw::c_void,
        destroy: hipHostFn_t,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Release number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipUserObjectRelease(
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Retain number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipUserObjectRetain(
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Retain user object for graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphRetainUserObject(
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Release user object from graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphReleaseUserObject(
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Write a DOT file describing graph structure.\n\n @param [in] graph - graph object for which DOT file has to be generated.\n @param [in] path - path to write the DOT file.\n @param [in] flags - Flags from hipGraphDebugDotFlags to get additional node information.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOperatingSystem\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphDebugDotPrint(
        graph: hipGraph_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Copies attributes from source node to destination node.\n\n Copies attributes from source node to destination node.\n Both node must have the same context.\n\n @param [out] hDst - Destination node.\n @param [in] hSrc - Source node.\n For list of attributes see ::hipKernelNodeAttrID.\n\n @returns #hipSuccess, #hipErrorInvalidContext\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphKernelNodeCopyAttributes(
        hSrc: hipGraphNode_t,
        hDst: hipGraphNode_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Enables or disables the specified node in the given graphExec\n\n Sets hNode to be either enabled or disabled. Disabled nodes are functionally equivalent\n to empty nodes until they are reenabled. Existing node parameters are not affected by\n disabling/enabling the node.\n\n The node is identified by the corresponding hNode in the non-executable graph, from which the\n executable graph was instantiated.\n\n hNode must not have been removed from the original graph.\n\n @note Currently only kernel, memset and memcpy nodes are supported.\n\n @param [in] hGraphExec - The executable graph in which to set the specified node.\n @param [in] hNode      - Node from the graph from which graphExec was instantiated.\n @param [in] isEnabled  - Node is enabled if != 0, otherwise the node is disabled.\n\n @returns #hipSuccess, #hipErrorInvalidValue,\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphNodeSetEnabled(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        isEnabled: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Query whether a node in the given graphExec is enabled\n\n Sets isEnabled to 1 if hNode is enabled, or 0 if it is disabled.\n\n The node is identified by the corresponding node in the non-executable graph, from which the\n executable graph was instantiated.\n\n hNode must not have been removed from the original graph.\n\n @note Currently only kernel, memset and memcpy nodes are supported.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [out] isEnabled  - Location to return the enabled status of the node.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphNodeGetEnabled(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        isEnabled: *mut ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a external semaphor wait node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] nodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddExternalSemaphoresWaitNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *const hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a external semaphor signal node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] nodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphAddExternalSemaphoresSignalNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *const hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore signal node.\n\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExternalSemaphoresSignalNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore wait node.\n\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExternalSemaphoresWaitNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns external semaphore signal node params.\n\n @param [in]   hNode       - Node from the graph from which graphExec was instantiated.\n @param [out]  params_out  - Pointer to params.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExternalSemaphoresSignalNodeGetParams(
        hNode: hipGraphNode_t,
        params_out: *mut hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns external semaphore wait node params.\n\n @param [in]   hNode       - Node from the graph from which graphExec was instantiated.\n @param [out]  params_out  - Pointer to params.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExternalSemaphoresWaitNodeGetParams(
        hNode: hipGraphNode_t,
        params_out: *mut hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore signal node in the given graphExec.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore wait node in the given graphExec.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets a memcpy node's parameters.\n\n @param [in] hNode - instance of the node to get parameters from.\n @param [out] nodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphMemcpyNodeGetParams(
        hNode: hipGraphNode_t,
        nodeParams: *mut HIP_MEMCPY3D,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters.\n\n @param [in] hNode - instance of the node to Set parameters for.\n @param [out] nodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphMemcpyNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *const HIP_MEMCPY3D,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memset node and adds it to a graph.\n\n @param [out] phGraphNode - pointer to graph node to create.\n @param [in] hGraph - instance of graph to add the created node to.\n @param [in] dependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - number of the dependencies.\n @param [in] memsetParams - const pointer to the parameters for the memory set.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphAddMemsetNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        memsetParams: *const HIP_MEMSET_NODE_PARAMS,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memory free node and adds it to a graph\n\n @param [out] phGraphNode - Pointer to the graph node to create and add to the graph\n @param [in]  hGraph - Instane of the graph the node to be added\n @param [in]  dependencies - Const pointer to the node dependenties\n @param [in]  numDependencies - The number of dependencies\n @param [in]  dptr - Pointer to the memory to be freed\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphAddMemFreeNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] copyParams - const pointer to the memcpy node params.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphExecMemcpyNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        copyParams: *const HIP_MEMCPY3D,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the parameters for a memset node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] memsetParams - pointer to the parameters.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipDrvGraphExecMemsetNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        memsetParams: *const HIP_MEMSET_NODE_PARAMS,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Frees an address range reservation made via hipMemAddressReserve\n\n @param [in] devPtr - starting address of the range.\n @param [in] size - size of the range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemAddressFree(devPtr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Reserves an address range\n\n @param [out] ptr - starting address of the reserved range.\n @param [in] size - size of the reservation.\n @param [in] alignment - alignment of the address.\n @param [in] addr - requested starting address of the range.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemAddressReserve(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        addr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates a memory allocation described by the properties and size\n\n @param [out] handle - value of the returned handle.\n @param [in] size - size of the allocation.\n @param [in] prop - properties of the allocation.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemCreate(
        handle: *mut hipMemGenericAllocationHandle_t,
        size: usize,
        prop: *const hipMemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Exports an allocation to a requested shareable handle type.\n\n @param [out] shareableHandle - value of the returned handle.\n @param [in] handle - handle to share.\n @param [in] handleType - type of the shareable handle.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: hipMemGenericAllocationHandle_t,
        handleType: hipMemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the access flags set for the given location and ptr.\n\n @param [out] flags - flags for this location.\n @param [in] location - target location.\n @param [in] ptr - address to check the access flags.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemGetAccess(
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const hipMemLocation,
        ptr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Calculates either the minimal or recommended granularity.\n\n @param [out] granularity - returned granularity.\n @param [in] prop - location properties.\n @param [in] option - determines which granularity to return.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows.\n"]
    pub fn hipMemGetAllocationGranularity(
        granularity: *mut usize,
        prop: *const hipMemAllocationProp,
        option: hipMemAllocationGranularity_flags,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the property structure of the given handle.\n\n @param [out] prop - properties of the given handle.\n @param [in] handle - handle to perform the query on.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux under development on Windows."]
    pub fn hipMemGetAllocationPropertiesFromHandle(
        prop: *mut hipMemAllocationProp,
        handle: hipMemGenericAllocationHandle_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Imports an allocation from a requested shareable handle type.\n\n @param [out] handle - returned value.\n @param [in] osHandle - shareable handle representing the memory allocation.\n @param [in] shHandleType - handle type.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemImportFromShareableHandle(
        handle: *mut hipMemGenericAllocationHandle_t,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: hipMemAllocationHandleType,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Maps an allocation handle to a reserved virtual address range.\n\n @param [in] ptr - address where the memory will be mapped.\n @param [in] size - size of the mapping.\n @param [in] offset - offset into the memory, currently must be zero.\n @param [in] handle - memory allocation to be mapped.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemMap(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        offset: usize,
        handle: hipMemGenericAllocationHandle_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Maps or unmaps subregions of sparse HIP arrays and sparse HIP mipmapped arrays.\n\n @param [in] mapInfoList - list of hipArrayMapInfo.\n @param [in] count - number of hipArrayMapInfo in mapInfoList.\n @param [in] stream - stream identifier for the stream to use for map or unmap operations.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemMapArrayAsync(
        mapInfoList: *mut hipArrayMapInfo,
        count: ::std::os::raw::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Release a memory handle representing a memory allocation which was previously allocated through hipMemCreate.\n\n @param [in] handle - handle of the memory allocation.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRelease(handle: hipMemGenericAllocationHandle_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the allocation handle of the backing memory allocation given the address.\n\n @param [out] handle - handle representing addr.\n @param [in] addr - address to look up.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemRetainAllocationHandle(
        handle: *mut hipMemGenericAllocationHandle_t,
        addr: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the access flags for each location specified in desc for the given virtual address range.\n\n @param [in] ptr - starting address of the virtual address range.\n @param [in] size - size of the range.\n @param [in] desc - array of hipMemAccessDesc.\n @param [in] count - number of hipMemAccessDesc in desc.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemSetAccess(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        desc: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Unmap memory allocation of a given address range.\n\n @param [in] ptr - starting address of the range to unmap.\n @param [in] size - size of the virtual address range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning : This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @note  This API is implemented on Linux, under development on Windows."]
    pub fn hipMemUnmap(ptr: *mut ::std::os::raw::c_void, size: usize) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Maps a graphics resource for access.\n\n @param [in] count - Number of resources to map.\n @param [in] resources - Pointer of resources to map.\n @param [in] stream - Stream for synchronization.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorInvalidResourceHandle\n"]
    pub fn hipGraphicsMapResources(
        count: ::std::os::raw::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Get an array through which to access a subresource of a mapped graphics resource.\n\n @param [out] array - Pointer of array through which a subresource of resource may be accessed.\n @param [in] resource - Mapped resource to access.\n @param [in] arrayIndex - Array index for the subresource to access.\n @param [in] mipLevel - Mipmap level for the subresource to access.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  In this API, the value of arrayIndex higher than zero is currently not supported.\n"]
    pub fn hipGraphicsSubResourceGetMappedArray(
        array: *mut hipArray_t,
        resource: hipGraphicsResource_t,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets device accessible address of a graphics resource.\n\n @param [out] devPtr - Pointer of device through which graphic resource may be accessed.\n @param [out] size - Size of the buffer accessible from devPtr.\n @param [in] resource - Mapped resource to access.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGraphicsResourceGetMappedPointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
        resource: hipGraphicsResource_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Unmaps graphics resources.\n\n @param [in] count - Number of resources to unmap.\n @param [in] resources - Pointer of resources to unmap.\n @param [in] stream - Stream for synchronization.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorContextIsDestroyed\n"]
    pub fn hipGraphicsUnmapResources(
        count: ::std::os::raw::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Unregisters a graphics resource.\n\n @param [in] resource - Graphics resources to unregister.\n\n @returns #hipSuccess\n"]
    pub fn hipGraphicsUnregisterResource(resource: hipGraphicsResource_t) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Create a surface object.\n\n @param [out] pSurfObject  Pointer of surface object to be created.\n @param [in] pResDesc  Pointer of suface object descriptor.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipCreateSurfaceObject(
        pSurfObject: *mut hipSurfaceObject_t,
        pResDesc: *const hipResourceDesc,
    ) -> hipError_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a surface object.\n\n @param [in] surfaceObject  Surface object to be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDestroySurfaceObject(surfaceObject: hipSurfaceObject_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy_spt(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpyToSymbol_spt(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpyFromSymbol_spt(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy2D_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy2DFromArray_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy3D_spt(p: *const hipMemcpy3DParms) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemset_spt(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemsetAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemset2D_spt(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemset2DAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        pitch: usize,
        value: ::std::os::raw::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemset3DAsync_spt(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemset3D_spt(
        pitchedDevPtr: hipPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpyAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy3DAsync_spt(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy2DAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpyFromSymbolAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpyToSymbolAsync_spt(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpyFromArray_spt(
        dst: *mut ::std::os::raw::c_void,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy2DToArray_spt(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy2DFromArrayAsync_spt(
        dst: *mut ::std::os::raw::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipMemcpy2DToArrayAsync_spt(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::std::os::raw::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamQuery_spt(stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamSynchronize_spt(stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamGetPriority_spt(
        stream: hipStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamWaitEvent_spt(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamGetFlags_spt(
        stream: hipStream_t,
        flags: *mut ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamAddCallback_spt(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipEventRecord_spt(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipLaunchCooperativeKernel_spt(
        f: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: u32,
        hStream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipLaunchKernel_spt(
        function_address: *const ::std::os::raw::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipGraphLaunch_spt(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamBeginCapture_spt(stream: hipStream_t, mode: hipStreamCaptureMode)
        -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamEndCapture_spt(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamIsCapturing_spt(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamGetCaptureInfo_spt(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipStreamGetCaptureInfo_v2_spt(
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t;
}
unsafe extern "C" {
    pub fn hipLaunchHostFunc_spt(
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> hipError_t;
}
pub const hipDataType_HIP_R_32F: hipDataType = 0;
pub const hipDataType_HIP_R_64F: hipDataType = 1;
pub const hipDataType_HIP_R_16F: hipDataType = 2;
pub const hipDataType_HIP_R_8I: hipDataType = 3;
pub const hipDataType_HIP_C_32F: hipDataType = 4;
pub const hipDataType_HIP_C_64F: hipDataType = 5;
pub const hipDataType_HIP_C_16F: hipDataType = 6;
pub const hipDataType_HIP_C_8I: hipDataType = 7;
pub const hipDataType_HIP_R_8U: hipDataType = 8;
pub const hipDataType_HIP_C_8U: hipDataType = 9;
pub const hipDataType_HIP_R_32I: hipDataType = 10;
pub const hipDataType_HIP_C_32I: hipDataType = 11;
pub const hipDataType_HIP_R_32U: hipDataType = 12;
pub const hipDataType_HIP_C_32U: hipDataType = 13;
pub const hipDataType_HIP_R_16BF: hipDataType = 14;
pub const hipDataType_HIP_C_16BF: hipDataType = 15;
pub const hipDataType_HIP_R_4I: hipDataType = 16;
pub const hipDataType_HIP_C_4I: hipDataType = 17;
pub const hipDataType_HIP_R_4U: hipDataType = 18;
pub const hipDataType_HIP_C_4U: hipDataType = 19;
pub const hipDataType_HIP_R_16I: hipDataType = 20;
pub const hipDataType_HIP_C_16I: hipDataType = 21;
pub const hipDataType_HIP_R_16U: hipDataType = 22;
pub const hipDataType_HIP_C_16U: hipDataType = 23;
pub const hipDataType_HIP_R_64I: hipDataType = 24;
pub const hipDataType_HIP_C_64I: hipDataType = 25;
pub const hipDataType_HIP_R_64U: hipDataType = 26;
pub const hipDataType_HIP_C_64U: hipDataType = 27;
pub const hipDataType_HIP_R_8F_E4M3: hipDataType = 28;
pub const hipDataType_HIP_R_8F_E5M2: hipDataType = 29;
pub const hipDataType_HIP_R_8F_E4M3_FNUZ: hipDataType = 1000;
pub const hipDataType_HIP_R_8F_E5M2_FNUZ: hipDataType = 1001;
pub type hipDataType = ::std::os::raw::c_uint;
pub const hipLibraryPropertyType_HIP_LIBRARY_MAJOR_VERSION: hipLibraryPropertyType = 0;
pub const hipLibraryPropertyType_HIP_LIBRARY_MINOR_VERSION: hipLibraryPropertyType = 1;
pub const hipLibraryPropertyType_HIP_LIBRARY_PATCH_LEVEL: hipLibraryPropertyType = 2;
pub type hipLibraryPropertyType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocrand_generator_base_type {
    _unused: [u8; 0],
}
#[doc = " \\cond ROCRAND_DOCS_TYPEDEFS\n rocRAND random number generator (opaque)"]
pub type rocrand_generator = *mut rocrand_generator_base_type;
#[doc = "< No errors"]
pub const rocrand_status_ROCRAND_STATUS_SUCCESS: rocrand_status = 0;
#[doc = "< Header file and linked library version do not match"]
pub const rocrand_status_ROCRAND_STATUS_VERSION_MISMATCH: rocrand_status = 100;
#[doc = "< Generator was not created using rocrand_create_generator"]
pub const rocrand_status_ROCRAND_STATUS_NOT_CREATED: rocrand_status = 101;
#[doc = "< Memory allocation failed during execution"]
pub const rocrand_status_ROCRAND_STATUS_ALLOCATION_FAILED: rocrand_status = 102;
#[doc = "< Generator type is wrong"]
pub const rocrand_status_ROCRAND_STATUS_TYPE_ERROR: rocrand_status = 103;
#[doc = "< Argument out of range"]
pub const rocrand_status_ROCRAND_STATUS_OUT_OF_RANGE: rocrand_status = 104;
#[doc = "< Requested size is not a multiple of quasirandom generator's dimension,\n< or requested size is not even (see rocrand_generate_normal()),\n< or pointer is misaligned (see rocrand_generate_normal())"]
pub const rocrand_status_ROCRAND_STATUS_LENGTH_NOT_MULTIPLE: rocrand_status = 105;
#[doc = "< GPU does not have double precision"]
pub const rocrand_status_ROCRAND_STATUS_DOUBLE_PRECISION_REQUIRED: rocrand_status = 106;
#[doc = "< Kernel launch failure"]
pub const rocrand_status_ROCRAND_STATUS_LAUNCH_FAILURE: rocrand_status = 107;
#[doc = "< Internal library error"]
pub const rocrand_status_ROCRAND_STATUS_INTERNAL_ERROR: rocrand_status = 108;
#[doc = " \\brief rocRAND function call status type"]
pub type rocrand_status = ::std::os::raw::c_uint;
#[doc = "< Default pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_DEFAULT: rocrand_rng_type = 400;
#[doc = "< XORWOW pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_XORWOW: rocrand_rng_type = 401;
#[doc = "< MRG32k3a pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MRG32K3A: rocrand_rng_type = 402;
#[doc = "< Mersenne Twister MTGP32 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MTGP32: rocrand_rng_type = 403;
#[doc = "< PHILOX-4x32-10 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_PHILOX4_32_10: rocrand_rng_type = 404;
#[doc = "< MRG31k3p pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MRG31K3P: rocrand_rng_type = 405;
#[doc = "< LFSR113 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_LFSR113: rocrand_rng_type = 406;
#[doc = "< Mersenne Twister MT19937 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MT19937: rocrand_rng_type = 407;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY2_32_20: rocrand_rng_type = 408;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY2_64_20: rocrand_rng_type = 409;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY4_32_20: rocrand_rng_type = 410;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY4_64_20: rocrand_rng_type = 411;
#[doc = "< Default quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_DEFAULT: rocrand_rng_type = 500;
#[doc = "< Sobol32 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SOBOL32: rocrand_rng_type = 501;
#[doc = "< Scrambled Sobol32 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL32: rocrand_rng_type = 502;
#[doc = "< Sobol64 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SOBOL64: rocrand_rng_type = 504;
#[doc = "< Scrambled Sobol64 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL64: rocrand_rng_type = 505;
#[doc = " \\brief rocRAND generator type"]
pub type rocrand_rng_type = ::std::os::raw::c_uint;
#[doc = "< Best ordering for pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_BEST: rocrand_ordering = 100;
#[doc = "< Default ordering for pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_DEFAULT: rocrand_ordering = 101;
#[doc = "< Fast lower quality pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_SEEDED: rocrand_ordering = 102;
#[doc = "< Legacy ordering for pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_LEGACY: rocrand_ordering = 103;
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_DYNAMIC: rocrand_ordering = 104;
#[doc = "< n-dimensional ordering for quasirandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_QUASI_DEFAULT: rocrand_ordering = 201;
#[doc = " \\brief rocRAND generator ordering"]
pub type rocrand_ordering = ::std::os::raw::c_uint;
pub const rocrand_direction_vector_set_ROCRAND_DIRECTION_VECTORS_32_JOEKUO6:
    rocrand_direction_vector_set = 101;
pub const rocrand_direction_vector_set_ROCRAND_SCRAMBLED_DIRECTION_VECTORS_32_JOEKUO6:
    rocrand_direction_vector_set = 102;
pub const rocrand_direction_vector_set_ROCRAND_DIRECTION_VECTORS_64_JOEKUO6:
    rocrand_direction_vector_set = 103;
pub const rocrand_direction_vector_set_ROCRAND_SCRAMBLED_DIRECTION_VECTORS_64_JOEKUO6:
    rocrand_direction_vector_set = 104;
#[doc = " \\brief rocRAND vector set"]
pub type rocrand_direction_vector_set = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief Creates a new random number generator.\n\n Creates a new pseudo random number generator of type \\p rng_type\n and returns it in \\p generator.\n\n Values for \\p rng_type are:\n - ROCRAND_RNG_PSEUDO_XORWOW\n - ROCRAND_RNG_PSEUDO_MRG31K3P\n - ROCRAND_RNG_PSEUDO_MRG32K3A\n - ROCRAND_RNG_PSEUDO_MTGP32\n - ROCRAND_RNG_PSEUDO_PHILOX4_32_10\n - ROCRAND_RNG_PSEUDO_LFSR113\n - ROCRAND_RNG_PSEUDO_THREEFRY2_32_20\n - ROCRAND_RNG_PSEUDO_THREEFRY2_64_20\n - ROCRAND_RNG_PSEUDO_THREEFRY4_32_20\n - ROCRAND_RNG_PSEUDO_THREEFRY4_64_20\n - ROCRAND_RNG_QUASI_SOBOL32\n - ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL32\n - ROCRAND_RNG_QUASI_SOBOL64\n - ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL64\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of generator to create\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED, if memory could not be allocated \\n\n - ROCRAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - ROCRAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - ROCRAND_STATUS_SUCCESS if generator was created successfully \\n\n"]
    pub fn rocrand_create_generator(
        generator: *mut rocrand_generator,
        rng_type: rocrand_rng_type,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a new host random number generator.\n\n Creates a new pseudo random number generator of type \\p rng_type\n and returns it in \\p generator. This generator is executed on the host rather than\n on a device, and it is enqueued on the stream associated with the generator.\n\n All generators are supported.\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of generator to create\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED, if memory could not be allocated \\n\n - ROCRAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - ROCRAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - ROCRAND_STATUS_SUCCESS if generator was created successfully \\n\n"]
    pub fn rocrand_create_generator_host(
        generator: *mut rocrand_generator,
        rng_type: rocrand_rng_type,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a new host random number generator, similar to `rocrand_create_generator_host`.\n   The exception is that, instead of enqueuing the host function in the stream,\n   execution happens synchronously with respect to the calling thread and the stream is ignored."]
    pub fn rocrand_create_generator_host_blocking(
        generator: *mut rocrand_generator,
        rng_type: rocrand_rng_type,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys random number generator.\n\n Destroys random number generator and frees related memory.\n\n \\param generator - Generator to be destroyed\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_SUCCESS if generator was destroyed successfully \\n"]
    pub fn rocrand_destroy_generator(generator: rocrand_generator) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 32-bit unsigned integers.\n\n Generates \\p n uniformly distributed 32-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^32, including \\p 0 and\n excluding \\p 2^32.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 32-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_uint,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 64-bit unsigned integers.\n\n Generates \\p n uniformly distributed 64-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^64, including \\p 0 and\n excluding \\p 2^64.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 64-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_TYPE_ERROR if the generator can't natively generate 64-bit random numbers \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_long_long(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_ulonglong,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 8-bit unsigned integers.\n\n Generates \\p n uniformly distributed 8-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^8, including \\p 0 and\n excluding \\p 2^8.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 8-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_char(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_uchar,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 16-bit unsigned integers.\n\n Generates \\p n uniformly distributed 16-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^16, including \\p 0 and\n excluding \\p 2^16.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 16-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_short(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_ushort,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed \\p float values.\n\n Generates \\p n uniformly distributed 32-bit floating-point values\n and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0f and \\p 1.0f, excluding \\p 0.0f and\n including \\p 1.0f.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>float</tt>s to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_uniform(
        generator: rocrand_generator,
        output_data: *mut f32,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed double-precision floating-point values.\n\n Generates \\p n uniformly distributed 64-bit double-precision floating-point\n values and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0 and \\p 1.0, excluding \\p 0.0 and\n including \\p 1.0.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>double</tt>s to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_uniform_double(
        generator: rocrand_generator,
        output_data: *mut f64,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed half-precision floating-point values.\n\n Generates \\p n uniformly distributed 16-bit half-precision floating-point\n values and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0 and \\p 1.0, excluding \\p 0.0 and\n including \\p 1.0.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>half</tt>s to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_uniform_half(
        generator: rocrand_generator,
        output_data: *mut half,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates normally distributed \\p float values.\n\n Generates \\p n normally distributed distributed 32-bit floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>float</tt>s to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_normal(
        generator: rocrand_generator,
        output_data: *mut f32,
        n: usize,
        mean: f32,
        stddev: f32,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates normally distributed \\p double values.\n\n Generates \\p n normally distributed 64-bit double-precision floating-point\n numbers and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>double</tt>s to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_normal_double(
        generator: rocrand_generator,
        output_data: *mut f64,
        n: usize,
        mean: f64,
        stddev: f64,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates normally distributed \\p half values.\n\n Generates \\p n normally distributed 16-bit half-precision floating-point\n numbers and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>half</tt>s to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_normal_half(
        generator: rocrand_generator,
        output_data: *mut half,
        n: usize,
        mean: half,
        stddev: half,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates log-normally distributed \\p float values.\n\n Generates \\p n log-normally distributed 32-bit floating-point values\n and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>float</tt>s to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_log_normal(
        generator: rocrand_generator,
        output_data: *mut f32,
        n: usize,
        mean: f32,
        stddev: f32,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates log-normally distributed \\p double values.\n\n Generates \\p n log-normally distributed 64-bit double-precision floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>double</tt>s to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_log_normal_double(
        generator: rocrand_generator,
        output_data: *mut f64,
        n: usize,
        mean: f64,
        stddev: f64,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates log-normally distributed \\p half values.\n\n Generates \\p n log-normally distributed 16-bit half-precision floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>half</tt>s to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_log_normal_half(
        generator: rocrand_generator,
        output_data: *mut half,
        n: usize,
        mean: half,
        stddev: half,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates Poisson-distributed 32-bit unsigned integers.\n\n Generates \\p n Poisson-distributed 32-bit unsigned integers and\n saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 32-bit unsigned integers to generate\n \\param lambda - lambda for the Poisson distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if lambda is non-positive \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_poisson(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_uint,
        n: usize,
        lambda: f64,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes the generator's state on GPU or host.\n\n Initializes the generator's state on GPU or host. User it not\n required to call this function before using a generator.\n\n If rocrand_initialize() was not called for a generator, it will be\n automatically called by functions which generates random numbers like\n rocrand_generate(), rocrand_generate_uniform() etc.\n\n \\param generator - Generator to initialize\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_SUCCESS if the seeds were generated successfully \\n"]
    pub fn rocrand_initialize_generator(generator: rocrand_generator) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the current stream for kernel launches.\n\n Sets the current stream for all kernel launches of the generator.\n All functions will use this stream.\n\n \\param generator - Generator to modify\n \\param stream - Stream to use or NULL for default stream\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_SUCCESS if stream was set successfully \\n"]
    pub fn rocrand_set_stream(generator: rocrand_generator, stream: hipStream_t) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the seed of a pseudo-random number generator.\n\n Sets the seed of the pseudo-random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n For an MRG32K3a or MRG31K3p generator the seed value can't be zero. If \\p seed is\n equal to zero and generator's type is ROCRAND_RNG_PSEUDO_MRG32K3A or ROCRAND_RNG_PSEUDO_MRG31K3P,\n value \\p 12345 is used as seed instead.\n\n For a LFSR113 generator seed values must be larger than 1, 7, 15,\n 127. The \\p seed upper and lower 32 bits used as first and\n second seed value. If those values smaller than 2 and/or 8, those\n are increased with 1 and/or 7.\n\n \\param generator - Pseudo-random number generator\n \\param seed - New seed value\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_TYPE_ERROR if the generator is a quasi-random number generator \\n\n - ROCRAND_STATUS_SUCCESS if seed was set successfully \\n"]
    pub fn rocrand_set_seed(
        generator: rocrand_generator,
        seed: ::std::os::raw::c_ulonglong,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the seeds of a pseudo-random number generator.\n\n Sets the seed of the pseudo-random number generator. Currently only for LFSR113\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n Only usable for LFSR113.\n\n For a LFSR113 generator seed values must be bigger than 1, 7, 15,\n 127. If those values smaller, than the requested minimum values [2, 8, 16, 128], then\n it will be increased with the minimum values minus 1 [1, 7, 15, 127].\n\n \\param generator - Pseudo-random number generator\n \\param seed - New seed value\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_TYPE_ERROR if the generator is a quasi-random number generator \\n\n - ROCRAND_STATUS_SUCCESS if seed was set successfully \\n"]
    pub fn rocrand_set_seed_uint4(generator: rocrand_generator, seed: uint4) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the offset of a random number generator.\n\n Sets the absolute offset of the random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's seed.\n\n Absolute offset cannot be set if generator's type is ROCRAND_RNG_PSEUDO_MTGP32 or\n ROCRAND_RNG_PSEUDO_LFSR113.\n\n \\param generator - Random number generator\n \\param offset - New absolute offset\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_SUCCESS if offset was successfully set \\n\n - ROCRAND_STATUS_TYPE_ERROR if generator's type is ROCRAND_RNG_PSEUDO_MTGP32 or\n ROCRAND_RNG_PSEUDO_LFSR113"]
    pub fn rocrand_set_offset(
        generator: rocrand_generator,
        offset: ::std::os::raw::c_ulonglong,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the ordering of a random number generator.\n\n Sets the ordering of the results of a random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's seed.\n\n \\param generator - Random number generator\n \\param order - New ordering of results\n\n The ordering choices for pseudorandom sequences are the following.\n Note that not all generators support all orderings. For details, see\n the Programmer's Guide in the documentation.\n - ROCRAND_ORDERING_PSEUDO_DEFAULT\n - ROCRAND_ORDERING_PSEUDO_LEGACY\n - ROCRAND_ORDERING_PSEUDO_BEST\n - ROCRAND_ORDERING_PSEUDO_SEEDED\n - ROCRAND_ORDERING_PSEUDO_DYNAMIC\n\n For quasirandom sequences there is only one ordering, ROCRAND_ORDERING_QUASI_DEFAULT.\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if the ordering is not valid \\n\n - ROCRAND_STATUS_SUCCESS if the ordering was successfully set \\n\n - ROCRAND_STATUS_TYPE_ERROR if generator's type is not valid"]
    pub fn rocrand_set_ordering(
        generator: rocrand_generator,
        order: rocrand_ordering,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Set the number of dimensions of a quasi-random number generator.\n\n Set the number of dimensions of a quasi-random number generator.\n Supported values of \\p dimensions are 1 to 20000.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n \\param generator - Quasi-random number generator\n \\param dimensions - Number of dimensions\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_TYPE_ERROR if the generator is not a quasi-random number generator \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p dimensions is out of range \\n\n - ROCRAND_STATUS_SUCCESS if the number of dimensions was set successfully \\n"]
    pub fn rocrand_set_quasi_random_generator_dimensions(
        generator: rocrand_generator,
        dimensions: ::std::os::raw::c_uint,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the version number of the library.\n\n Returns in \\p version the version number of the dynamically linked\n rocRAND library.\n\n \\param version - Version of the library\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p version is NULL \\n\n - ROCRAND_STATUS_SUCCESS if the version number was successfully returned \\n"]
    pub fn rocrand_get_version(version: *mut ::std::os::raw::c_int) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Construct the histogram for a Poisson distribution.\n\n Construct the histogram for the Poisson distribution with lambda \\p lambda.\n\n \\param lambda - lambda for the Poisson distribution\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution pointer was null \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if lambda is non-positive \\n\n - ROCRAND_STATUS_SUCCESS if the histogram was constructed successfully \\n"]
    pub fn rocrand_create_poisson_distribution(
        lambda: f64,
        discrete_distribution: *mut rocrand_discrete_distribution,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Construct the histogram for a custom discrete distribution.\n\n Construct the histogram for the discrete distribution of \\p size\n 32-bit unsigned integers from the range [\\p offset, \\p offset + \\p size)\n using \\p probabilities as probabilities.\n\n \\param probabilities - probabilities of the the distribution in host memory\n \\param size - size of \\p probabilities\n \\param offset - offset of values\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution pointer was null \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p size was zero \\n\n - ROCRAND_STATUS_SUCCESS if the histogram was constructed successfully \\n"]
    pub fn rocrand_create_discrete_distribution(
        probabilities: *const f64,
        size: ::std::os::raw::c_uint,
        offset: ::std::os::raw::c_uint,
        discrete_distribution: *mut rocrand_discrete_distribution,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Destroy the histogram array for a discrete distribution.\n\n Destroy the histogram array for a discrete distribution created by\n rocrand_create_poisson_distribution.\n\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution was null \\n\n - ROCRAND_STATUS_SUCCESS if the histogram was destroyed successfully \\n"]
    pub fn rocrand_destroy_discrete_distribution(
        discrete_distribution: rocrand_discrete_distribution,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the vector for 32-bit (scrambled-)sobol generation.\n\n \\param vectors - location where to write the vector pointer to\n\n \\param set - which direction vector set to use\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p set was invalid for this method \\n\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_direction_vectors32(
        vectors: *mut *const ::std::os::raw::c_uint,
        set: rocrand_direction_vector_set,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the vector for 64-bit (scrambled-)sobol generation.\n\n \\param vectors - location where to write the vector pointer to\n\n \\param set - which direction vector set to use\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p set was invalid for this method \\n\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_direction_vectors64(
        vectors: *mut *const ::std::os::raw::c_ulonglong,
        set: rocrand_direction_vector_set,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the scramble constants for 32-bit scrambled sobol generation.\n\n \\param constants - location where to write the constants pointer to\n\n \\return\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_scramble_constants32(
        constants: *mut *const ::std::os::raw::c_uint,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the scramble constants for 64-bit scrambled sobol generation.\n\n \\param constants - location where to write the constants pointer to\n\n \\return\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_scramble_constants64(
        constants: *mut *const ::std::os::raw::c_ulonglong,
    ) -> rocrand_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_39 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_50 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_51 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_52 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_53 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_54 {
    pub _address: u8,
}
pub type rep = ::std::os::raw::c_long;
